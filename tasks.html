<!DOCTYPE html>
<html lang="it-IT">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Language" content="it-IT">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tasks v19.17.40</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/it.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Darker+Grotesque:wght@300;500;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #FF3366;
            --secondary: #6C5CE7;
            --success: #00B894;
            --warning: #F39C12;
            --danger: #E74C3C;

            --dark: #1F2937;
            --light: #FFFFFF;
            --muted: #6B7280;

            --accent: #2563EB;
            --border: #E5E7EB;
            --card-bg: #FFFFFF;
            --input-bg: #F9FAFB;
            --dash-font-scale: 1;
            --dash-title-size: 1.05rem;
            --dash-meta-size: 0.82rem;
            --dash-title-size-mobile: 0.88rem;
            --dash-meta-size-mobile: 0.72rem;
            --mgmt-title-size: 1.1rem;
            --mgmt-meta-size: 0.9rem;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Darker Grotesque', sans-serif;
            background: var(--light);
            color: var(--dark);
            min-height: 100vh;
        }

        .app-container {
            display: grid;
            grid-template-columns: 280px 1fr;
            min-height: 100vh;
        }

        /* Mobile Menu Toggle */
        .menu-toggle {
            display: none;
            position: fixed;
            top: 1rem;
            left: 1rem;
            z-index: 2000;
            background: var(--primary);
            color: white;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 0;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(255, 51, 102, 0.4);
        }

        .quick-add-note {
            display: none;
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            z-index: 2000;
            background: var(--accent);
            color: white;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 0;
            font-size: 2rem;
            font-weight: 300;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(52, 152, 219, 0.4);
            transition: all 0.3s ease;
        }

        .quick-add-note:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 25px rgba(52, 152, 219, 0.6);
        }

        .quick-add-note:active {
            transform: scale(0.95);
        }

        /* Responsive Design */
        @media (min-width: 769px) {
            /* Desktop: assicurati che sidebar sia sempre visibile */
            .sidebar {
                display: block !important;
                position: relative !important;
                left: 0 !important;
            }
            
            .menu-toggle {
                display: none !important;
            }

            .quick-add-note {
                display: flex !important;
                align-items: center;
                justify-content: center;
            }
            
            .sidebar-overlay {
                display: none !important;
            }

            /* Su desktop mostra il testo completo */
            .nav-item::after {
                content: " " attr(data-text);
            }
        }
        
        @media (max-width: 768px) {
            .app-container {
                grid-template-columns: 1fr;
            }

            .menu-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .quick-add-note {
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .sidebar {
                position: fixed;
                left: -100%;
                top: 0;
                width: 280px;
                height: 100vh;
                z-index: 1500;
                transition: left 0.3s ease;
                overflow-y: auto;
            }

            .sidebar.active {
                left: 0;
            }

            .sidebar-overlay {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100vh;
                background: rgba(0, 0, 0, 0.7);
                z-index: 1400;
            }

            .sidebar-overlay.active {
                display: block;
            }
            
            /* Su schermi mobili, overlay sempre nascosto */
            @media (max-width: 768px) {
                .sidebar-overlay,
                .sidebar-overlay.active {
                    display: none !important;
                    visibility: hidden !important;
                    opacity: 0 !important;
                    pointer-events: none !important;
                }
            }

            .main-content {
                padding: 0 0.5rem 1.0rem;
            }

            .page-title {
                font-size: 2rem;
            }

            .page-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 1rem;
            }

            .card {
                padding: 0.5rem;
            }

            .task-card {
                grid-template-columns: auto 1fr;
                gap: 1rem;
            }

            .task-actions {
                grid-column: 1 / -1;
                margin-top: 1rem;
                justify-content: flex-start;
            }

            .modal-content {
                width: 95%;
                padding: 0.75rem;
                max-height: 85vh;
            }

            .form-group {
                margin-bottom: 1rem;
            }

            /* Filtri su mobile */
            .card > div[style*="grid-template-columns"] {
                grid-template-columns: 1fr !important;
            }
            
            /* Badge dashboard su mobile - rimangono su 1 riga ma pi√π piccoli */
            .dashboard-badges {
                gap: 0.3rem !important;
            }
            
            .dashboard-badges .card {
                padding: 0.3rem !important;
            }
            
            .dashboard-badges .card div:first-child {
                font-size: 1.2rem !important;
                margin-bottom: 0.1rem !important;
            }
            
            .dashboard-badges .card div:last-child {
                font-size: 0.6rem !important;
            }

            /* Score widget pi√π piccolo */
            .score-value {
                font-size: 2rem;
            }

            .score-widget {
                margin-top: 2rem;
                padding: 0.5rem;
            }

            /* Bottoni pi√π grandi su mobile */
            .btn {
                padding: 0.5rem 0.75rem;
                font-size: 1.1rem;
            }

            .btn-small {
                padding: 0.35rem 0.5rem;
                font-size: 1rem;
            }

            /* Task detail responsive */
            .task-detail-row {
                flex-direction: column;
                gap: 0.5rem;
            }

            /* Category pills responsive */
            .category-pills {
                gap: 0.3rem;
            }

            .category-pill {
                font-size: 0.8rem;
                padding: 0.1rem 0.3rem;
            }
        }

        /* Tablet */
        @media (max-width: 1024px) and (min-width: 769px) {
            .app-container {
                grid-template-columns: 220px 1fr;
            }

            .sidebar {
                padding: 0.75rem 0.5rem;
            }

            .logo {
                font-size: 1.5rem;
            }

            .main-content {
                padding: 0 1.0rem 1.0rem;
            }
        }

        /* Very small screens */
        @media (max-width: 480px) {
            .page-title {
                font-size: 1.6rem;
            }

            .modal-title {
                font-size: 1.5rem;
            }

            .score-value {
                font-size: 1.8rem;
            }

            h2 {
                font-size: 1.4rem !important;
            }

            h3 {
                font-size: 1.1rem;
            }

            .task-checkbox {
                width: 25px;
                height: 25px;
            }
        }

        .sidebar {
            background: #F3F4F6;
            padding: 1.0rem 0.75rem;
            border-right: 1px solid var(--border);
        }

        .logo {
            font-family: 'Space Mono', monospace;
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 3rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .nav-item {
            padding: 0.5rem 0.6rem;
            margin-bottom: 0.5rem;
            border-radius: 0;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1rem;
            font-weight: 500;
            position: relative;
        }

        .nav-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .nav-item.active {
            background: var(--primary);
        }

        .score-widget {
            margin-top: 3rem;
            padding: 0.75rem;
            background: rgba(0, 217, 163, 0.1);
            border-radius: 0;
            border: 2px solid var(--success);
        }

        .score-value {
            font-family: 'Space Mono', monospace;
            font-size: 3rem;
            font-weight: 700;
            color: var(--success);
            text-align: center;
        }

        .score-label {
            text-align: center;
            margin-top: 0.5rem;
            opacity: 0.8;
        }

        .main-content {
            padding: 0 1.5rem 1.0rem 1.5rem;
            overflow-y: auto;
        }

        .page-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .page-title {
            font-size: 3rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--accent) 0%, var(--primary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .btn {
            padding: 0.4rem 0.75rem;
            border-radius: 0;
            border: none;
            cursor: pointer;
            font-family: 'Darker Grotesque', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-success {
            background: var(--success);
            color: var(--dark);
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-secondary {
            background: var(--border);
            color: var(--dark);
            font-weight: 600;
        }

        .btn-secondary:hover {
            background: var(--muted);
            color: white;
        }

        .btn-accent {
            background: var(--accent);
            color: white;
            font-weight: 600;
        }

        .btn-accent:hover {
            background: #2980b9;
        }

        .btn-small {
            padding: 0.25rem 0.5rem;
            font-size: 0.9rem;
        }

        .card {
            background: var(--card-bg);
            border-radius: 0;
            padding: 0.75rem;
            margin-bottom: 1.5rem;
            border: 1px solid var(--border);
            transition: all 0.3s ease;
        }

        .card:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #FFFFFF;
            border-radius: 0;
            padding: 1.0rem;
            max-width: 700px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            color: var(--dark);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-title {
            font-size: 2rem;
            font-weight: 900;
            color: var(--accent);
        }

        .modal-close {
            font-size: 2rem;
            cursor: pointer;
            color: var(--muted);
            transition: all 0.3s ease;
        }

        .modal-close:hover {
            color: var(--danger);
            transform: rotate(90deg);
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.9rem;
            color: var(--dark);
        }

        .form-input, .form-select, .form-textarea {
            width: 100%;
            padding: 0.4rem 0.5rem;
            border-radius: 0;
            border: 2px solid var(--border);
            background: var(--input-bg);
            color: var(--dark) !important;
            font-family: 'Darker Grotesque', sans-serif;
            font-size: 1.1rem;
            transition: all 0.3s ease;
        }
        
        /* Forza colore anche per type specifici */
        input[type="text"],
        input[type="number"],
        input[type="date"],
        textarea,
        select {
            color: #1F2937 !important;
        }
        
        /* Placeholder visibili */
        .form-input::placeholder,
        .form-textarea::placeholder {
            color: #9CA3AF;
            opacity: 1;
        }

        .form-input:focus, .form-select:focus, .form-textarea:focus {
            outline: none;
            border-color: var(--primary);
            background: #FFFFFF;
            color: var(--dark) !important;
        }

        /* Flatpickr ‚Äî integrazione design app */
        .flatpickr-calendar {
            font-family: 'Darker Grotesque', sans-serif;
            border: 2px solid var(--border);
            border-radius: 4px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.12);
        }
        .flatpickr-day.selected, .flatpickr-day.selected:hover {
            background: var(--primary);
            border-color: var(--primary);
        }
        .flatpickr-day:hover {
            background: var(--border);
        }
        .flatpickr-months .flatpickr-month,
        .flatpickr-weekdays {
            background: var(--dark);
            color: #fff;
        }
        .flatpickr-current-month .flatpickr-monthDropdown-months,
        .flatpickr-current-month input.cur-year {
            color: #fff;
        }
        span.flatpickr-weekday {
            background: var(--dark);
            color: rgba(255,255,255,0.7);
        }
        .flatpickr-time input {
            font-family: 'Darker Grotesque', sans-serif;
            font-size: 1rem;
        }

        /* Fix per dropdown visibility */
        .form-select option {
            background: #FFFFFF;
            color: var(--dark);
            padding: 0.25rem;
        }

        .form-select option:hover {
            background: var(--primary);
            color: white;
        }

        /* Toggle Switch */
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }

        .toggle-label {
            font-size: 0.9rem;
            color: #666;
            font-weight: 500;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 52px;
            height: 28px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .3s;
            border-radius: 0;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .3s;
            border-radius: 0;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: var(--accent);
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }

        .section-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .filter-grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }

        /* Visualizzazione + Filtri layout */
        .view-filters-desktop {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .vf-left { width: 100%; }
        .vf-right { width: 100%; }
        .vf-search { margin-bottom: 0.75rem; }
        .vf-filters-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }

        @media (min-width: 768px) {
            .view-filters-desktop {
                flex-direction: column;
            }
            .vf-left {
                width: 100%;
            }
            .vf-right {
                width: 100%;
            }
            .vf-filters-row {
                grid-template-columns: 1fr 1fr 1fr;
            }
        }

        .hidden {
            display: none !important;
        }

        .task-card {
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 1.5rem;
            align-items: center;
        }

        .task-checkbox {
            width: 30px;
            height: 30px;
            border-radius: 0;
            border: 3px solid var(--primary);
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .task-checkbox:hover {
            background: var(--primary);
            transform: scale(1.1);
        }

        .task-checkbox:active {
            transform: scale(0.95);
        }

        .category-pills {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .category-pill {
            padding: 0.15rem 0.4rem;
            border-radius: 0;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .task-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .task-detail {
            background: rgba(255, 255, 255, 0.03);
            padding: 0.5rem;
            border-radius: 0;
            margin-top: 1rem;
            border: 1px solid var(--border);
        }

        .task-detail-row {
            display: flex;
            justify-content: space-between;
            padding: 0.25rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .task-detail-row:last-child {
            border-bottom: none;
        }

        .task-detail-label {
            font-weight: 600;
            color: var(--accent);
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            color: var(--dark);
        }

        .interval-input {
            display: grid;
            grid-template-columns: 100px 1fr;
            gap: 1rem;
            align-items: center;
        }

        /* Reminder items */
        .reminder-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(52, 152, 219, 0.1);
            border: 1px solid rgba(52, 152, 219, 0.3);
            padding: 0.3rem 0.5rem;
            border-radius: 0;
            margin-bottom: 0.5rem;
            transition: all 0.2s ease;
        }

        .reminder-item:hover {
            background: rgba(52, 152, 219, 0.2);
            border-color: var(--accent);
        }

        .reminder-item span:first-child {
            color: var(--accent);
            font-weight: 500;
        }

        .reminder-remove {
            cursor: pointer;
            color: var(--danger);
            font-size: 1.3rem;
            font-weight: bold;
            padding: 0 0.15rem;
            transition: all 0.2s ease;
            opacity: 0.7;
        }

        .reminder-remove:hover {
            opacity: 1;
            transform: scale(1.2);
        }

        /* Queue status badges */
        .queue-status-badge {
            display: inline-block;
            padding: 0.1rem 0.4rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 700;
        }
        .queue-attempt-badge {
            display: inline-block;
            background: var(--border);
            color: var(--muted);
            padding: 0.1rem 0.4rem;
            border-radius: 4px;
            font-size: 0.75rem;
        }

        /* Toast Animations */
        @keyframes slideUp {
            from {
                transform: translateX(-50%) translateY(100px);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }

        @keyframes slideDown {
            from {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
            to {
                transform: translateX(-50%) translateY(100px);
                opacity: 0;
            }
        }
    
        /* Mobile top navigation instead of hamburger */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: auto;
                display: flex;
                flex-direction: row;
                justify-content: space-around;
                align-items: center;
                padding: 0.1rem 0.1rem;
                border-right: none;
                border-bottom: 1px solid var(--border);
                z-index: 1000;
            }

            .sidebar h1 {
                display: none;
            }

            .nav-menu {
                display: flex;
                flex-direction: row;
                gap: 0.3rem;
                width: 100%;
                justify-content: space-around;
            }

            .nav-item {
                flex-direction: column;
                padding: 0.15rem;
                font-size: 2.2rem;
            }

            .nav-item span {
                font-size: 0.55rem;
            }

            .main-content {
                margin-top: 0;
                padding: 0 0.5rem 0.75rem;
            }

            .hamburger {
                display: none !important;
            }
        }


        /* FORCE mobile horizontal nav, remove hamburger */
        @media (max-width: 768px) {
            .hamburger,
            .menu-toggle {
                display: none !important;
            }

            .sidebar {
                display: flex !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                width: 100% !important;
                height: auto !important;
                background: #F3F4F6 !important;
                border-bottom: 2px solid var(--border) !important;
                border-right: none !important;
                padding: 0.1rem 0 !important;
                z-index: 1000;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            }

            .nav-menu {
                display: flex !important;
                flex-direction: row !important;
                width: 100% !important;
                justify-content: space-around !important;
                align-items: center !important;
                gap: 0.3rem !important;
                margin: 0 !important;
            }

            .nav-item {
                display: flex !important;
                flex-direction: column !important;
                align-items: center !important;
                justify-content: center !important;
                gap: 0.05rem !important;
                padding: 0.15rem 0.1rem !important;
                margin: 0 !important;
                font-size: 2.2rem !important;
                min-width: 0 !important;
                flex: 1 !important;
                text-align: center !important;
                position: relative !important;
            }

            .nav-item.active {
                background: var(--primary) !important;
                border-radius: 0;
            }

            /* Nascondo esplicitamente il testo su mobile */
            .nav-item::after {
                content: none !important;
                display: none !important;
            }

            /* Nascondo il widget punteggio su mobile */
            .score-widget {
                display: none !important;
            }

            /* Nascondo l'overlay su mobile perch√© la navbar √® sempre visibile */
            .sidebar-overlay {
                display: none !important;
            }
            
            /* Forzo l'overlay a rimanere nascosto anche se ha classe active */
            .sidebar-overlay.active {
                display: none !important;
                opacity: 0 !important;
                pointer-events: none !important;
            }

            /* Spazio per la navbar fissa */
            .main-content {
                padding-top: 4.5rem !important;
            }
        }

        /* ===== CALENDAR STYLES ===== */
        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            gap: 1rem;
            padding: 0.5rem;
            background: var(--input-bg);
            border-radius: 0;
        }

        .calendar-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--dark);
            flex: 1;
            text-align: center;
            min-width: 200px;
        }

        .calendar-grid {
            display: grid;
            gap: 1px;
            background: var(--border);
            border: 1px solid var(--border);
        }

        .calendar-grid.week-view {
            grid-template-columns: 80px repeat(7, 1fr);
        }

        .calendar-grid.month-view {
            grid-template-columns: repeat(7, 1fr);
        }

        .calendar-header-cell {
            background: var(--input-bg);
            padding: 1rem;
            text-align: center;
            font-weight: 700;
            color: var(--dark);
            font-size: 1rem;
        }

        .calendar-time-cell {
            background: var(--input-bg);
            padding: 0.5rem;
            text-align: right;
            font-size: 0.85rem;
            color: var(--muted);
            border-right: 2px solid var(--border);
            font-weight: 600;
        }

        .calendar-day-cell {
            background: white;
            padding: 0.5rem;
            min-height: 120px;
            max-height: 120px;
            height: 120px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .calendar-day-cell:hover {
            background: var(--input-bg);
        }

        .calendar-day-cell.today {
            background: rgba(255, 51, 102, 0.08);
            border: 2px solid var(--primary);
        }

        .calendar-day-cell.other-month {
            opacity: 0.3;
            background: #FAFAFA;
        }

        .calendar-day-number {
            font-weight: 700;
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
            color: var(--dark);
            flex-shrink: 0;
        }

        .calendar-day-cell.today .calendar-day-number {
            color: var(--primary);
            font-weight: 900;
        }

        .calendar-tasks-container {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .calendar-task-item {
            background: var(--primary);
            color: white;
            padding: 0.25rem 0.4rem;
            border-radius: 0;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-weight: 600;
            flex-shrink: 0;
        }

        .calendar-task-item:hover {
            transform: scale(1.02);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 10;
        }

        .calendar-task-item.completed {
            opacity: 0.6;
            text-decoration: line-through;
            background: var(--muted);
        }

        .calendar-task-count {
            display: inline-block;
            background: var(--accent);
            color: white;
            padding: 0.2rem 0.4rem;
            border-radius: 0;
            font-size: 0.75rem;
            font-weight: 700;
            margin-top: 0.25rem;
            flex-shrink: 0;
        }

        .calendar-week-cell {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            padding: 0.5rem;
        }

        .calendar-week-hour {
            font-size: 0.75rem;
            color: var(--muted);
            margin-bottom: 0.25rem;
        }

        @media (max-width: 768px) {
            .calendar-grid.week-view {
                grid-template-columns: 50px repeat(7, 1fr);
            }

            .calendar-day-cell {
                min-height: 90px;
                max-height: 90px;
                height: 90px;
                padding: 0.25rem;
            }

            .calendar-day-number {
                font-size: 0.95rem;
                margin-bottom: 0.3rem;
            }

            .calendar-task-item {
                font-size: 0.7rem;
                padding: 0.2rem 0.3rem;
            }

            .calendar-title {
                font-size: 1.4rem;
            }

            .calendar-header-cell {
                padding: 0.5rem 0.25rem;
                font-size: 0.8rem;
            }

            .calendar-time-cell {
                font-size: 0.7rem;
                padding: 0.3rem;
            }

            .calendar-task-count {
                font-size: 0.7rem;
                padding: 0.15rem 0.3rem;
            }
        }

        /* ===== DASHBOARD COMPACT DESKTOP ===== */
        @media (min-width: 769px) {
            .dash-badges {
                grid-template-columns: repeat(4, 1fr) !important;
                gap: 0.5rem !important;
                margin-bottom: 1rem !important;
            }
            .dash-badge {
                padding: 0.5rem 0.6rem !important;
            }
            .dash-badge-value {
                font-size: 1.6rem !important;
                margin-bottom: 0 !important;
            }
            .dash-badge-label {
                font-size: 0.7rem !important;
            }
            .dash-sections-grid {
                display: flex;
                flex-direction: column;
                gap: 0.75rem;
            }
            .dash-section {
                margin-bottom: 0 !important;
                padding: 0.75rem !important;
            }
            .dash-section-title {
                font-size: 1rem !important;
                margin-bottom: 0.5rem !important;
            }
            .dash-section--full {
                grid-column: unset;
            }
            .dash-task-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 0.5rem;
            }
            .dash-task {
                padding: 0.4rem 0.5rem !important;
                margin-bottom: 0 !important;
                box-shadow: 0 1px 3px rgba(0,0,0,0.06) !important;
            }
            .dash-task-cats {
                margin-bottom: 0 !important;
                gap: 0.25rem !important;
                margin-left: auto !important;
            }
            .dash-task-cat-chip {
                padding: 0.1rem 0.4rem !important;
                font-size: 0.7rem !important;
            }
            .dash-task-body {
                margin-bottom: 0.4rem !important;
                gap: 0.5rem !important;
            }
            .dash-task-icon {
                font-size: 1rem !important;
                min-width: 20px !important;
            }
            .dash-task-info {
                min-width: 0;
            }
            .dash-task-title {
                font-size: var(--dash-title-size-mobile, 0.88rem) !important;
                line-height: 1.2 !important;
            }
            .dash-task-meta {
                font-size: var(--dash-meta-size-mobile, 0.72rem) !important;
                margin-top: 0.1rem !important;
            }
            .dash-task-actions {
                gap: 0.3rem !important;
            }
            .dash-task-btn {
                padding: 0.15rem 0.4rem !important;
                font-size: 0.75rem !important;
            }
            .dash-cat-group {
                margin-bottom: 0.75rem !important;
            }
            .dash-cat-title {
                font-size: 0.9rem !important;
                margin-bottom: 0.35rem !important;
            }
        }


</style>
</head>
<body>
    <div class="app-container">
        <!-- Mobile Menu Toggle -->
        <button class="menu-toggle" onclick="toggleMenu()">‚ò∞</button>
        
        <!-- Quick Add Note Button (opposite to hamburger) -->
        <button class="quick-add-note" onclick="showQuickNoteModal()" title="Aggiungi Appunto Veloce">+</button>
        
        <!-- Sidebar Overlay (mobile) -->
        <div class="sidebar-overlay" onclick="toggleMenu()"></div>
        
        <aside class="sidebar" id="sidebar">
            <nav class="nav-menu">
                <div class="nav-item active" onclick="showPage('planner', this)" data-text="Piano">üìÖ</div>
                <div class="nav-item" onclick="showPage('management', this)" data-text="Gestione">‚öôÔ∏è</div>
                <div class="nav-item" onclick="showPage('reminders', this)" id="remindersMenuItem" data-text="Promemoria">üîî</div>
                <div class="nav-item" onclick="showPage('settings', this)" data-text="Impostazioni">üîß</div>
            </nav>

            <div class="score-widget">
                <div class="score-value" id="totalScore">0</div>
                <div class="score-label">Punteggio Totale</div>
            </div>
        </aside>

        <main class="main-content">
            <!-- Dashboard -->
            <div id="dashboardPage" class="hidden">
                <div id="todayTasks"></div>
            </div>

            <!-- Tasks -->
            <div id="tasksPage" class="hidden">
                <div class="page-header">
                    <button class="btn btn-primary" onclick="showCreateTaskModal()">Nuovo Task</button>
                </div>
                
                <!-- Visualizzazione + Filtri (due card affiancate su desktop) -->
                <div class="view-filters-desktop" style="margin-bottom: 1rem;">
                    <!-- Card Visualizzazione - Collapsible -->
                    <div class="card vf-left" style="margin-bottom: 0;">
                        <div onclick="toggleFilterPanel('vistaPanel', 'vistaArrow')" style="cursor: pointer; display: flex; align-items: center; justify-content: space-between;">
                            <h3 style="color: #1a1a1a; margin: 0; font-size: 1rem; text-transform: uppercase; letter-spacing: 0.5px;">üìä Vista</h3>
                            <span id="vistaArrow" style="font-size: 1.2rem; transition: transform 0.3s; transform: rotate(0deg);">‚ñ∂</span>
                        </div>
                        <div id="vistaPanel" style="display: none; margin-top: 0.75rem;">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem;">
                                <span class="toggle-label" id="expandLabel" style="font-size: 0.8rem;">Espandi tutti</span>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="groupsStateToggle" onchange="toggleGroupsState()">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="form-group" style="margin-bottom: 0;">
                                <label class="form-label">Raggruppa per</label>
                                <select class="form-select" id="groupBy" onchange="applyTaskFilters()">
                                    <option value="none">Nessun raggruppamento</option>
                                    <option value="category">Categoria</option>
                                    <option value="priority">Priorit√†</option>
                                    <option value="type">Tipo</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <!-- Card Filtri - Collapsible -->
                    <div class="card vf-right" style="margin-bottom: 0;">
                        <div onclick="toggleFilterPanel('searchPanel', 'searchArrow')" style="cursor: pointer; display: flex; align-items: center; justify-content: space-between;">
                            <h3 style="color: #1a1a1a; margin: 0; font-size: 1rem; text-transform: uppercase; letter-spacing: 0.5px;">üîé Cerca e Filtra</h3>
                            <span id="searchArrow" style="font-size: 1.2rem; transition: transform 0.3s; transform: rotate(0deg);">‚ñ∂</span>
                        </div>
                        <div id="searchPanel" style="display: none; margin-top: 0.75rem;">
                            <div class="vf-search">
                                <label class="form-label">Cerca task</label>
                                <div style="position: relative;">
                                    <input type="text" class="form-input" id="filterSearch" 
                                        placeholder="Cerca per titolo o descrizione..." 
                                        oninput="applyTaskFilters()"
                                        style="background: rgba(255, 255, 255, 0.08); padding-right: 2.5rem;">
                                    <button type="button" onclick="clearSearchFilter()"
                                        style="position: absolute; right: 0.5rem; top: 50%; transform: translateY(-50%); background: none; border: none; color: var(--secondary); cursor: pointer; font-size: 1.5rem; padding: 0.25rem; display: none;"
                                        id="clearSearchBtn" title="Pulisci ricerca">√ó</button>
                                </div>
                            </div>
                            <div class="vf-filters-row">
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label class="form-label">Stato</label>
                                    <select class="form-select" id="filterStatus" onchange="applyTaskFilters()">
                                        <option value="active">Attivi</option>
                                        <option value="completed">Completati</option>
                                        <option value="terminato">Terminati</option>
                                        <option value="archived">Archiviati</option>
                                        <option value="">Tutti</option>
                                    </select>
                                </div>
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label class="form-label">Priorit√†</label>
                                    <select class="form-select" id="filterPriority" onchange="applyTaskFilters()">
                                        <option value="">Tutte le priorit√†</option>
                                    </select>
                                </div>
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label class="form-label">Categoria</label>
                                    <select class="form-select" id="filterCategory" onchange="applyTaskFilters()">
                                        <option value="">Tutte le categorie</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div id="tasksList"></div>
            </div>

            <!-- Categories -->
            <div id="categoriesPage" class="hidden">
                <div class="page-header">
                    <button class="btn btn-primary" onclick="createCategory()">Nuova Categoria</button>
                </div>
                <div id="categoriesList"></div>
            </div>

            <!-- Planner Page -->
            <div id="plannerPage">
                
                <!-- View Selector -->
                <div class="card" style="margin-bottom: 1.5rem;">
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="btn btn-primary" onclick="switchPlannerView('dashboard')" id="btnDashboardView" style="flex: 1; min-width: 0;">Dashboard</button>
                        <button class="btn btn-secondary" onclick="switchPlannerView('month')" id="btnMonthView" style="flex: 1; min-width: 0;">Mese</button>
                        <button class="btn btn-secondary" onclick="switchPlannerView('week')" id="btnWeekView" style="flex: 1; min-width: 0;">Settimana</button>
                    </div>
                </div>
                
                <!-- Navigation Buttons - Fixed (for testing) -->
                <div id="plannerNavigation" class="card" style="display: none; margin-bottom: 1rem; background: #FFF3CD; border-left: 4px solid #FFC107;">
                    <div style="display: flex; justify-content: space-between; align-items: center; gap: 1rem;">
                        <button class="btn btn-secondary" onclick="navigatePlanner(-1)" style="font-size: 1.5rem; padding: 0.6rem 1.2rem;">‚óÄ‚óÄ</button>
                        <span id="currentMonthDisplay" style="font-weight: 700; font-size: 1.2rem; flex: 1; text-align: center;"></span>
                        <button class="btn btn-secondary" onclick="navigatePlanner(1)" style="font-size: 1.5rem; padding: 0.6rem 1.2rem;">‚ñ∂‚ñ∂</button>
                    </div>
                </div>
                
                <!-- Calendar Container -->
                <div id="calendarContainer"></div>
            </div>

            <!-- Management Page (Tasks, Categories, Notes) -->
            <div id="managementPage" class="hidden">
                <!-- Tab Selector -->
                <div class="card" style="margin-bottom: 1.5rem;">
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="btn btn-primary" onclick="switchManagementView('tasks')" id="btnTasksView" style="flex: 1; min-width: 0;">Tasks</button>
                        <button class="btn btn-secondary" onclick="switchManagementView('categories')" id="btnCategoriesView" style="flex: 1; min-width: 0;">Categorie</button>
                        <button class="btn btn-secondary" onclick="switchManagementView('notes')" id="btnNotesView" style="flex: 1; min-width: 0;">Appunti</button>
                    </div>
                </div>

                <!-- Management Container -->
                <div id="managementContainer"></div>
            </div>

            <!-- Reminders Page -->
            <div id="remindersPage" class="hidden">
                <!-- Tab Selector -->
                <div class="card" style="margin-bottom: 1.5rem;">
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <button class="btn btn-primary"   onclick="switchRemindersView('notifiche')" id="btnNotificheView"       style="flex: 1; min-width: 0;">üîî Notifiche</button>
                        <button class="btn btn-secondary" onclick="switchRemindersView('history')"   id="btnHistoryRemindersView" style="flex: 1; min-width: 0;">Storico</button>
                        <button class="btn btn-secondary" onclick="loadQueueItems()" title="Ricarica" style="padding: 0.5rem 0.75rem; flex-shrink: 0;">üîÑ</button>
                    </div>
                </div>

                <!-- Container -->
                <div id="remindersContainer">
                    <div id="remindersPageList"></div>
                </div>
            </div>


            <!-- Settings Page -->
            <div id="settingsPage" class="hidden">
                <div class="card">
                    <h3 style="margin-bottom: 1.5rem;">Dashboard</h3>
                    
                    <div class="form-group">
                        <label class="form-label">Giorni per "Prossimi alla scadenza"</label>
                        <input type="number" class="form-input" id="settingUpcomingDays" min="1" max="90" value="10">
                        <small style="opacity: 0.7; display: block; margin-top: 0.5rem;">
                            Numero di giorni da visualizzare nella sezione "Prossimi alla scadenza" (1-90)
                        </small>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">üìè Dimensione carattere task</label>
                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                            <span style="font-size: 0.8rem; color: #999;">A</span>
                            <input type="range" id="settingFontScale" min="80" max="150" step="5" value="100" style="flex: 1; height: 6px; -webkit-appearance: auto; appearance: auto; accent-color: var(--primary);" oninput="document.getElementById('fontScaleLabel').textContent = this.value + '%'; applyFontScalePreview(this.value);">
                            <span style="font-size: 1.2rem; color: #999;">A</span>
                            <span id="fontScaleLabel" style="font-weight: 700; min-width: 3.5rem; text-align: center; background: var(--primary); color: white; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.9rem;">100%</span>
                        </div>
                        <div id="fontScalePreview" style="margin-top: 0.75rem; padding: 0.5rem; border: 1px dashed #dee2e6; background: #f8f9fa;">
                            <p style="margin: 0; font-weight: 600; color: #333;" id="fontPreviewTitle">Anteprima titolo task</p>
                            <p style="margin: 0.2rem 0 0 0; color: #666;" id="fontPreviewMeta">Anteprima dettagli task ‚Ä¢ 20/02/2026</p>
                        </div>
                        <small style="opacity: 0.7; display: block; margin-top: 0.5rem;">
                            Fattore di ingrandimento per titoli e dettagli dei task in dashboard, gestione e calendario (80%-150%)
                        </small>
                    </div>
                    
                    <button class="btn btn-primary" onclick="saveSettings()">üíæ Salva Impostazioni</button>
                </div>
                
                <div class="card">
                    <h3 style="margin-bottom: 1.5rem;">üéØ Priorit√† Task</h3>
                    
                    <div class="form-group">
                        <label class="form-label">Gestisci Livelli di Priorit√†</label>
                        <small style="opacity: 0.7; display: block; margin: 0.3rem 0 0.5rem 0;">
                            Personalizza i livelli di priorit√† disponibili per i task
                        </small>
                        <div id="prioritiesList" style="margin-bottom: 1rem;"></div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 2fr 1fr 1fr auto; gap: 0.5rem; margin-bottom: 1rem;">
                        <input type="text" class="form-input" id="newPriorityName" placeholder="Nome (es. Urgente)">
                        <input type="number" class="form-input" id="newPriorityValue" placeholder="Valore" min="0" max="100">
                        <input type="color" class="form-input" id="newPriorityColor" value="#FF3366">
                        <button class="btn btn-primary" onclick="addPriority()">+ Aggiungi</button>
                    </div>
                    
                    <small style="opacity: 0.7; display: block;">
                        Il valore numerico determina l'ordine (pi√π alto = pi√π importante)
                    </small>
                </div>
                
                <div class="card">
                    <h3 style="margin-bottom: 1.5rem;">üîî Notifiche</h3>
                    
                    <div class="form-group">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                            <div>
                                <strong>Notifiche Browser</strong>
                                <p style="opacity: 0.7; font-size: 0.9rem; margin: 0.3rem 0 0 0;">
                                    Ricevi notifiche desktop per i promemoria
                                </p>
                            </div>
                            <div id="notificationStatus"></div>
                        </div>
                        
                        <button class="btn btn-accent" onclick="manageNotifications()" id="notificationButton">
                            Gestisci Notifiche
                        </button>
                        
                        <small style="opacity: 0.7; display: block; margin-top: 0.5rem;">
                            ‚Ä¢ Le notifiche vengono controllate ogni minuto<br>
                            ‚Ä¢ Ricevi un avviso per ogni promemoria configurato<br>
                            ‚Ä¢ Click sulla notifica per aprire il task
                        </small>
                    </div>
                </div>
                
                <div class="card">
                    <h3 style="margin-bottom: 1rem;">Informazioni Sistema</h3>
                    <div class="task-detail-row">
                        <span class="task-detail-label">Versione:</span>
                        <span>Tasks v19.17.40</span>
                    </div>
                    <div class="task-detail-row">
                        <span class="task-detail-label">Database:</span>
                        <span>Supabase PostgreSQL</span>
                    </div>
                    <div class="task-detail-row">
                        <span class="task-detail-label">Tipi Task:</span>
                        <span>5 (Singolo, Ricorrente, Ricorrenza Semplice, Multiplo, Libera Ripetizione)</span>
                    </div>
                </div>
            </div>

            <!-- Appunti -->
            <div id="notesPage" class="hidden">
                <div class="page-header">
                    <button class="btn btn-primary" onclick="showAddNoteModal()">Nuovo Appunto</button>
                </div>
                
                <div id="notesList"></div>
            </div>
        </main>
    </div>

    <!-- Debug Console (mobile) - TOP -->
    <div id="debugConsole" style="position: fixed; top: 0; left: 0; right: 0; background: #000; color: #0f0; font-family: monospace; font-size: 11px; max-height: 250px; overflow-y: auto; padding: 0.25rem; display: none; z-index: 10000; border-bottom: 2px solid #0f0;">
        <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
            <strong>üîç DEBUG CONSOLE</strong>
            <button onclick="toggleDebugConsole()" style="background: #f00; color: #fff; border: none; padding: 0.1rem 0.25rem; cursor: pointer;">Nascondi</button>
        </div>
        <div id="debugLog" style="max-height: 180px; overflow-y: auto;"></div>
    </div>
    
    <!-- Debug Toggle Button (fixed bottom right) -->
    <button id="debugToggle" onclick="toggleDebugConsole()" style="position: fixed; bottom: 20px; right: 20px; z-index: 10001; background: #0f0; color: #000; border: none; padding: 0.25rem; border-radius: 0; width: 50px; height: 50px; font-size: 20px; cursor: pointer; display: none; box-shadow: 0 4px 8px rgba(0,0,0,0.3);">üêõ</button>

    <!-- Snooze Modal -->
    <div id="snoozeModal" class="modal" onclick="if(event.target===this)closeSnoozeModal()">
        <div class="modal-content" style="max-width: 360px;">
            <div class="modal-header">
                <h3 class="modal-title">‚è∏Ô∏è Sospendi notifica</h3>
                <span class="modal-close" onclick="closeSnoozeModal()">‚úï</span>
            </div>
            <div style="padding:1.5rem;">
                <p style="margin-bottom: 1rem; opacity: 0.8;">Per quanto tempo vuoi sospendere questa notifica?</p>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                    <button class="btn btn-secondary" onclick="confirmSnooze(15)">15 minuti</button>
                    <button class="btn btn-secondary" onclick="confirmSnooze(30)">30 minuti</button>
                    <button class="btn btn-secondary" onclick="confirmSnooze(60)">1 ora</button>
                    <button class="btn btn-secondary" onclick="confirmSnooze(120)">2 ore</button>
                    <button class="btn btn-secondary" onclick="confirmSnooze(240)">4 ore</button>
                    <button class="btn btn-secondary" onclick="confirmSnooze(1440)">1 giorno</button>
                </div>
                <div style="margin-top: 1rem;">
                    <label class="form-label">Altro (minuti)</label>
                    <div style="display: flex; gap: 0.5rem;">
                        <input type="number" class="form-input" id="snoozeCustomMinutes" placeholder="es. 90" min="1" max="43200">
                        <button class="btn btn-primary" onclick="confirmSnoozeCustom()">OK</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Task Modal (Create/Edit) -->
    <div id="taskModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="taskModalTitle">Nuovo Task</h2>
                <span class="modal-close" onclick="closeTaskModal()">‚úï</span>
            </div>

            <form id="taskForm" onsubmit="saveTask(event)">
                <input type="hidden" id="editTaskId">
                
                <div class="form-group">
                    <label class="form-label">Titolo</label>
                    <input type="text" class="form-input" id="taskTitle" required>
                </div>

                <div class="form-group">
                    <label class="form-label">Descrizione (opzionale)</label>
                    <textarea class="form-textarea" id="taskDescription" rows="3"></textarea>
                </div>

                <div class="form-group">
                    <label class="form-label">Tipo Task</label>
                    <select class="form-select" id="taskType" onchange="updateTaskFields()">
                        <option value="single">Singolo</option>
                        <option value="recurring">Ricorrente</option>
                        <option value="simple_recurring">Ricorrenza semplice</option>
                        <option value="multiple">Multiplo (date specifiche)</option>
                        <option value="free_repeat">A libera ripetizione</option>
                        <option value="workflow">Workflow (step consecutivi)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label class="form-label">Priorit√†</label>
                    <select class="form-select" id="taskPriority">
                        <option value="">Nessuna</option>
                    </select>
                </div>

                <div class="form-group">
                    <label class="form-label">Categorie</label>
                    <div id="taskCategoriesSelect"></div>
                </div>

                <div class="form-group" id="startDateGroup">
                    <label class="form-label">Data/Ora Inizio</label>
                    <input type="text" class="form-input" id="taskStartDate" placeholder="GG-MM-AAAA HH:MM" readonly>
                </div>

                <!-- SINGOLO -->
                <div class="form-group" id="deadlineGroup">
                    <label class="form-label">Scadenza</label>
                    <input type="text" class="form-input" id="taskDeadline" placeholder="GG-MM-AAAA HH:MM" readonly>
                </div>

                <!-- RICORRENTE -->
                <div class="form-group hidden" id="recurringGroup">
                    <label class="form-label">Frequenza</label>
                    <select class="form-select" id="recurringFrequency" onchange="updateRecurringFields()">
                        <option value="daily">Giornaliero</option>
                        <option value="weekly">Settimanale</option>
                        <option value="monthly">Mensile</option>
                        <option value="yearly">Annuale</option>
                    </select>
                </div>

                <!-- INTERVALLO -->
                <div class="form-group hidden" id="intervalGroup">
                    <label class="form-label">Intervallo</label>
                    <div class="interval-input">
                        <input type="number" class="form-input" id="recurringInterval" min="1" value="1">
                        <span id="intervalLabel">anni</span>
                    </div>
                </div>

                <div class="form-group hidden" id="weekDaysGroup">
                    <label class="form-label">Giorni della Settimana</label>
                    <div class="checkbox-group">
                        <label><input type="checkbox" class="week-day" value="1"> Lun</label>
                        <label><input type="checkbox" class="week-day" value="2"> Mar</label>
                        <label><input type="checkbox" class="week-day" value="3"> Mer</label>
                        <label><input type="checkbox" class="week-day" value="4"> Gio</label>
                        <label><input type="checkbox" class="week-day" value="5"> Ven</label>
                        <label><input type="checkbox" class="week-day" value="6"> Sab</label>
                        <label><input type="checkbox" class="week-day" value="0"> Dom</label>
                    </div>
                </div>

                <div class="form-group hidden" id="monthDayGroup">
                    <label class="form-label">Giorni del Mese (seleziona uno o pi√π)</label>
                    <div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 0.5rem; max-width: 500px;">
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="1"> 1</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="2"> 2</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="3"> 3</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="4"> 4</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="5"> 5</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="6"> 6</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="7"> 7</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="8"> 8</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="9"> 9</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="10"> 10</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="11"> 11</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="12"> 12</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="13"> 13</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="14"> 14</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="15"> 15</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="16"> 16</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="17"> 17</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="18"> 18</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="19"> 19</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="20"> 20</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="21"> 21</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="22"> 22</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="23"> 23</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="24"> 24</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="25"> 25</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="26"> 26</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="27"> 27</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="28"> 28</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="29"> 29</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="30"> 30</label>
                        <label style="display: flex; align-items: center; gap: 0.3rem;"><input type="checkbox" class="month-day" value="31"> 31</label>
                    </div>
                </div>

                <div class="form-group hidden" id="yearDateGroup">
                    <label class="form-label">Date annuali (seleziona una o pi√π date)</label>
                    
                    <!-- Selettore rapido per aggiungere data -->
                    <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem; flex-wrap: wrap;">
                        <input type="number" class="form-input" id="quickDay" min="1" max="31" value="1" style="flex: 0 0 80px;" placeholder="GG">
                        <select class="form-select" id="quickMonth" style="flex: 0 0 120px;">
                            <option value="1">Gen</option>
                            <option value="2">Feb</option>
                            <option value="3">Mar</option>
                            <option value="4">Apr</option>
                            <option value="5">Mag</option>
                            <option value="6">Giu</option>
                            <option value="7">Lug</option>
                            <option value="8">Ago</option>
                            <option value="9">Set</option>
                            <option value="10">Ott</option>
                            <option value="11">Nov</option>
                            <option value="12">Dic</option>
                        </select>
                        <button type="button" class="btn btn-secondary" onclick="addYearlyDate()" style="flex: 0 0 auto;">+ Aggiungi</button>
                    </div>
                    
                    <!-- Lista date selezionate -->
                    <div id="yearlyDatesList" style="display: flex; flex-wrap: wrap; gap: 0.5rem; min-height: 60px; padding: 0.25rem; background: rgba(255,255,255,0.05); border-radius: 0;">
                        <small style="opacity: 0.5; width: 100%;">Nessuna data selezionata</small>
                    </div>
                    
                    <input type="hidden" id="recurringDates" value="">
                </div>

                <!-- RICORRENZA SEMPLICE -->
                <div class="form-group hidden" id="simpleRecurringGroup">
                    <label class="form-label">Ripeti dopo (giorni dal completamento)</label>
                    <input type="number" class="form-input" id="repeatAfterDays" min="1" value="7">
                </div>

                <!-- WORKFLOW STEPS -->
                <div class="form-group hidden" id="workflowGroup">
                    <label class="form-label" style="font-weight: 700; font-size: 1rem;">üîÄ Step del Workflow</label>
                    
                    <!-- Grafo dipendenze (unica visualizzazione) -->
                    <div id="wfGraphPreview" style="margin-bottom: 1rem; background: #f8f9fa; border: 1px solid #dee2e6; padding: 0.75rem;">
                        <div id="wfGraphContent"><p style="opacity: 0.5; font-size: 0.85rem; text-align: center;">Aggiungi almeno 2 step per vedere il grafo</p></div>
                    </div>
                    
                    <!-- Form aggiunta nuovo step -->
                    <div style="background: #f8f9fa; padding: 0.75rem; border: 2px dashed #dee2e6; margin-bottom: 0.5rem;">
                        <div class="form-group" style="margin-bottom: 0.5rem;">
                            <label class="form-label" style="font-size: 0.85rem;">Nome step</label>
                            <input type="text" class="form-input" id="wfNewStepTitle" placeholder="Es: Contattare agenzia...">
                        </div>
                        <div class="form-group" style="margin-bottom: 0.5rem;">
                            <label class="form-label" style="font-size: 0.85rem;">Dipende da</label>
                            <div id="wfDependsOnList" style="max-height: 150px; overflow-y: auto; border: 1px solid #dee2e6; background: white; padding: 0.4rem;">
                                <label style="display: flex; align-items: center; gap: 0.4rem; padding: 0.3rem; cursor: pointer; font-size: 0.85rem;">
                                    <input type="checkbox" id="wfDepNone" checked onchange="wfToggleNone()"> Nessuno (inizia subito)
                                </label>
                            </div>
                        </div>
                        <button type="button" class="btn btn-primary" id="wfAddBtn" onclick="wfAddStep()" style="width: 100%; font-size: 0.9rem; padding: 0.4rem;">+ Aggiungi Step</button>
                        <button type="button" class="btn" id="wfCancelBtn" onclick="wfCancelEdit()" style="width: 100%; font-size: 0.9rem; padding: 0.4rem; display: none; margin-top: 0.3rem; background: #6c757d; color: white;">‚úï Annulla modifica</button>
                    </div>
                </div>

                <!-- TASK MULTIPLO (Date specifiche) -->
                <div class="form-group hidden" id="multipleDatesGroup">
                    <label class="form-label">Date del task (seleziona una o pi√π date)</label>
                    
                    <!-- Textbox che mostra le date selezionate e apre il calendario -->
                    <div style="position: relative;">
                        <input type="text" class="form-input" id="multipleDatesTextbox" readonly 
                            placeholder="Clicca per selezionare le date..." 
                            onclick="openMultiCalendar()"
                            style="cursor: pointer; padding-right: 2.5rem;">
                        <span onclick="openMultiCalendar()" style="position: absolute; right: 0.75rem; top: 50%; transform: translateY(-50%); cursor: pointer; font-size: 1.2rem; opacity: 0.7;">üìÖ</span>
                    </div>
                    
                    <input type="hidden" id="multipleDatesData" value="">
                </div>

                <!-- POPUP CALENDARIO MULTI-SELEZIONE -->
                <div id="multiCalendarOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:10000; justify-content:center; align-items:center;">
                    <div id="multiCalendarPopup" style="background: #fff; border: 1px solid #ddd; border-radius: 12px; padding: 1.25rem; width: 340px; max-width: 95vw; max-height: 90vh; overflow-y: auto; box-shadow: 0 12px 40px rgba(0,0,0,0.25);">
                        
                        <!-- Header con navigazione mese -->
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                            <button type="button" onclick="multiCalNavMonth(-1)" style="background: none; border: none; color: #333; font-size: 1.5rem; cursor: pointer; padding: 0.25rem 0.6rem; border-radius: 6px; transition: background 0.2s; line-height:1;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='none'">‚Äπ</button>
                            <span id="multiCalMonthLabel" style="font-weight: 700; font-size: 1.05rem; color: #1a1a1a;"></span>
                            <button type="button" onclick="multiCalNavMonth(1)" style="background: none; border: none; color: #333; font-size: 1.5rem; cursor: pointer; padding: 0.25rem 0.6rem; border-radius: 6px; transition: background 0.2s; line-height:1;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='none'">‚Ä∫</button>
                        </div>

                        <!-- Giorni settimana -->
                        <div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 2px; text-align: center; margin-bottom: 0.4rem;">
                            <div style="font-size: 0.75rem; font-weight: 600; color: #888; padding: 0.25rem;">Lun</div>
                            <div style="font-size: 0.75rem; font-weight: 600; color: #888; padding: 0.25rem;">Mar</div>
                            <div style="font-size: 0.75rem; font-weight: 600; color: #888; padding: 0.25rem;">Mer</div>
                            <div style="font-size: 0.75rem; font-weight: 600; color: #888; padding: 0.25rem;">Gio</div>
                            <div style="font-size: 0.75rem; font-weight: 600; color: #888; padding: 0.25rem;">Ven</div>
                            <div style="font-size: 0.75rem; font-weight: 600; color: #888; padding: 0.25rem;">Sab</div>
                            <div style="font-size: 0.75rem; font-weight: 600; color: #888; padding: 0.25rem;">Dom</div>
                        </div>

                        <!-- Griglia giorni -->
                        <div id="multiCalDaysGrid" style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 2px; text-align: center;">
                        </div>

                        <!-- Contatore date selezionate -->
                        <div id="multiCalSelectedCount" style="margin-top: 0.75rem; font-size: 0.85rem; color: #666; text-align: center;"></div>

                        <!-- Bottoni azione -->
                        <div style="display: flex; gap: 0.75rem; margin-top: 1rem;">
                            <button type="button" onclick="multiCalClear()" style="flex: 1; padding: 0.6rem; background: #f5f5f5; border: 1px solid #ddd; color: #333; border-radius: 8px; cursor: pointer; font-size: 0.9rem; transition: background 0.2s;" onmouseover="this.style.background='#eee'" onmouseout="this.style.background='#f5f5f5'">Cancella tutto</button>
                            <button type="button" onclick="multiCalConfirm()" style="flex: 1; padding: 0.6rem; background: var(--accent, #2563EB); border: none; color: #fff; border-radius: 8px; cursor: pointer; font-size: 0.9rem; font-weight: 600; transition: opacity 0.2s;" onmouseover="this.style.opacity='0.85'" onmouseout="this.style.opacity='1'">Conferma</button>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Promemoria</label>
                    <div id="remindersList" style="min-height: 40px;"></div>
                </div>

                <div id="standardPointsGroup" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem;">
                    <div class="form-group">
                        <label class="form-label">Punti Successo</label>
                        <input type="number" class="form-input" id="successPoints" value="10">
                    </div>

                    <div class="form-group" id="failurePointsGroup">
                        <label class="form-label">Punti Fallimento</label>
                        <input type="number" class="form-input" id="failurePoints" value="-5">
                    </div>

                    <div class="form-group" id="skipPointsGroup">
                        <label class="form-label">Punti Skip</label>
                        <input type="number" class="form-input" id="skipPoints" value="0">
                    </div>

                    <div class="form-group hidden" id="latePointsGroup">
                        <label class="form-label">Punti Ritardo</label>
                        <input type="number" class="form-input" id="latePoints" value="-3">
                    </div>
                </div>

                <!-- PUNTI WORKFLOW -->
                <div id="workflowPointsGroup" style="display: none;">
                    <label class="form-label" style="font-weight: 700; margin-bottom: 0.5rem;">üéØ Punti Workflow</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                        <div class="form-group">
                            <label class="form-label" style="font-size: 0.85rem;">Step Completato</label>
                            <input type="number" class="form-input" id="wfStepSuccessPoints" value="5">
                        </div>
                        <div class="form-group">
                            <label class="form-label" style="font-size: 0.85rem;">Step Fallito</label>
                            <input type="number" class="form-input" id="wfStepFailurePoints" value="-3">
                        </div>
                        <div class="form-group">
                            <label class="form-label" style="font-size: 0.85rem;">Task Completato</label>
                            <input type="number" class="form-input" id="wfTaskSuccessPoints" value="20">
                        </div>
                        <div class="form-group">
                            <label class="form-label" style="font-size: 0.85rem;">Task Fallito</label>
                            <input type="number" class="form-input" id="wfTaskFailurePoints" value="-10">
                        </div>
                    </div>
                </div>

                <button type="submit" class="btn btn-primary" style="width: 100%;">Salva Task</button>
            </form>
        </div>
    </div>

    <!-- View Task Modal -->
    <div id="viewTaskModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Dettagli Task</h2>
                <span class="modal-close" onclick="closeViewTaskModal()">‚úï</span>
            </div>
            <div id="viewTaskContent"></div>
            <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                <button class="btn btn-secondary" onclick="cloneTaskFromView()">üìã Clona</button>
                <button class="btn btn-primary" onclick="editTaskFromView()">‚úèÔ∏è Modifica</button>
                <button class="btn btn-secondary" onclick="archiveTaskFromView()">üì¶ Archivia</button>
                <button class="btn btn-danger" onclick="deleteTaskFromView()">üóëÔ∏è Elimina</button>
                <button class="btn btn-secondary" onclick="closeViewTaskModal()">Chiudi</button>
            </div>
        </div>
    </div>

    <!-- Workflow Popup Modal -->
    <div id="workflowPopupModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h2 class="modal-title" id="wfPopupTitle">üîÄ Workflow</h2>
                <span class="modal-close" onclick="closeWorkflowPopup()">‚úï</span>
            </div>
            <div id="wfPopupContent"></div>
        </div>
    </div>

    <!-- View Category Modal -->
    <div id="viewCategoryModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Task della Categoria</h2>
                <span class="modal-close" onclick="closeViewCategoryModal()">‚úï</span>
            </div>
            <div id="viewCategoryContent"></div>
            <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                <button class="btn btn-secondary" onclick="closeViewCategoryModal()">Chiudi</button>
            </div>
        </div>
    </div>

    <!-- Categories Popup Modal -->
    <div id="categoriesPopupModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <h2 class="modal-title">Categorie Aggiuntive</h2>
                <span class="modal-close" onclick="closeCategoriesPopup()">‚úï</span>
            </div>
            <div id="categoriesPopupContent" style="display: flex; flex-direction: column; gap: 0.8rem; margin: 1.5rem 0;"></div>
            <div style="display: flex; gap: 1rem;">
                <button class="btn btn-secondary" onclick="closeCategoriesPopup()">Chiudi</button>
            </div>
        </div>
    </div>

    <!-- Add/Edit Note Modal -->
    <div id="noteModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2 class="modal-title" id="noteModalTitle">Nuovo Appunto</h2>
                <span class="modal-close" onclick="closeNoteModal()">‚úï</span>
            </div>
            <form id="noteForm" onsubmit="saveNote(event)">
                <input type="hidden" id="editNoteId" value="">
                
                <div class="form-group">
                    <label class="form-label">Titolo *</label>
                    <input type="text" class="form-input" id="noteTitle" required placeholder="Es: Idea per progetto">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Data/Ora</label>
                    <input type="text" class="form-input" id="noteDate" placeholder="GG-MM-AAAA HH:MM">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Contenuto</label>
                    <textarea class="form-input" id="noteContent" rows="6" placeholder="Scrivi qui il tuo appunto..."></textarea>
                </div>
                
                <div style="display: flex; gap: 1rem; margin-top: 1.5rem;">
                    <button type="submit" class="btn btn-primary">üíæ Salva</button>
                    <button type="button" class="btn btn-secondary" onclick="closeNoteModal()">Annulla</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Quick Note Modal (Simple: only name and date) -->
    <div id="quickNoteModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <h2 class="modal-title">üìù Appunto Veloce</h2>
                <span class="modal-close" onclick="closeQuickNoteModal()">‚úï</span>
            </div>
            <form id="quickNoteForm" onsubmit="saveQuickNote(event)">
                <div class="form-group">
                    <label class="form-label">Nome *</label>
                    <input type="text" class="form-input" id="quickNoteName" required placeholder="Es: Chiamare Mario" autofocus>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Data/Ora</label>
                    <input type="text" class="form-input" id="quickNoteDate" placeholder="GG-MM-AAAA HH:MM">
                </div>
                
                <div style="display: flex; gap: 1rem; margin-top: 1.5rem;">
                    <button type="submit" class="btn btn-primary">‚úì Salva</button>
                    <button type="button" class="btn btn-secondary" onclick="closeQuickNoteModal()">Annulla</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        const APP_VERSION = 'v19.17.40';
        const BUILD_TIME  = '2026-03-01T00:00:00Z';

        console.log('%c‚óè Tasks ' + APP_VERSION + ' %c build: ' + BUILD_TIME,
            'background:#FF3366;color:#fff;font-weight:bold;padding:2px 8px;border-radius:3px 0 0 3px',
            'background:#222;color:#aaa;padding:2px 8px;border-radius:0 3px 3px 0');

        console.log('Script started');
        console.log('window.supabase:', window.supabase);
        
        // DEBUG CONSOLE FOR MOBILE
        let debugEnabled = true;
        
        function toggleDebugConsole() {
            const debugConsole = document.getElementById('debugConsole');
            const debugToggle = document.getElementById('debugToggle');
            
            if (debugConsole.style.display === 'none') {
                debugConsole.style.display = 'block';
                debugToggle.innerHTML = 'üêõ';
            } else {
                debugConsole.style.display = 'none';
                debugToggle.innerHTML = 'üêõ';
            }
        }
        
        function debugLog(...args) {
            console.log(...args);
            if (!debugEnabled) return;
            
            setTimeout(() => {
                const debugConsole = document.getElementById('debugConsole');
                const debugLogDiv = document.getElementById('debugLog');
                const debugToggle = document.getElementById('debugToggle');
                
                if (debugConsole && debugLogDiv) {
                    // Mostra il pulsante toggle al primo log
                    if (debugToggle) debugToggle.style.display = 'block';
                    
                    const msg = args.map(a => {
                        if (typeof a === 'object') {
                            try { return JSON.stringify(a, null, 2); }
                            catch { return String(a); }
                        }
                        return String(a);
                    }).join(' ');
                    const time = new Date().toLocaleTimeString();
                    debugLogDiv.innerHTML += `<div style="margin: 0.25rem 0; padding: 0.125rem; background: #111; border-left: 3px solid #0f0;">${time}: ${msg}</div>`;
                    debugLogDiv.scrollTop = debugLogDiv.scrollHeight;
                }
            }, 100);
        }
        
        window.addEventListener('error', (e) => {
            debugLog('‚ùå ERROR:', e.message, 'at line', e.lineno);
        });
        
        const SUPABASE_URL = 'https://jajlmmdsjlvzgcxiiypk.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImphamxtbWRzamx2emdjeGlpeXBrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njk5NTU0NjYsImV4cCI6MjA4NTUzMTQ2Nn0.ikaipwxOvIn43epayQ4mSZQkXtin3aaGEPouafwJFxU';
        
        if (!window.supabase) {
            alert('ERRORE: Supabase non √® caricato! Verifica la connessione internet.');
            console.error('Supabase library not loaded!');
        }
        
        const sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
        console.log('Supabase client created:', sb);

        let categories = [];
        let tasks = [];
        let history = [];
        let settings = {};
        let reminders = [];
        let selectedCategories = [];
        let currentViewTaskId = null;
        let notes = []; // Appunti
        let priorities = []; // Livelli di priorit√†
        let reminderPresets = []; // Preset promemoria da DB
        let sbAccessToken = sessionStorage.getItem('sb_token') || null; // Token Supabase: da sessionStorage o postMessage
        let fpStart = null;
        let fpDeadline = null;
        let fpNoteDate = null;
        let fpQuickNoteDate = null;

        const FP_OPTS_BASE = {
            locale: 'it',
            enableTime: true,
            dateFormat: 'd-m-Y H:i',
            time_24hr: true,
            allowInput: false
        };

        function initDatePickers() {
            fpStart = flatpickr(document.getElementById('taskStartDate'), {
                ...FP_OPTS_BASE,
                onChange: function() {
                    updateRecurringFieldsFromStartDate();
                    autoUpdateDeadline();
                }
            });
            fpDeadline = flatpickr(document.getElementById('taskDeadline'), FP_OPTS_BASE);
            fpNoteDate = flatpickr(document.getElementById('noteDate'), FP_OPTS_BASE);
            fpQuickNoteDate = flatpickr(document.getElementById('quickNoteDate'), FP_OPTS_BASE);
        }

        async function init() {
            console.log('üöÄ Tasks ' + APP_VERSION + ' - Init function started');

            initDatePickers();

            // Reset sidebar state on desktop
            if (window.innerWidth > 768) {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.querySelector('.sidebar-overlay');
                if (sidebar) sidebar.classList.remove('active');
                if (overlay) overlay.classList.remove('active');
            }
            
            await loadSettings();
            console.log('Settings loaded:', Object.keys(settings).length);
            applyFontScale();
            await loadCategories();
            console.log('Categories loaded:', categories.length);
            await loadPriorities();
            console.log('Priorities loaded:', priorities.length);
            await loadTasks();
            console.log('Tasks loaded:', tasks.length);
            await loadHistory();
            console.log('History loaded:', history.length);
            await loadNotes();
            console.log('Notes loaded:', notes.length);
            renderCalendar();
            console.log('Planner rendered');
            
            // Aggiorna i select delle priorit√†
            updatePrioritySelects();
            
            // Inizializza sistema notifiche
            await initNotificationSystem();

            // Carica preset promemoria da DB
            await loadReminderPresets();

            // Aggiorna badge promemoria
            updateRemindersCount();
        }

        async function loadReminderPresets() {
            try {
                const { data, error } = await sb
                    .from('cm_reminder_presets')
                    .select('int_id, label, offset_minutes, sort_order')
                    .eq('active', true)
                    .order('sort_order', { ascending: true });
                if (error) {
                    console.error('Error loading reminder presets:', error);
                } else if (data) {
                    reminderPresets = data;
                    console.log('Reminder presets loaded:', reminderPresets.length);
                }
            } catch (e) {
                console.error('loadReminderPresets exception:', e);
            }
        }

        // ========================================
        // NOTIFICATION RULES (cm_notification_rules)
        // ========================================

        // Restituisce un client Supabase autenticato con il token ricevuto dal launcher.
        // Il client globale `sb` usa solo la chiave anonima; per tabelle con RLS su user_id
        // serve il JWT dell'utente nell'header Authorization.
        let _authSbInstance = null;
        let _authSbToken    = null;

        function getAuthSb() {
            const token = sbAccessToken;
            if (!token) return null;
            if (_authSbInstance && _authSbToken === token) return _authSbInstance;
            _authSbToken    = token;
            _authSbInstance = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY, {
                auth: { persistSession: false, autoRefreshToken: false },
                global: { headers: { Authorization: `Bearer ${token}` } }
            });
            return _authSbInstance;
        }

        // Decodifica il JWT (senza chiamate di rete) e restituisce il payload
        function decodeJWT(token) {
            try {
                return JSON.parse(atob(token.split('.')[1].replace(/-/g, '+').replace(/_/g, '/')));
            } catch(e) { return null; }
        }

        async function syncNotificationRules(taskId, taskType, reminderLabels, dueDate, entityTitle) {
            try {
                const token = sbAccessToken;
                if (!token) {
                    console.warn('‚ö†Ô∏è syncNotificationRules: nessun SB_TOKEN, skip');
                    return;
                }
                const payload = decodeJWT(token);
                const userId  = payload?.sub;
                if (!userId) {
                    console.warn('‚ö†Ô∏è syncNotificationRules: impossibile decodificare user_id dal JWT');
                    return;
                }
                const authSb = getAuthSb();

                console.log(`üîî syncNotificationRules ‚Äî taskId=${taskId}, type=${taskType}, labels=${JSON.stringify(reminderLabels)}`);

                // Se nessun promemoria ‚Üí elimina il record del task e termina
                if (!reminderLabels || reminderLabels.length === 0) {
                    const { error: delErr } = await authSb.from('cm_notification_rules')
                        .delete()
                        .eq('app', 'tasks')
                        .eq('entity_id', String(taskId))
                        .eq('user_id', userId);
                    if (delErr) console.warn('‚ö†Ô∏è syncNotificationRules delete error:', delErr);
                    console.log(`‚ÑπÔ∏è syncNotificationRules: nessun promemoria per task ${taskId}, record eliminato`);
                    return;
                }

                // Mappa le label ‚Üí int_id (chiave semplice numerica del preset)
                const unmatched = [];
                const presetIds = reminderLabels
                    .map(label => {
                        const preset = reminderPresets.find(p => p.label === label);
                        if (!preset || preset.int_id == null) { unmatched.push(label); return null; }
                        return preset.int_id;
                    })
                    .filter(id => id != null);

                if (unmatched.length > 0) {
                    console.warn('‚ö†Ô∏è syncNotificationRules: label senza int_id corrispondente:', unmatched);
                    showToast(`‚ö†Ô∏è Promemoria non trovati nei preset: ${unmatched.join(', ')}`);
                }

                // UPSERT: un solo record per task con l'array JSONB degli int_id selezionati
                // conflict target: (user_id, app, entity_id) ‚Üí richiede UNIQUE CONSTRAINT sul DB
                const rule = {
                    user_id:          userId,
                    app:              'tasks',
                    entity_id:        String(taskId),
                    entity_type:      taskType,
                    entity_title:     entityTitle || null,
                    reminder_presets: { reminders: presetIds, due_at: dueDate || null },   // JSONB: {"reminders": [1, 3, 5], "due_at": "2026-02-26T10:00:00"}
                    channel:          'telegram',
                    enabled:          true
                };

                const { error } = await authSb
                    .from('cm_notification_rules')
                    .upsert(rule, { onConflict: 'user_id,app,entity_id' });

                if (error) {
                    console.error('‚ùå syncNotificationRules upsert error:', error);
                    showToast(`‚ùå Errore salvataggio promemoria: ${error.message || JSON.stringify(error)}`);
                } else {
                    console.log(`‚úÖ syncNotificationRules: task ${taskId} ‚Üí preset IDs ${JSON.stringify(presetIds)}`);
                    showToast('üîî Promemoria salvati');
                    triggerFillQueue(); // aggiorna la coda notifiche immediatamente
                }
            } catch (e) {
                console.error('‚ùå syncNotificationRules exception:', e);
                showToast(`‚ùå Eccezione promemoria: ${e.message}`);
            }
        }

        async function triggerFillQueue() {
            try {
                const token = sbAccessToken;
                if (!token) return;
                const resp = await fetch(`${SUPABASE_URL}/functions/v1/fill-notification-queue`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!resp.ok) {
                    console.warn('‚ö†Ô∏è triggerFillQueue: risposta non ok', resp.status);
                    return;
                }
                const data = await resp.json();
                console.log('‚úÖ triggerFillQueue:', data);
            } catch (e) {
                console.warn('‚ö†Ô∏è triggerFillQueue eccezione:', e.message);
            }
        }

        async function deleteNotificationRules(taskId) {
            try {
                const authSb = getAuthSb();
                if (!authSb) return; // nessun token, skip silenzioso

                const { error } = await authSb.from('cm_notification_rules')
                    .delete()
                    .eq('app', 'tasks')
                    .eq('entity_id', String(taskId));

                if (error) {
                    console.error('‚ùå deleteNotificationRules error:', error);
                } else {
                    console.log(`üóëÔ∏è deleteNotificationRules: regole eliminate per task ${taskId}`);
                }
            } catch (e) {
                console.error('‚ùå deleteNotificationRules exception:', e);
            }
        }

        async function loadCategories() {
            console.log('Loading categories...');
            debugLog('Loading categories...');
            try {
                const { data, error } = await sb.from('cm_categories').select('*');
                if (error) {
                    console.error('Error loading categories:', error);
                    debugLog('‚ùå Error loading categories:', error.message || JSON.stringify(error));
                    alert('Errore nel caricamento delle categorie: ' + (error.message || 'Unknown error'));
                } else {
                    if (data) categories = data;
                    console.log('Categories loaded successfully:', categories);
                    debugLog('‚úÖ Categories loaded:', categories.length);
                }
            } catch (e) {
                console.error('Exception loading categories:', e);
                debugLog('‚ùå Exception loading categories:', e.message);
                alert('Eccezione nel caricamento delle categorie: ' + e.message);
            }
        }

        async function loadPriorities() {
            console.log('Loading priorities...');
            try {
                const { data, error } = await sb.from('ts_priorities').select('*').order('value', { ascending: false });
                if (error) {
                    console.error('Error loading priorities:', error);
                    await initializeDefaultPriorities();
                } else {
                    if (data && data.length > 0) {
                        priorities = data;
                    } else {
                        await initializeDefaultPriorities();
                    }
                    console.log('Priorities loaded:', priorities);
                }
            } catch (e) {
                console.error('Exception loading priorities:', e);
                await initializeDefaultPriorities();
            }
        }

        async function initializeDefaultPriorities() {
            const defaultPriorities = [
                { id: crypto.randomUUID(), name: 'Urgente', value: 100, color: '#E74C3C' },
                { id: crypto.randomUUID(), name: 'Alta', value: 75, color: '#F39C12' },
                { id: crypto.randomUUID(), name: 'Media', value: 50, color: '#2563EB' },
                { id: crypto.randomUUID(), name: 'Bassa', value: 25, color: '#6B7280' }
            ];
            
            priorities = defaultPriorities;
            try {
                for (const priority of defaultPriorities) {
                    await sb.from('ts_priorities').insert([priority]);
                }
                console.log('Default priorities created');
            } catch (e) {
                console.error('Error creating default priorities:', e);
            }
        }

        async function addPriority() {
            const name = document.getElementById('newPriorityName').value.trim();
            const value = parseInt(document.getElementById('newPriorityValue').value);
            const color = document.getElementById('newPriorityColor').value;
            
            if (!name || isNaN(value)) {
                alert('Inserisci nome e valore validi');
                return;
            }
            
            const newPriority = {
                id: crypto.randomUUID(),
                name: name,
                value: value,
                color: color
            };
            
            try {
                const { error } = await sb.from('ts_priorities').insert([newPriority]);
                if (error) throw error;
                
                priorities.push(newPriority);
                priorities.sort((a, b) => b.value - a.value);
                
                document.getElementById('newPriorityName').value = '';
                document.getElementById('newPriorityValue').value = '';
                document.getElementById('newPriorityColor').value = '#FF3366';
                
                renderPrioritiesList();
                updatePrioritySelects();
                showToast('‚úÖ Priorit√† aggiunta');
            } catch (error) {
                console.error('Error adding priority:', error);
                alert('Errore aggiunta priorit√†');
            }
        }

        async function deletePriority(id) {
            if (!confirm('Eliminare questa priorit√†?')) return;
            
            try {
                const { error } = await sb.from('ts_priorities').delete().eq('id', id);
                if (error) throw error;
                
                priorities = priorities.filter(p => p.id !== id);
                renderPrioritiesList();
                updatePrioritySelects();
                showToast('‚úÖ Priorit√† eliminata');
            } catch (error) {
                console.error('Error deleting priority:', error);
                alert('Errore eliminazione priorit√†');
            }
        }

        async function editPriority(id) {
            const priority = priorities.find(p => p.id === id);
            if (!priority) return;
            
            const newName = prompt('Nuovo nome:', priority.name);
            if (!newName) return;
            
            const newValue = parseInt(prompt('Nuovo valore (0-100):', priority.value));
            if (isNaN(newValue)) return;
            
            const newColor = prompt('Nuovo colore (hex):', priority.color);
            if (!newColor) return;
            
            try {
                const { error } = await sb.from('ts_priorities').update({
                    name: newName,
                    value: newValue,
                    color: newColor
                }).eq('id', id);
                
                if (error) throw error;
                
                const index = priorities.findIndex(p => p.id === id);
                priorities[index] = { ...priority, name: newName, value: newValue, color: newColor };
                priorities.sort((a, b) => b.value - a.value);
                
                renderPrioritiesList();
                updatePrioritySelects();
                showToast('‚úÖ Priorit√† aggiornata');
            } catch (error) {
                console.error('Error updating priority:', error);
                alert('Errore aggiornamento priorit√†');
            }
        }

        function renderPrioritiesList() {
            const listEl = document.getElementById('prioritiesList');
            if (!listEl) return;
            
            if (priorities.length === 0) {
                listEl.innerHTML = '<p style="opacity: 0.7;">Nessuna priorit√† configurata</p>';
                return;
            }
            
            listEl.innerHTML = priorities.map(p => `
                <div class="card" style="background: ${p.color}15; border: 2px solid ${p.color}; margin-bottom: 0.5rem; padding: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
                    <div style="display: flex; align-items: center; gap: 0.75rem;">
                        <div style="width: 20px; height: 20px; background: ${p.color};"></div>
                        <strong style="color: ${p.color};">${p.name}</strong>
                        <span style="opacity: 0.7; font-size: 0.9rem;">(${p.value})</span>
                    </div>
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="btn btn-small btn-secondary" onclick="editPriority('${p.id}')">‚úèÔ∏è</button>
                        <button class="btn btn-small btn-danger" onclick="deletePriority('${p.id}')">üóëÔ∏è</button>
                    </div>
                </div>
            `).join('');
        }

        function updatePrioritySelects() {
            const taskPrioritySelect = document.getElementById('taskPriority');
            if (taskPrioritySelect) {
                const currentValue = taskPrioritySelect.value;
                taskPrioritySelect.innerHTML = '<option value="">Nessuna</option>' + 
                    priorities.map(p => `<option value="${p.id}">${p.name}</option>`).join('');
                taskPrioritySelect.value = currentValue;
            }
            
            const filterPrioritySelect = document.getElementById('filterPriority');
            if (filterPrioritySelect) {
                const currentValue = filterPrioritySelect.value;
                filterPrioritySelect.innerHTML = '<option value="">Tutte le priorit√†</option>' + 
                    priorities.map(p => `<option value="${p.id}">${p.name}</option>`).join('');
                filterPrioritySelect.value = currentValue;
            }
        }

        async function loadSettings() {
            console.log('Loading settings...');
            debugLog('Loading settings...');
            try {
                const { data, error } = await sb.from('ts_settings').select('*');
                if (error) {
                    console.error('Error loading settings:', error);
                    debugLog('‚ùå Error loading settings:', error.message || JSON.stringify(error));
                    // Non mostriamo alert per settings, usiamo valori di default
                } else {
                    if (data) {
                        // Converti array in oggetto chiave-valore
                        settings = {};
                        data.forEach(s => {
                            settings[s.key] = s.value;
                        });
                        console.log('Settings loaded successfully:', settings);
                        debugLog('‚úÖ Settings loaded:', Object.keys(settings).length);
                    }
                }
            } catch (e) {
                console.error('Exception loading settings:', e);
                debugLog('‚ùå Exception loading settings:', e.message);
                // Usa valori di default
                settings = {
                    'dashboard_upcoming_days': '10'
                };
                debugLog('Using default settings:', settings);
            }
        }

        async function loadTasks() {
            console.log('Loading tasks...');
            debugLog('Loading tasks...');
            try {
                const { data, error } = await sb.from('ts_tasks').select('*');
                if (error) {
                    console.error('Error loading tasks:', error);
                    debugLog('‚ùå Error loading tasks:', error.message || JSON.stringify(error));
                    alert('Errore nel caricamento dei task: ' + (error.message || 'Unknown error'));
                } else {
                    if (data) tasks = data;
                    console.log('Tasks loaded successfully:', tasks);
                    debugLog('‚úÖ Tasks loaded:', tasks.length);
                }
            } catch (e) {
                console.error('Exception loading tasks:', e);
                debugLog('‚ùå Exception loading tasks:', e.message);
                alert('Eccezione nel caricamento dei task: ' + e.message);
            }
        }

        async function loadHistory() {
            console.log('Loading history...');
            debugLog('Loading history...');
            try {
                const { data, error } = await sb.from('ts_history').select('*').order('timestamp', { ascending: false });
                if (error) {
                    console.error('Error loading history:', error);
                    debugLog('‚ùå Error loading history:', error.message || JSON.stringify(error));
                    alert('Errore nel caricamento dello storico: ' + (error.message || 'Unknown error'));
                } else {
                    if (data) history = data;
                    console.log('History loaded successfully:', history);
                    debugLog('‚úÖ History loaded:', history.length);
                    updateScore();
                }
            } catch (e) {
                console.error('Exception loading history:', e);
                debugLog('‚ùå Exception loading history:', e.message);
                alert('Eccezione nel caricamento dello storico: ' + e.message);
            }
        }

        // Rollback del punteggio (annulla un record storico)
        async function rollbackPoints(historyId) {
            if (!confirm('Annullare questo punteggio? Verr√† creato un record di annullamento con punti opposti.')) {
                return;
            }
            
            // Trova il record originale
            const originalRecord = history.find(h => h.id === historyId);
            if (!originalRecord) {
                alert('Record non trovato');
                return;
            }
            
            // Crea un nuovo record con punti opposti
            const rollbackRecord = {
                task_id: originalRecord.task_id,
                action: 'rollback',
                points: -originalRecord.points,  // Punti opposti
                rollback_of: historyId,  // Riferimento al record originale
                timestamp: new Date().toISOString()
            };
            
            console.log('Creating rollback record:', rollbackRecord);
            
            // Inserisci il record di rollback
            const { data, error } = await sb.from('ts_history').insert([rollbackRecord]).select();
            
            if (error) {
                console.error('Error creating rollback:', error);
                alert('Errore durante l\'annullamento: ' + error.message);
                return;
            }
            
            if (data) {
                console.log('Rollback created:', data[0]);
                // Ricarica storico
                await loadHistory();
                showToast('‚Ü©Ô∏è Punteggio annullato!');
            }
        }

        async function loadSettings() {
            console.log('Loading settings...');
            try {
                const { data, error } = await sb.from('ts_settings').select('*');
                if (error) {
                    console.error('Error loading settings:', error);
                    // Se la tabella settings non esiste, usa valori di default
                    settings = {
                        dashboard_upcoming_days: '10',
                        theme: 'dark',
                        notifications_enabled: 'true'
                    };
                    console.log('Using default settings:', settings);
                } else {
                    // Converti array in oggetto key-value
                    if (data) {
                        settings = {};
                        data.forEach(s => {
                            settings[s.key] = s.value;
                        });
                        console.log('Settings loaded successfully:', settings);
                    }
                }
            } catch (e) {
                console.error('Exception loading settings:', e);
                // Usa default se ci sono errori
                settings = {
                    dashboard_upcoming_days: '10',
                    theme: 'dark',
                    notifications_enabled: 'true'
                };
            }
        }

        function updateScore() {
            const total = history.reduce((sum, h) => sum + (h.points || 0), 0);
            debugLog('üìä SIDEBAR - Total points: ' + total + ' | History items: ' + history.length);
            const scoreElement = document.getElementById('totalScore');
            if (scoreElement) {
                scoreElement.textContent = total;
            }
        }

        // Gestione date annuali
        let yearlyDates = []; // Array di stringhe "DD-MM"
        
        // Gestione date multiple (per tipo multiple)
        let multipleDates = []; // Array di stringhe "YYYY-MM-DD"
        let multiCalCurrentMonth = new Date().getMonth();
        let multiCalCurrentYear = new Date().getFullYear();
        
        function openMultiCalendar() {
            const overlay = document.getElementById('multiCalendarOverlay');
            overlay.style.display = 'flex';
            
            // Posiziona il calendario sul mese della prima data selezionata o oggi
            if (multipleDates.length > 0) {
                const firstDate = new Date(multipleDates[0] + 'T00:00:00');
                multiCalCurrentMonth = firstDate.getMonth();
                multiCalCurrentYear = firstDate.getFullYear();
            }
            
            renderMultiCalendar();
        }
        
        function closeMultiCalendar() {
            document.getElementById('multiCalendarOverlay').style.display = 'none';
        }
        
        // Chiudi cliccando sull'overlay
        document.addEventListener('click', function(e) {
            if (e.target.id === 'multiCalendarOverlay') {
                closeMultiCalendar();
            }
        });
        
        function multiCalNavMonth(dir) {
            multiCalCurrentMonth += dir;
            if (multiCalCurrentMonth > 11) { multiCalCurrentMonth = 0; multiCalCurrentYear++; }
            if (multiCalCurrentMonth < 0) { multiCalCurrentMonth = 11; multiCalCurrentYear--; }
            renderMultiCalendar();
        }
        
        function renderMultiCalendar() {
            const monthNames = ['Gennaio', 'Febbraio', 'Marzo', 'Aprile', 'Maggio', 'Giugno', 'Luglio', 'Agosto', 'Settembre', 'Ottobre', 'Novembre', 'Dicembre'];
            document.getElementById('multiCalMonthLabel').textContent = monthNames[multiCalCurrentMonth] + ' ' + multiCalCurrentYear;
            
            const grid = document.getElementById('multiCalDaysGrid');
            grid.innerHTML = '';
            
            const firstDay = new Date(multiCalCurrentYear, multiCalCurrentMonth, 1);
            let startDay = firstDay.getDay(); // 0=Dom
            startDay = startDay === 0 ? 6 : startDay - 1; // Converti a Lun=0
            
            const daysInMonth = new Date(multiCalCurrentYear, multiCalCurrentMonth + 1, 0).getDate();
            
            const today = new Date();
            const todayStr = today.getFullYear() + '-' + String(today.getMonth() + 1).padStart(2, '0') + '-' + String(today.getDate()).padStart(2, '0');
            
            // Celle vuote prima del primo giorno
            for (let i = 0; i < startDay; i++) {
                const empty = document.createElement('div');
                empty.style.cssText = 'padding: 0.4rem;';
                grid.appendChild(empty);
            }
            
            // Giorni del mese
            for (let d = 1; d <= daysInMonth; d++) {
                const dateStr = multiCalCurrentYear + '-' + String(multiCalCurrentMonth + 1).padStart(2, '0') + '-' + String(d).padStart(2, '0');
                const isSelected = multipleDates.includes(dateStr);
                const isToday = dateStr === todayStr;
                
                const dayEl = document.createElement('div');
                dayEl.textContent = d;
                dayEl.dataset.dateStr = dateStr;
                dayEl.dataset.selected = isSelected ? '1' : '0';
                dayEl.style.cssText = 'padding: 0.45rem 0.2rem; cursor: pointer; border-radius: 8px; font-size: 0.9rem; transition: all 0.15s; user-select: none;'
                    + (isSelected 
                        ? 'background: var(--accent, #2563EB); color: #fff; font-weight: 600; box-shadow: 0 2px 8px rgba(37,99,235,0.3);' 
                        : isToday 
                            ? 'border: 2px solid var(--accent, #2563EB); color: #1a1a1a; font-weight: 700;'
                            : 'color: #1a1a1a;'
                    );
                
                dayEl.onmouseover = function() {
                    if (this.dataset.selected !== '1') this.style.background = '#f0f0f0';
                };
                dayEl.onmouseout = function() {
                    if (this.dataset.selected !== '1') this.style.background = 'none';
                };
                
                dayEl.onclick = function() { toggleMultiCalDate(this.dataset.dateStr); };
                
                grid.appendChild(dayEl);
            }
            
            // Aggiorna contatore
            const count = multipleDates.length;
            document.getElementById('multiCalSelectedCount').textContent = count === 0 ? 'Nessuna data selezionata' : count + ' data' + (count > 1 ? 'e' : '') + ' selezionata' + (count > 1 ? 'e' : '');
        }
        
        function toggleMultiCalDate(dateStr) {
            const idx = multipleDates.indexOf(dateStr);
            if (idx >= 0) {
                multipleDates.splice(idx, 1);
            } else {
                multipleDates.push(dateStr);
            }
            multipleDates.sort();
            renderMultiCalendar();
        }
        
        function multiCalClear() {
            multipleDates = [];
            renderMultiCalendar();
        }
        
        function multiCalConfirm() {
            updateMultipleDatesTextbox();
            closeMultiCalendar();
        }
        
        function updateMultipleDatesTextbox() {
            const textbox = document.getElementById('multipleDatesTextbox');
            const hiddenInput = document.getElementById('multipleDatesData');
            
            if (multipleDates.length === 0) {
                textbox.value = '';
                hiddenInput.value = '';
                return;
            }
            
            const monthNames = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];
            
            const formatted = multipleDates.map(dateStr => {
                const date = new Date(dateStr + 'T00:00:00');
                return date.getDate() + ' ' + monthNames[date.getMonth()] + ' ' + date.getFullYear();
            });
            
            textbox.value = formatted.join(', ');
            hiddenInput.value = JSON.stringify(multipleDates);
        }
        
        function removeMultipleDate(dateStr) {
            multipleDates = multipleDates.filter(d => d !== dateStr);
            updateMultipleDatesTextbox();
        }
        
        function renderMultipleDates() {
            // Compatibilit√†: aggiorna textbox quando chiamato dal codice esistente
            updateMultipleDatesTextbox();
        }
        
        function addYearlyDate() {
            const day = parseInt(document.getElementById('quickDay').value);
            const month = parseInt(document.getElementById('quickMonth').value);
            
            if (day < 1 || day > 31) {
                alert('Giorno non valido (1-31)');
                return;
            }
            
            // Valida che il giorno sia valido per quel mese
            const maxDays = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            if (day > maxDays[month - 1]) {
                alert(`Il mese selezionato ha massimo ${maxDays[month - 1]} giorni`);
                return;
            }
            
            const dateStr = String(day).padStart(2, '0') + '-' + String(month).padStart(2, '0');
            
            if (yearlyDates.includes(dateStr)) {
                alert('Data gi√† aggiunta');
                return;
            }
            
            yearlyDates.push(dateStr);
            yearlyDates.sort(); // Ordina per data
            renderYearlyDates();
        }
        
        function removeYearlyDate(dateStr) {
            yearlyDates = yearlyDates.filter(d => d !== dateStr);
            renderYearlyDates();
        }
        
        function renderYearlyDates() {
            const container = document.getElementById('yearlyDatesList');
            const hiddenInput = document.getElementById('recurringDates');
            
            if (yearlyDates.length === 0) {
                container.innerHTML = '<small style="opacity: 0.5; width: 100%;">Nessuna data selezionata</small>';
                hiddenInput.value = '';
                return;
            }
            
            const monthNames = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];
            
            container.innerHTML = yearlyDates.map(dateStr => {
                const [day, month] = dateStr.split('-');
                const monthName = monthNames[parseInt(month) - 1];
                return `
                    <div style="background: var(--accent); color: #fff; padding: 0.2rem 0.4rem; border-radius: 0; display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                        <span>${day} ${monthName}</span>
                        <button type="button" onclick="removeYearlyDate('${dateStr}')" style="background: none; border: none; color: #fff; cursor: pointer; font-size: 1.2rem; padding: 0; line-height: 1;">√ó</button>
                    </div>
                `;
            }).join('');
            
            hiddenInput.value = JSON.stringify(yearlyDates);
        }

        function showPage(page, element) {
            document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
            if (element) element.classList.add('active');
            
            document.querySelectorAll('.main-content > div').forEach(p => p.classList.add('hidden'));
            document.getElementById(page + 'Page').classList.remove('hidden');
            
            // Non serve pi√π chiudere il menu su mobile perch√© √® sempre orizzontale
            
            if (page === 'dashboard') renderDashboard();
            if (page === 'tasks') renderTasks();
            if (page === 'planner') renderCalendar();
            if (page === 'categories') renderCategories();
            if (page === 'notes') renderNotes();
            if (page === 'management') renderManagement();
            if (page === 'reminders') renderRemindersContainer();
            if (page === 'settings') renderSettings();
        }

        function toggleMenu() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.querySelector('.sidebar-overlay');
            
            sidebar.classList.toggle('active');
            overlay.classList.toggle('active');
        }

        // Chiudi menu quando si ridimensiona la finestra a desktop
        window.addEventListener('resize', () => {
            if (window.innerWidth > 768) {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.querySelector('.sidebar-overlay');
                if (sidebar) sidebar.classList.remove('active');
                if (overlay) overlay.classList.remove('active');
            }
        });

        // Conversione date formato europeo ‚Üî ISO
        // Converte una data in componenti nel fuso orario italiano (Europe/Rome)
        // con fallback al fuso locale del browser in caso di errore Intl
        function toRomeParts(d) {
            const dt = (d instanceof Date) ? d : new Date(d);
            if (!dt || isNaN(dt.getTime())) return null;
            try {
                const fmt = new Intl.DateTimeFormat('it-IT', {
                    timeZone: 'Europe/Rome',
                    year: 'numeric', month: '2-digit', day: '2-digit',
                    hour: '2-digit', minute: '2-digit', hour12: false
                });
                const p = {};
                fmt.formatToParts(dt).forEach(({ type, value }) => { p[type] = value; });
                if (p.hour === '24') p.hour = '00'; // edge case mezzanotte
                if (p.day && p.month && p.year && p.hour && p.minute) return p;
            } catch (e) { /* fallthrough */ }
            // Fallback: usa il fuso locale del browser
            return {
                day:    String(dt.getDate()).padStart(2, '0'),
                month:  String(dt.getMonth() + 1).padStart(2, '0'),
                year:   String(dt.getFullYear()),
                hour:   String(dt.getHours()).padStart(2, '0'),
                minute: String(dt.getMinutes()).padStart(2, '0')
            };
        }

        // Formatta ISO ‚Üí "GG-MM-AAAA HH:MM" in orario italiano
        function isoToEu(isoStr) {
            if (!isoStr) return '';
            const p = toRomeParts(isoStr);
            if (!p) return '';
            return `${p.day}-${p.month}-${p.year} ${p.hour}:${p.minute}`;
        }

        // Formatta data ‚Üí "GG-MM-AAAA" in orario italiano
        function fmtDate(d) {
            if (!d) return '';
            const p = toRomeParts(d);
            if (!p) return '';
            return `${p.day}-${p.month}-${p.year}`;
        }

        // Converte "GG-MM-AAAA HH:MM" (orario locale browser) ‚Üí ISO UTC
        // Semplice e affidabile: usa new Date(y,m,d,h,min) che interpreta
        // il tempo come locale del browser (= orario italiano per utenti in Italia)
        function euToIso(euStr) {
            if (!euStr || !euStr.trim()) return null;
            // Accetta: DD/MM/YYYY HH:MM oppure DD-MM-YYYY HH:MM (con o senza ora)
            const m = euStr.trim().match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})(?:\s+(\d{1,2}):(\d{2}))?$/);
            if (!m) return null;
            const day     = parseInt(m[1]);
            const month   = parseInt(m[2]) - 1; // 0-indexed
            const year    = parseInt(m[3]);
            const hours   = m[4] ? parseInt(m[4]) : 0;
            const minutes = m[5] ? parseInt(m[5]) : 0;
            const d = new Date(year, month, day, hours, minutes);
            if (isNaN(d.getTime())) return null;
            return d.toISOString();
        }

        // Formatta data in formato GG-MM-AAAA HH:MM (orario italiano)
        function formatDateTime(date) {
            if (!date) return 'Nessuna data';
            const p = toRomeParts(date);
            if (!p) return 'Data non valida';
            return `${p.day}-${p.month}-${p.year} ${p.hour}:${p.minute}`;
        }

        function getRecurringLabel(task) {
            if (task.type === 'free_repeat') {
                return 'A libera ripetizione';
            }
            
            if (task.type === 'simple_recurring') {
                const days = task.repeat_after_days || 0;
                return `Ogni ${days} ${days === 1 ? 'giorno' : 'giorni'} dal completamento`;
            }
            
            const freqLabels = { daily: 'Giornaliero', weekly: 'Settimanale', monthly: 'Mensile', yearly: 'Annuale' };
            const interval = task.recurring_interval || 1;
            
            if (interval === 1) {
                return freqLabels[task.recurring_frequency] || task.recurring_frequency;
            }
            
            const unitLabels = {
                daily: interval === 1 ? 'giorno' : 'giorni',
                weekly: interval === 1 ? 'settimana' : 'settimane',
                monthly: interval === 1 ? 'mese' : 'mesi',
                yearly: interval === 1 ? 'anno' : 'anni'
            };
            
            return `Ogni ${interval} ${unitLabels[task.recurring_frequency]}`;
        }
        
        function getDetailedRecurringLabel(task) {
            if (task.type === 'simple_recurring') {
                const days = task.repeat_after_days || 7;
                return `Ricorrenza semplice ‚Ä¢ Ogni ${days} ${days === 1 ? 'giorno' : 'giorni'}`;
            }
            
            if (task.type !== 'recurring') return '';
            
            const interval = task.recurring_interval || 1;
            const freq = task.recurring_frequency;
            
            let parts = [];
            
            // Tipo di ricorrenza
            const freqLabels = {
                'daily': 'Giornaliera',
                'weekly': 'Settimanale',
                'monthly': 'Mensile',
                'yearly': 'Annuale'
            };
            parts.push(freqLabels[freq] || freq);
            
            // Intervallo
            if (interval > 1) {
                const intervalLabels = {
                    'daily': `ogni ${interval} giorni`,
                    'weekly': `ogni ${interval} settimane`,
                    'monthly': `ogni ${interval} mesi`,
                    'yearly': `ogni ${interval} anni`
                };
                parts.push(intervalLabels[freq]);
            }
            
            // Dettagli specifici
            if (freq === 'weekly') {
                const dayNames = ['Dom', 'Lun', 'Mar', 'Mer', 'Gio', 'Ven', 'Sab'];
                if (task.recurring_days_of_week && task.recurring_days_of_week.length > 0) {
                    const days = task.recurring_days_of_week.map(d => dayNames[d]).join(', ');
                    parts.push(days);
                }
            } else if (freq === 'monthly') {
                if (task.recurring_day_of_month && task.recurring_day_of_month.length > 0) {
                    const days = task.recurring_day_of_month.join(', ');
                    parts.push(`giorno ${days}`);
                }
            } else if (freq === 'yearly') {
                const monthNames = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];
                if (task.recurring_dates && task.recurring_dates.length > 0) {
                    const dates = task.recurring_dates.map(dateStr => {
                        const [day, month] = dateStr.split('-');
                        return `${day} ${monthNames[parseInt(month) - 1]}`;
                    }).join(', ');
                    parts.push(dates);
                }
            }
            
            return parts.join(' ‚Ä¢ ');
        }

        // Calcola la prossima occorrenza di un task ricorrente a partire da una data
        function getNextRecurringDate(task, fromDate) {
            if (task.type !== 'recurring') return null;
            
            const interval = task.recurring_interval || 1;
            const startDate = new Date(task.start_date);
            const from = new Date(fromDate);
            from.setHours(0, 0, 0, 0);
            
            if (task.recurring_frequency === 'yearly') {
                // Supporta date multiple (recurring_dates) o singola (vecchio formato)
                let dates = [];
                
                if (task.recurring_dates && task.recurring_dates.length > 0) {
                    // Nuovo formato: array di "DD-MM"
                    dates = task.recurring_dates.map(dateStr => {
                        const [day, month] = dateStr.split('-');
                        return { day: parseInt(day), month: parseInt(month) };
                    });
                } else if (task.recurring_day_of_year && task.recurring_month) {
                    // Vecchio formato: compatibilit√†
                    dates = [{ day: task.recurring_day_of_year, month: task.recurring_month }];
                }
                
                if (dates.length === 0) return null;
                
                const currentYear = from.getFullYear();
                
                // CASO 1: Cerca nell'anno corrente (date dopo oggi)
                for (const date of dates) {
                    const testDate = new Date(currentYear, date.month - 1, date.day);
                    testDate.setHours(0, 0, 0, 0);
                    if (testDate > from) {
                        return testDate;
                    }
                }
                
                // CASO 2: Tutte le date dell'anno corrente sono passate
                // Vai al prossimo anno valido (secondo interval)
                const nextYear = currentYear + interval;
                const firstDate = dates[0];
                const nextDate = new Date(nextYear, firstDate.month - 1, firstDate.day);
                nextDate.setHours(0, 0, 0, 0);
                return nextDate;
            }
            
            if (task.recurring_frequency === 'monthly') {
                // Trova il prossimo giorno del mese (supporta multipli giorni)
                // Fallback: usa il giorno di start_date se recurring_day_of_month non √® impostato
                let sortedDays;
                if (task.recurring_day_of_month && task.recurring_day_of_month.length > 0) {
                    sortedDays = [...task.recurring_day_of_month].sort((a, b) => a - b);
                } else {
                    // Usa il giorno della start_date come fallback
                    const fallbackDay = startDate.getDate();
                    sortedDays = [fallbackDay];
                    debugLog('‚ö†Ô∏è recurring_day_of_month null, fallback a giorno start_date:', fallbackDay);
                }
                const currentDay = from.getDate();
                const currentMonth = from.getMonth();
                const currentYear = from.getFullYear();
                
                // CASO 1: Cerca nel mese corrente (giorni dopo oggi)
                for (const day of sortedDays) {
                    if (day > currentDay) {
                        const testDate = new Date(currentYear, currentMonth, day);
                        testDate.setHours(0, 0, 0, 0);
                        return testDate;
                    }
                }
                
                // CASO 2: Nessun giorno valido questo mese, vai a (interval) mesi avanti
                const nextMonth = new Date(from);
                nextMonth.setMonth(from.getMonth() + interval);
                
                // Trova il primo giorno valido in quel mese
                const firstValidDay = sortedDays[0];
                const nextDate = new Date(nextMonth.getFullYear(), nextMonth.getMonth(), firstValidDay);
                nextDate.setHours(0, 0, 0, 0);
                return nextDate;
            }
            
            if (task.recurring_frequency === 'weekly') {
                // Algoritmo settimanale: rispetta l'intervallo contando dalla data corrente (fromDate)
                let sortedDays;
                if (task.recurring_days_of_week && task.recurring_days_of_week.length > 0) {
                    sortedDays = [...task.recurring_days_of_week].sort((a, b) => a - b);
                } else {
                    const fallbackDay = startDate.getDay();
                    sortedDays = [fallbackDay];
                    debugLog('‚ö†Ô∏è recurring_days_of_week null, fallback a giorno start_date:', fallbackDay);
                }
                const currentDayOfWeek = from.getDay();
                
                // STRATEGIA SEMPLICE E CORRETTA:
                // 1. Cerca un giorno valido nella settimana corrente (da domani fino alla fine della settimana)
                // 2. Se non lo trovi, salta esattamente 'interval' settimane e cerca il primo giorno valido
                
                // PASSO 1: Cerca nella settimana corrente
                for (let i = 1; i <= 7 - currentDayOfWeek; i++) {
                    const testDate = new Date(from);
                    testDate.setDate(from.getDate() + i);
                    
                    if (sortedDays.includes(testDate.getDay())) {
                        testDate.setHours(0, 0, 0, 0);
                        return testDate;
                    }
                }
                
                // PASSO 2: Non trovato nulla questa settimana, salta 'interval' settimane
                // Vai alla domenica (inizio settimana) + interval settimane
                const daysToNextSunday = (7 - currentDayOfWeek) % 7 || 7;
                const nextSunday = new Date(from);
                nextSunday.setDate(from.getDate() + daysToNextSunday);
                
                // Salta 'interval' settimane dalla prossima domenica
                const targetSunday = new Date(nextSunday);
                targetSunday.setDate(nextSunday.getDate() + ((interval - 1) * 7));
                
                // Trova il primo giorno valido in quella settimana
                for (let i = 0; i < 7; i++) {
                    const testDate = new Date(targetSunday);
                    testDate.setDate(targetSunday.getDate() + i);
                    
                    if (sortedDays.includes(testDate.getDay())) {
                        testDate.setHours(0, 0, 0, 0);
                        return testDate;
                    }
                }
                
                return null;
            }
            
            if (task.recurring_frequency === 'daily') {
                // Prossimo giorno secondo l'intervallo
                const nextDate = new Date(from);
                nextDate.setDate(nextDate.getDate() + interval);
                nextDate.setHours(0, 0, 0, 0);
                return nextDate;
            }
            
            return null;
        }

        function isTaskDueToday(task, today) {
            // Task a libera ripetizione NON vanno nella sezione OGGI
            if (task.type === 'free_repeat') {
                return false;
            }
            
            // Task con ricorrenza semplice o ricorrente: controlla next_occurrence_date
            if (task.type === 'simple_recurring' || task.type === 'recurring') {
                if (!task.next_occurrence_date) {
                    // Se non ha next_occurrence_date, usa start_date come prima occorrenza
                    const startDate = new Date(task.start_date);
                    startDate.setHours(0, 0, 0, 0);
                    return startDate.getTime() === today.getTime();
                }
                const nextOccurrence = new Date(task.next_occurrence_date);
                nextOccurrence.setHours(0, 0, 0, 0);
                // SOLO oggi, non <= (che include il passato)
                return nextOccurrence.getTime() === today.getTime();
            }
            
            if (task.type === 'single') {
                // Usa start_date invece di deadline
                if (!task.start_date) return false;
                const startDate = new Date(task.start_date);
                startDate.setHours(0, 0, 0, 0);
                // SOLO oggi, non <= 
                return startDate.getTime() === today.getTime();
            }
            
            if (task.type === 'multiple') {
                if (!task.next_occurrence_date) return false;
                const nextOccurrence = new Date(task.next_occurrence_date);
                nextOccurrence.setHours(0, 0, 0, 0);
                return nextOccurrence.getTime() === today.getTime();
            }
            
            if (task.type === 'workflow') {
                if (!task.next_occurrence_date) return false;
                const nextOccurrence = new Date(task.next_occurrence_date);
                nextOccurrence.setHours(0, 0, 0, 0);
                return nextOccurrence.getTime() === today.getTime();
            }
            
            return false;
        }

        /* VECCHIA FUNZIONE renderDashboard - NON PI√ô USATA - SOSTITUITA DA QUELLA A RIGA 6856
        function renderDashboard() {
            const now = new Date();
            const today = new Date(now);
            today.setHours(0, 0, 0, 0);
            
            const todayEnd = new Date(today);
            todayEnd.setHours(23, 59, 59, 999);
            
            // Usa il numero di giorni dalle impostazioni (default 10)
            const upcomingDays = parseInt(settings['dashboard_upcoming_days'] || '10');
            const nextNDays = new Date(today);
            nextNDays.setDate(nextNDays.getDate() + upcomingDays);
            
            debugLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            debugLog('üîµ RENDER DASHBOARD START');
            debugLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            debugLog('üìÖ Today: ' + today.toISOString().split('T')[0]);
            debugLog('üìÖ Upcoming days range: ' + upcomingDays);
            
            // Filtra task attivi
            debugLog('üîµ STEP 1: Filter active tasks');
            debugLog('  Total tasks: ' + tasks.length);
            const activeTasks = tasks.filter(t => t.status === 'active');
            debugLog('  Active tasks: ' + activeTasks.length);
            
            // Log dettagli task multipli
            const allMultiple = tasks.filter(t => t.type === 'multiple');
            debugLog('üîµ MULTIPLE TASKS CHECK:');
            debugLog('  Total multiple: ' + allMultiple.length);
            allMultiple.forEach(t => {
                debugLog('    - ' + t.title);
                debugLog('      status: ' + t.status);
                debugLog('      next_occurrence_date: ' + (t.next_occurrence_date || 'NULL'));
            });
            
            // Separa i task a libera ripetizione
            debugLog('üîµ STEP 2: Separate free_repeat tasks');
            const freeRepeatTasks = activeTasks.filter(t => t.type === 'free_repeat');
            const workflowTasks = activeTasks.filter(t => t.type === 'workflow');
            const scheduledTasks = activeTasks.filter(t => t.type !== 'free_repeat' && t.type !== 'workflow');
            debugLog('  Free repeat: ' + freeRepeatTasks.length);
            debugLog('  Scheduled: ' + scheduledTasks.length);
            
            // Log scheduled multipli
            const scheduledMultiple = scheduledTasks.filter(t => t.type === 'multiple');
            debugLog('  Scheduled MULTIPLE: ' + scheduledMultiple.length);
            scheduledMultiple.forEach(t => {
                debugLog('    - ' + t.title + ' | next: ' + (t.next_occurrence_date || 'NULL'));
            });
            
            // SCADUTI: usa start_date invece di deadline
            debugLog('üîµ STEP 3: Filter OVERDUE tasks');
            const overdueTasks = scheduledTasks.filter(t => {
                if (t.type === 'single' && t.start_date) {
                    const startDate = new Date(t.start_date);
                    return startDate < today;
                }
                if ((t.type === 'simple_recurring' || t.type === 'recurring' || t.type === 'multiple') && t.next_occurrence_date) {
                    const nextOcc = new Date(t.next_occurrence_date);
                    const isOverdue = nextOcc < today;
                    if (t.type === 'multiple') {
                        debugLog('  MULTIPLE ' + t.title + ': isOverdue=' + isOverdue);
                    }
                    return isOverdue;
                }
                return false;
            });
            debugLog('  Overdue tasks: ' + overdueTasks.length);
            
            // OGGI: task che scadono oggi (SENZA free_repeat)
            debugLog('üîµ STEP 4: Filter TODAY tasks');
            const todayTasks = scheduledTasks.filter(t => {
                const isDue = isTaskDueToday(t, today);
                if (t.type === 'multiple') {
                    debugLog('  MULTIPLE ' + t.title + ': isDueToday=' + isDue);
                }
                return isDue;
            });
            debugLog('  Today tasks: ' + todayTasks.length);
            
            // PROSSIMI ALLA SCADENZA: usa start_date invece di deadline
            // Include: singoli, ricorrenti, ricorrenza semplice
            // upcomingDays e nextNDays gi√† dichiarati sopra
            
            debugLog('üîµ STEP 5: Filter UPCOMING tasks');
            debugLog('  Tomorrow: ' + new Date(today.getTime() + 86400000).toISOString().split('T')[0]);
            debugLog('  Next N days: ' + nextNDays.toISOString().split('T')[0]);
            
            const upcomingTasks = scheduledTasks.filter(t => {
                const tomorrow = new Date(today);
                tomorrow.setDate(tomorrow.getDate() + 1);
                
                // Task singoli: usa start_date invece di deadline
                if (t.type === 'single' && t.start_date) {
                    const startDate = new Date(t.start_date);
                    startDate.setHours(0, 0, 0, 0);
                    return startDate >= tomorrow && startDate <= nextNDays;
                }
                
                // Task ricorrenza semplice, ricorrente, o multipli con next_occurrence_date
                if ((t.type === 'simple_recurring' || t.type === 'recurring' || t.type === 'multiple') && t.next_occurrence_date) {
                    const nextOccurrence = new Date(t.next_occurrence_date);
                    nextOccurrence.setHours(0, 0, 0, 0);
                    const isUpcoming = nextOccurrence >= tomorrow && nextOccurrence <= nextNDays;
                    
                    if (t.type === 'multiple') {
                        debugLog('  MULTIPLE ' + t.title + ':');
                        debugLog('    next_occurrence_date: ' + t.next_occurrence_date);
                        debugLog('    nextOccurrence (parsed): ' + nextOccurrence.toISOString().split('T')[0]);
                        debugLog('    >= tomorrow? ' + (nextOccurrence >= tomorrow));
                        debugLog('    <= nextNDays? ' + (nextOccurrence <= nextNDays));
                        debugLog('    isUpcoming: ' + isUpcoming);
                    }
                    
                    return isUpcoming;
                }
                
                return false;
            });
            debugLog('  Upcoming tasks: ' + upcomingTasks.length);
            
            console.log('Dashboard debug:', {
                today: today.toISOString(),
                upcomingDays: upcomingDays,
                nextNDays: nextNDays.toISOString(),
                totalScheduledTasks: scheduledTasks.length,
                upcomingTasks: upcomingTasks.length,
                upcomingTasksList: upcomingTasks.map(t => ({
                    title: t.title,
                    deadline: t.deadline,
                    next_occurrence: t.next_occurrence_date,
                    type: t.type
                }))
            });
            
            // Funzione per renderizzare task card
            const renderTaskCard = (task, sectionColor, index) => {
                const cats = categories.filter(c => task.categories?.includes(c.id));
                
                // Icona basata sul tipo di task
                let taskIcon = '‚è∞'; // default
                if (task.type === 'recurring' || task.type === 'simple_recurring') {
                    taskIcon = 'üîÅ';
                } else if (task.type === 'multiple') {
                    taskIcon = 'üìÖ';
                } else if (task.type === 'free_repeat') {
                    taskIcon = 'üîÑ';
                }
                
                // Genera HTML per le categorie
                let categoriesHtml = '';
                if (cats.length > 0) {
                    // Mostra solo la prima categoria
                    const visibleCats = cats.slice(0, 1);
                    const hiddenCats = cats.slice(1);
                    
                    categoriesHtml = visibleCats.map(c => 
                        `<span style="background: ${c.color}; color: white; padding: 0.25rem 0.6rem; border-radius: 0; font-size: 0.9rem; font-weight: 600; white-space: nowrap; display: flex; align-items: center;">${c.icon} ${c.name}</span>`
                    ).join('');
                    
                    // Se ci sono categorie nascoste, aggiungi badge +N con popup
                    if (hiddenCats.length > 0) {
                        const hiddenCatsJson = JSON.stringify(hiddenCats.map(c => ({ icon: c.icon, name: c.name, color: c.color })));
                        categoriesHtml += `
                            <span 
                                style="
                                    background: #6B7280; 
                                    color: white; 
                                    padding: 0.25rem 0.5rem; 
                                    border-radius: 0; 
                                    font-size: 0.9rem; 
                                    font-weight: 600;
                                    cursor: pointer;
                                    white-space: nowrap;
                                    display: flex;
                                    align-items: center;
                                "
                                onclick="showCategoriesPopup(${hiddenCatsJson.replace(/"/g, '&quot;')})"
                            >
                                +${hiddenCats.length}
                            </span>
                        `;
                    }
                }
                
                return `
                    <div class="card" style="background: white; border-radius: 0; padding: 0.75rem; margin-bottom: 1rem; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
                        <!-- Header con categorie in alto -->
                        <div style="display: flex; justify-content: flex-end; gap: 0.5rem; margin-bottom: 1rem; align-items: center;">
                            ${categoriesHtml}
                        </div>
                        
                        <!-- Task Content -->
                        <div onclick="viewTask('${task.id}')" style="cursor: pointer; margin-bottom: 1.5rem;">
                            <div style="display: flex; align-items: flex-start; gap: 0.8rem;">
                                <span style="font-size: 1.3rem; color: #666; min-width: 30px;">${taskIcon}</span>
                                <div style="flex: 1;">
                                    <h3 style="margin: 0; font-size: var(--mgmt-title-size); color: #333; font-weight: 600; line-height: 1.4;">${task.title}</h3>
                                    ${(() => {
                                        let dateStr = '';
                                        if (task.type === 'single' && task.start_date) {
                                            dateStr = formatDateTime(task.start_date);
                                        } else if ((task.type === 'simple_recurring' || task.type === 'recurring') && task.next_occurrence_date) {
                                            dateStr = formatDateTime(task.next_occurrence_date);
                                        } else if (task.next_due) {
                                            dateStr = formatDateTime(task.next_due);
                                        }
                                        return dateStr ? `<p style="margin: 0.3rem 0 0 0; font-size: var(--mgmt-meta-size); color: #000;">${dateStr}</p>` : '';
                                    })()}
                                    ${(() => {
                                        let typeLabel = '';
                                        if (task.type === 'simple_recurring' || task.type === 'recurring') {
                                            typeLabel = getDetailedRecurringLabel(task);
                                        } else if (task.type === 'multiple') {
                                            const allDates = (task.multiple_dates || []);
                                            const totalDates = allDates.length;
                                            const nextOcc = task.next_occurrence_date ? task.next_occurrence_date.split('T')[0] : null;
                                            
                                            if (nextOcc) {
                                                const remainingDates = allDates.filter(d => d >= nextOcc).length;
                                                const nextDate = new Date(nextOcc + 'T00:00:00');
                                                const monthNames = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];
                                                const nextDateStr = `${nextDate.getDate()} ${monthNames[nextDate.getMonth()]}`;
                                                typeLabel = `Prossima: ${nextDateStr} ‚Ä¢ ${remainingDates}/${totalDates} date`;
                                            } else {
                                                typeLabel = `${totalDates} date completate`;
                                            }
                                        } else if (task.type === 'free_repeat') {
                                            typeLabel = 'Libera ripetizione';
                                        } else if (task.type === 'single') {
                                            typeLabel = 'Singolo';
                                        } else if (task.type === 'workflow') {
                                            const steps = task.workflow_steps || [];
                                            const completed = steps.filter(s => s.status === 'completed').length;
                                            const failed = steps.filter(s => s.status === 'failed').length;
                                            typeLabel = `Workflow ‚Ä¢ ${completed}‚úì${failed > 0 ? ' ' + failed + '‚úó' : ''} / ${steps.length} step`;
                                        }
                                        return typeLabel ? `<p style="margin: 0.3rem 0 0 0; font-size: var(--mgmt-meta-size); color: #000;">${typeLabel}</p>` : '';
                                    })()}
                                </div>
                            </div>
                        </div>
                        
                        <!-- Action Buttons in basso a sinistra - pi√π piccoli -->
                        <div style="display: flex; gap: 0.8rem; justify-content: flex-start; align-items: center;">
                            <button onclick="event.stopPropagation(); completeTask('${task.id}')" style="
                                background: #4CAF50;
                                color: white;
                                border: none;
                                padding: 0.25rem 0.6rem;
                                border-radius: 0;
                                font-size: 0.9rem;
                                font-weight: 600;
                                cursor: pointer;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 0.4rem;
                                transition: all 0.2s ease;
                                white-space: nowrap;
                            " onmouseover="this.style.background='#45a049'" onmouseout="this.style.background='#4CAF50'">
                                Completato
                            </button>
                            ${task.type !== 'free_repeat' ? `
                            <button onclick="event.stopPropagation(); failTask('${task.id}')" style="
                                background: #E74C3C;
                                color: white;
                                border: none;
                                padding: 0.25rem 0.6rem;
                                border-radius: 0;
                                font-size: 0.9rem;
                                font-weight: 600;
                                cursor: pointer;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 0.4rem;
                                transition: all 0.2s ease;
                                white-space: nowrap;
                            " onmouseover="this.style.background='#c0392b'" onmouseout="this.style.background='#E74C3C'">
                                Fallito
                            </button>
                            ` : ''}
                            ${(task.type === 'recurring' || task.type === 'simple_recurring' || task.type === 'multiple') ? `
                            <button onclick="event.stopPropagation(); skipTask('${task.id}')" style="
                                background: #F39C12;
                                color: white;
                                border: none;
                                padding: 0.25rem 0.6rem;
                                border-radius: 0;
                                font-size: 0.9rem;
                                font-weight: 600;
                                cursor: pointer;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 0.4rem;
                                transition: all 0.2s ease;
                                white-space: nowrap;
                            " onmouseover="this.style.background='#e67e22'" onmouseout="this.style.background='#F39C12'">
                                Salta
                            </button>
                            ` : ''}
                        </div>
                    </div>
                `;
            };
            
            // Costruisci HTML
            let html = '';
            
            // FILA DI BADGE IN ALTO
            const totalScore = history.reduce((sum, h) => sum + (h.points || 0), 0);
            const completedCount = history.filter(h => h.action === 'completed').length;
            const failedCount = history.filter(h => h.action === 'failed').length;
            const skippedCount = history.filter(h => h.action === 'skipped').length;
            
            debugLog('üìä DASHBOARD BADGES - Total: ' + totalScore + ' | Completed: ' + completedCount + ' | Failed: ' + failedCount + ' | Skipped: ' + skippedCount + ' | History items: ' + history.length);
            
            html += `
                <div class="dashboard-badges" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin-bottom: 2rem;">
                    <!-- Badge 1: Punteggio -->
                    <div class="card" style="background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%); color: white; text-align: center; padding: 1rem;">
                        <div style="font-size: 2.5rem; font-weight: 900; margin-bottom: 0.25rem;">${totalScore}</div>
                        <div style="font-size: 0.9rem; font-weight: 600; opacity: 0.9;">PUNTEGGIO</div>
                    </div>
                    
                    <!-- Badge 2: Completati -->
                    <div class="card" style="background: var(--success)20; color: var(--success); text-align: center; padding: 1rem; border: 2px solid var(--success);">
                        <div style="font-size: 2.5rem; font-weight: 900; margin-bottom: 0.25rem;">${completedCount}</div>
                        <div style="font-size: 0.9rem; font-weight: 600;">COMPLETATI</div>
                    </div>
                    
                    <!-- Badge 3: Falliti -->
                    <div class="card" style="background: var(--danger)20; color: var(--danger); text-align: center; padding: 1rem; border: 2px solid var(--danger);">
                        <div style="font-size: 2.5rem; font-weight: 900; margin-bottom: 0.25rem;">${failedCount}</div>
                        <div style="font-size: 0.9rem; font-weight: 600;">FALLITI</div>
                    </div>
                    
                    <!-- Badge 4: Saltati -->
                    <div class="card" style="background: var(--warning)20; color: var(--warning); text-align: center; padding: 1rem; border: 2px solid var(--warning);">
                        <div style="font-size: 2.5rem; font-weight: 900; margin-bottom: 0.25rem;">${skippedCount}</div>
                        <div style="font-size: 0.9rem; font-weight: 600;">SALTATI</div>
                    </div>
                </div>
            `;
            
            // SCADUTI
            if (overdueTasks.length > 0) {
                html += `
                    <div style="margin-bottom: 2rem;">
                        <h2 style="color: var(--danger); font-size: 1.8rem; font-weight: 700; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                            ‚ö†Ô∏è SCADUTI (${overdueTasks.length})
                        </h2>
                        ${overdueTasks.map((t, i) => renderTaskCard(t, 'var(--danger)', i)).join('')}
                    </div>
                `;
            }
            
            // OGGI
            if (todayTasks.length > 0) {
                html += `
                    <div style="margin-bottom: 2rem;">
                        <h2 style="color: var(--warning); font-size: 1.8rem; font-weight: 700; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                            üìÖ OGGI (${todayTasks.length})
                        </h2>
                        ${todayTasks.map((t, i) => renderTaskCard(t, 'var(--warning)', i)).join('')}
                    </div>
                `;
            }
            
            // PROSSIMI 10 GIORNI
            console.log('Rendering upcoming section, upcomingTasks.length:', upcomingTasks.length);
            if (upcomingTasks.length > 0) {
                console.log('Adding upcoming section to HTML');
                html += `
                    <div style="margin-bottom: 2rem;">
                        <h2 style="color: var(--accent); font-size: 1.8rem; font-weight: 700; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                            üîú PROSSIMI ALLA SCADENZA (${upcomingTasks.length}) - ${upcomingDays} giorni
                        </h2>
                        ${upcomingTasks.map((t, i) => renderTaskCard(t, 'var(--accent)', i)).join('')}
                    </div>
                `;
            } else {
                console.log('No upcoming tasks to display');
            }
            
            // Nessun task programmato
            if (html === '') {
                html = '<div class="card"><p>Nessun task in scadenza! üéâ</p></div>';
            }
            
            // TASK A LIBERA RIPETIZIONE - Raggruppati per categoria (solo se show_in_dashboard = true)
            if (freeRepeatTasks.length > 0) {
                html += `
                    <div style="margin-top: 3rem; padding-top: 2rem; border-top: 2px solid rgba(255, 255, 255, 0.1);">
                        <h2 style="color: var(--secondary); font-size: 1.8rem; font-weight: 700; margin-bottom: 1.5rem; display: flex; align-items: center; gap: 0.5rem;">
                            üîÑ A LIBERA RIPETIZIONE
                        </h2>
                `;
                
                // Raggruppa per categoria
                const tasksByCategory = {};
                freeRepeatTasks.forEach(task => {
                    const taskCats = task.categories || [];
                    taskCats.forEach(catId => {
                        const cat = categories.find(c => c.id === catId);
                        // Mostra solo se la categoria ha show_in_dashboard = true
                        if (cat && cat.show_in_dashboard) {
                            if (!tasksByCategory[catId]) {
                                tasksByCategory[catId] = [];
                            }
                            tasksByCategory[catId].push(task);
                        }
                    });
                    // Task senza categoria (non mostrarli se non hanno categoria con flag)
                });
                
                // Conta i task che verranno mostrati
                let totalTasksToShow = 0;
                Object.values(tasksByCategory).forEach(tasks => {
                    totalTasksToShow += tasks.length;
                });
                
                if (totalTasksToShow === 0) {
                    html += '<p style="opacity: 0.7;">Nessuna categoria configurata per la dashboard. Vai su "Categorie" per attivarle.</p>';
                } else {
                    // Renderizza per categoria
                    Object.keys(tasksByCategory).forEach(catId => {
                        const cat = categories.find(c => c.id === catId);
                        const catTasks = tasksByCategory[catId];
                        const catName = `${cat.icon} ${cat.name}`;
                        const catColor = cat.color;
                        
                        html += `
                            <div style="margin-bottom: 2rem;">
                                <h3 style="color: ${catColor}; font-size: 1.4rem; font-weight: 700; margin-bottom: 1rem;">
                                    ${catName} (${catTasks.length})
                                </h3>
                                ${catTasks.map((t, i) => renderTaskCard(t, catColor, i)).join('')}
                            </div>
                        `;
                    });
                }
                
                html += `</div>`;
            }
            
            document.getElementById('todayTasks').innerHTML = html;
        }
        */ // FINE VECCHIA FUNZIONE COMMENTATA

        function renderTasks() {
            // Popola il filtro categorie
            const categoryFilter = document.getElementById('filterCategory');
            if (categoryFilter) {
                const currentValue = categoryFilter.value;
                
                // Calcola il conteggio di task per ogni categoria
                const categoriesWithCount = categories.map(cat => {
                    const count = tasks.filter(t => 
                        t.categories?.includes(cat.id) && 
                        t.status === 'active'
                    ).length;
                    return { ...cat, taskCount: count };
                });
                
                // Ordina per numero di task (decrescente)
                categoriesWithCount.sort((a, b) => b.taskCount - a.taskCount);
                
                categoryFilter.innerHTML = '<option value="">Tutte le categorie</option>' + 
                    categoriesWithCount.map(cat => 
                        `<option value="${cat.id}">${cat.icon} ${cat.name} (${cat.taskCount})</option>`
                    ).join('');
                categoryFilter.value = currentValue;
            }
            
            applyTaskFilters();
        }

        function toggleGroupsState() {
            const toggle = document.getElementById('groupsStateToggle');
            const label = document.getElementById('expandLabel');
            
            if (toggle && label) {
                label.textContent = toggle.checked ? 'Comprimi tutti' : 'Espandi tutti';
            }
            
            applyTaskFilters();
        }

        function applyTaskFilters(containerElement = document) {
            const categoryFilter = containerElement.querySelector('#filterCategory')?.value || '';
            const priorityFilter = containerElement.querySelector('#filterPriority')?.value || '';
            const statusFilter = containerElement.querySelector('#filterStatus')?.value || 'active';
            const searchFilter = containerElement.querySelector('#filterSearch')?.value.toLowerCase().trim() || '';
            
            // Mostra/nascondi bottone clear
            const clearBtn = containerElement.querySelector('#clearSearchBtn');
            if (clearBtn) {
                clearBtn.style.display = searchFilter ? 'block' : 'none';
            }
            
            let filteredTasks = tasks;
            
            // Filtra per stato
            if (statusFilter) {
                filteredTasks = filteredTasks.filter(t => t.status === statusFilter);
            }
            
            // Filtra per categoria
            if (categoryFilter) {
                filteredTasks = filteredTasks.filter(t => t.categories?.includes(categoryFilter));
            }
            
            // Filtra per priorit√†
            if (priorityFilter) {
                filteredTasks = filteredTasks.filter(t => t.priority_id === priorityFilter);
            }
            
            // Filtra per testo di ricerca (titolo o descrizione)
            if (searchFilter) {
                filteredTasks = filteredTasks.filter(t => {
                    const title = (t.title || '').toLowerCase();
                    const description = (t.description || '').toLowerCase();
                    return title.includes(searchFilter) || description.includes(searchFilter);
                });
            }
            
            // Ordina per next_occurrence_date, senza data alla fine
            filteredTasks.sort((a, b) => {
                const rawA = a.next_occurrence_date;
                const rawB = b.next_occurrence_date;
                if (!rawA && !rawB) return 0;
                if (!rawA) return 1;
                if (!rawB) return -1;
                return new Date(rawA) - new Date(rawB);
            });
            
            // Renderizza
            const html = filteredTasks.map((task, index) => {
                const cats = categories.filter(c => task.categories?.includes(c.id));
                let typeLabel = '';
                let taskIcon = '‚è∞';
                
                // Funzione helper per formattare le date/giorni
                function formatDateRange(task) {
                    const monthNames = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];
                    const dayNames = ['Dom', 'Lun', 'Mar', 'Mer', 'Gio', 'Ven', 'Sab'];
                    
                    if (task.type === 'recurring' || task.type === 'free_repeat') {
                        if (task.recurring_frequency === 'yearly' && task.recurring_dates?.length > 0) {
                            const sortedDates = [...task.recurring_dates].sort();
                            if (sortedDates.length > 1) {
                                const [firstDay, firstMonth] = sortedDates[0].split('-');
                                const [lastDay, lastMonth] = sortedDates[sortedDates.length - 1].split('-');
                                return `dal ${parseInt(firstDay)} ${monthNames[parseInt(firstMonth) - 1]} al ${parseInt(lastDay)} ${monthNames[parseInt(lastMonth) - 1]}`;
                            } else {
                                const [day, month] = sortedDates[0].split('-');
                                return `${parseInt(day)} ${monthNames[parseInt(month) - 1]}`;
                            }
                        } else if (task.recurring_frequency === 'weekly' && task.recurring_days_of_week?.length > 0) {
                            const days = task.recurring_days_of_week.map(d => dayNames[d]);
                            if (days.length > 1) {
                                return `da ${days[0]} a ${days[days.length - 1]}`;
                            } else {
                                return days[0];
                            }
                        } else if (task.recurring_frequency === 'monthly' && task.recurring_day_of_month?.length > 0) {
                            const days = [...task.recurring_day_of_month].sort((a, b) => a - b);
                            if (days.length > 1) {
                                return `dal ${days[0]} al ${days[days.length - 1]}`;
                            } else {
                                return `giorno ${days[0]}`;
                            }
                        }
                    } else if (task.type === 'multiple' && task.multiple_dates?.length > 0) {
                        const sortedDates = [...task.multiple_dates].sort();
                        if (sortedDates.length > 1) {
                            const firstDate = new Date(sortedDates[0] + 'T00:00:00');
                            const lastDate = new Date(sortedDates[sortedDates.length - 1] + 'T00:00:00');
                            return `dal ${firstDate.getDate()} ${monthNames[firstDate.getMonth()]} al ${lastDate.getDate()} ${monthNames[lastDate.getMonth()]}`;
                        } else {
                            const date = new Date(sortedDates[0] + 'T00:00:00');
                            return `${date.getDate()} ${monthNames[date.getMonth()]}`;
                        }
                    } else if (task.type === 'single') {
                        if (task.deadline) {
                            const start = new Date(task.start_date);
                            const end = new Date(task.deadline);
                            return `dal ${start.getDate()} ${monthNames[start.getMonth()]} al ${end.getDate()} ${monthNames[end.getMonth()]}`;
                        } else {
                            const start = new Date(task.start_date);
                            return `${start.getDate()} ${monthNames[start.getMonth()]}`;
                        }
                    } else if (task.type === 'simple_recurring') {
                        if (task.next_occurrence_date) {
                            const next = new Date(task.next_occurrence_date);
                            return `prossima: ${next.getDate()} ${monthNames[next.getMonth()]}`;
                        }
                    }
                    return '';
                }
                
                const dateInfo = formatDateRange(task);
                
                if (task.type === 'single') {
                    typeLabel = dateInfo ? `${dateInfo} ‚Ä¢ Singolo` : 'üìÖ Singolo';
                    taskIcon = 'üìÖ';
                } else if (task.type === 'recurring') {
                    const recurLabel = getRecurringLabel(task);
                    typeLabel = dateInfo ? `${dateInfo} ‚Ä¢ Ricorrente ‚Ä¢ ${recurLabel}` : `‚ôæÔ∏è Ricorrente ‚Ä¢ ${recurLabel}`;
                    taskIcon = 'üîÅ';
                } else if (task.type === 'simple_recurring') {
                    const recurLabel = getRecurringLabel(task);
                    typeLabel = dateInfo ? `${dateInfo} ‚Ä¢ Ricorrenza semplice ‚Ä¢ ${recurLabel}` : `üîÅ Ricorrenza semplice ‚Ä¢ ${recurLabel}`;
                    taskIcon = 'üîÅ';
                } else if (task.type === 'multiple') {
                    // Calcola la prossima data e il conteggio
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    
                    const allDates = (task.multiple_dates || []);
                    const totalDates = allDates.length;
                    
                    // Usa next_occurrence_date come riferimento per la prossima data
                    const nextOcc = task.next_occurrence_date ? task.next_occurrence_date.split('T')[0] : null;
                    
                    if (nextOcc) {
                        // Conta le date rimanenti: dalla next_occurrence_date in poi (inclusa)
                        const remainingDates = allDates.filter(d => d >= nextOcc).length;
                        
                        const nextDate = new Date(nextOcc + 'T00:00:00');
                        const monthNames = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];
                        const nextDateStr = `${nextDate.getDate()} ${monthNames[nextDate.getMonth()]}`;
                        typeLabel = `prossima: ${nextDateStr} ‚Ä¢ Multiplo ‚Ä¢ ${remainingDates}/${totalDates} date`;
                    } else {
                        typeLabel = dateInfo ? `${dateInfo} ‚Ä¢ Multiplo ‚Ä¢ ${totalDates} date completate` : `üìÖ Multiplo (${totalDates} date completate)`;
                    }
                    taskIcon = 'üìÖ';
                } else if (task.type === 'free_repeat') {
                    const recurLabel = getRecurringLabel(task);
                    typeLabel = dateInfo ? `${dateInfo} ‚Ä¢ A libera ripetizione ‚Ä¢ ${recurLabel}` : 'üîÑ A libera ripetizione';
                    taskIcon = 'üîÑ';
                } else if (task.type === 'workflow') {
                    const steps = task.workflow_steps || [];
                    const completed = steps.filter(s => s.status === 'completed').length;
                    const failed = steps.filter(s => s.status === 'failed').length;
                    typeLabel = `üîÄ Workflow ‚Ä¢ ${completed}‚úì${failed > 0 ? ' ' + failed + '‚úó' : ''} / ${steps.length} step`;
                    taskIcon = 'üîÄ';
                }
                
                // Badge stato
                let statusBadge = '';
                if (task.status === 'terminato') {
                    statusBadge = '<span style="background: #374151; color: white; padding: 0.15rem 0.4rem; border-radius: 0; font-size: 0.9rem; font-weight: 600;">‚õî Terminato</span>';
                } else if (task.status === 'completed') {
                    statusBadge = '<span style="background: var(--success); color: var(--dark); padding: 0.15rem 0.4rem; border-radius: 0; font-size: 0.9rem; font-weight: 600;">‚úì Completato</span>';
                } else if (task.status === 'archived') {
                    statusBadge = '<span style="background: var(--secondary); color: white; padding: 0.15rem 0.4rem; border-radius: 0; font-size: 0.9rem; font-weight: 600;">üì¶ Archiviato</span>';
                }
                
                // Genera HTML per le categorie (stile dashboard)
                let categoriesHtml = '';
                if (cats.length > 0) {
                    const visibleCats = cats.slice(0, 1);
                    const hiddenCats = cats.slice(1);
                    
                    categoriesHtml = visibleCats.map(c => 
                        `<span style="background: ${c.color}; color: white; padding: 0.25rem 0.6rem; border-radius: 0; font-size: 0.9rem; font-weight: 600; white-space: nowrap; display: flex; align-items: center;">${c.icon} ${c.name}</span>`
                    ).join('');
                    
                    if (hiddenCats.length > 0) {
                        const hiddenCatsJson = JSON.stringify(hiddenCats.map(c => ({ icon: c.icon, name: c.name, color: c.color })));
                        categoriesHtml += `
                            <span 
                                style="
                                    background: #6B7280; 
                                    color: white; 
                                    padding: 0.25rem 0.5rem; 
                                    border-radius: 0; 
                                    font-size: 0.9rem; 
                                    font-weight: 600;
                                    cursor: pointer;
                                    white-space: nowrap;
                                    display: flex;
                                    align-items: center;
                                "
                                onclick="showCategoriesPopup(${hiddenCatsJson.replace(/"/g, '&quot;')})"
                            >
                                +${hiddenCats.length}
                            </span>
                        `;
                    }
                }
                
                // Badge priorit√†
                const priority = priorities.find(p => p.id === task.priority_id);
                const priorityBadge = priority ? `<span style="background: ${priority.color}; color: white; padding: 0.25rem 0.6rem; border-radius: 0; font-size: 0.9rem; font-weight: 600; margin-right: 0.5rem;">üéØ ${priority.name}</span>` : '';
                
                return `
                    <div class="card" style="background: white; border-radius: 0; padding: 0.75rem; margin-bottom: 1rem; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
                        <!-- Header con categorie e stato -->
                        <div style="display: flex; justify-content: space-between; gap: 0.5rem; margin-bottom: 1rem; align-items: center;">
                            <div>${statusBadge}</div>
                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                ${priorityBadge}${categoriesHtml}
                            </div>
                        </div>
                        
                        <!-- Task Content -->
                        <div onclick="viewTask('${task.id}')" style="cursor: pointer; margin-bottom: 1.5rem;">
                            <div style="display: flex; align-items: flex-start; gap: 0.8rem;">
                                <span style="font-size: 1.3rem; color: #666; min-width: 30px;">${taskIcon}</span>
                                <div style="flex: 1;">
                                    <h3 style="margin: 0; font-size: var(--mgmt-title-size); color: #333; font-weight: 600; line-height: 1.4;">${task.title}</h3>
                                    <p style="opacity: 0.6; margin: 0.5rem 0 0 0; font-size: var(--mgmt-meta-size);">${typeLabel}</p>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Action Buttons in basso a sinistra -->
                        <div style="display: flex; gap: 0.8rem; justify-content: flex-start; align-items: center;">
                            <button onclick="cloneTask('${task.id}')" style="
                                background: #6c757d;
                                color: white;
                                border: none;
                                padding: 0.25rem 0.6rem;
                                border-radius: 0;
                                font-size: 0.9rem;
                                font-weight: 600;
                                cursor: pointer;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 0.4rem;
                                transition: all 0.2s ease;
                                white-space: nowrap;
                            " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
                                üìã Clona
                            </button>
                            <button onclick="viewTask('${task.id}')" style="
                                background: var(--accent);
                                color: white;
                                border: none;
                                padding: 0.25rem 0.6rem;
                                border-radius: 0;
                                font-size: 0.9rem;
                                font-weight: 600;
                                cursor: pointer;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 0.4rem;
                                transition: all 0.2s ease;
                                white-space: nowrap;
                            " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
                                Vedi
                            </button>
                            ${task.status === 'active' ? `
                                <button onclick="editTask('${task.id}')" style="
                                    background: var(--primary);
                                    color: white;
                                    border: none;
                                    padding: 0.25rem 0.6rem;
                                    border-radius: 0;
                                    font-size: 0.9rem;
                                    font-weight: 600;
                                    cursor: pointer;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    gap: 0.4rem;
                                    transition: all 0.2s ease;
                                    white-space: nowrap;
                                " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
                                    Modifica
                                </button>
                                <button onclick="deleteTask('${task.id}')" style="
                                    background: var(--danger);
                                    color: white;
                                    border: none;
                                    padding: 0.25rem 0.6rem;
                                    border-radius: 0;
                                    font-size: 0.9rem;
                                    font-weight: 600;
                                    cursor: pointer;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    gap: 0.4rem;
                                    transition: all 0.2s ease;
                                    white-space: nowrap;
                                " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
                                    Cancella
                                </button>
                            ` : `
                                <button onclick="reactivateTask('${task.id}')" style="
                                    background: var(--warning);
                                    color: white;
                                    border: none;
                                    padding: 0.25rem 0.6rem;
                                    border-radius: 0;
                                    font-size: 0.9rem;
                                    font-weight: 600;
                                    cursor: pointer;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    gap: 0.4rem;
                                    transition: all 0.2s ease;
                                    white-space: nowrap;
                                " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
                                    üîÑ Riattiva
                                </button>
                                <button onclick="deleteTask('${task.id}')" style="
                                    background: var(--danger);
                                    color: white;
                                    border: none;
                                    padding: 0.25rem 0.6rem;
                                    border-radius: 0;
                                    font-size: 0.9rem;
                                    font-weight: 600;
                                    cursor: pointer;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    gap: 0.4rem;
                                    transition: all 0.2s ease;
                                    white-space: nowrap;
                                " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
                                    Cancella
                                </button>
                            `}
                        </div>
                    </div>
                `;
            }).join('');
            
            // Gestione raggruppamenti
            const groupBy = containerElement.querySelector('#groupBy')?.value || 'none';
            const groupsStateToggle = containerElement.querySelector('#groupsStateToggle');
            const groupsState = groupsStateToggle?.checked ? 'expanded' : 'collapsed';
            
            const listEl = containerElement.querySelector('#tasksList');
            if (listEl) {
                if (filteredTasks.length > 0) {
                    const resultCount = filteredTasks.length;
                    const countBadge = `
                        <div class="card" style="background: rgba(52, 152, 219, 0.1); border-color: var(--accent); margin-bottom: 1rem;">
                            <p style="margin: 0; color: var(--accent); font-weight: 600;">
                                üîç Trovati ${resultCount} task${resultCount !== 1 ? '' : ''}
                                ${searchFilter ? ` con "${searchFilter}"` : ''}
                            </p>
                        </div>
                    `;
                    
                    let finalHtml = '';
                    
                    if (groupBy === 'none') {
                        // Nessun raggruppamento - mostra lista normale
                        finalHtml = countBadge + html;
                    } else {
                        // Raggruppa i task
                        const groups = {};
                        
                        filteredTasks.forEach(task => {
                            let groupKey = 'Senza';
                            let groupName = 'Senza';
                            let groupColor = '#6B7280';
                            
                            if (groupBy === 'category') {
                                const taskCategories = categories.filter(c => task.categories?.includes(c.id));
                                if (taskCategories.length > 0) {
                                    const cat = taskCategories[0];
                                    groupKey = cat.id;
                                    groupName = `${cat.icon} ${cat.name}`;
                                    groupColor = cat.color;
                                } else {
                                    groupKey = 'no_category';
                                    groupName = 'üìã Senza categoria';
                                }
                            } else if (groupBy === 'priority') {
                                const priority = priorities.find(p => p.id === task.priority_id);
                                if (priority) {
                                    groupKey = priority.id;
                                    groupName = `üéØ ${priority.name}`;
                                    groupColor = priority.color;
                                } else {
                                    groupKey = 'no_priority';
                                    groupName = '‚ö™ Senza priorit√†';
                                }
                            } else if (groupBy === 'type') {
                                groupKey = task.type;
                                const typeNames = {
                                    'single': 'üìÖ Singoli',
                                    'recurring': 'üîÅ Ricorrenti',
                                    'simple_recurring': 'üîÅ Ricorrenza semplice',
                                    'multiple': 'üìÖ Multipli',
                                    'free_repeat': 'üîÑ Libera ripetizione'
                                };
                                groupName = typeNames[task.type] || task.type;
                                groupColor = '#2563EB';
                            }
                            
                            if (!groups[groupKey]) {
                                groups[groupKey] = {
                                    name: groupName,
                                    color: groupColor,
                                    tasks: []
                                };
                            }
                            groups[groupKey].tasks.push(task);
                        });
                        
                        // Genera HTML per i gruppi
                        finalHtml = countBadge;
                        Object.keys(groups).forEach((groupKey, index) => {
                            const group = groups[groupKey];
                            const groupId = `group_${index}`;
                            const isExpanded = groupsState === 'expanded';
                            
                            const groupTasksHtml = group.tasks.map((task) => {
                                // Rigenera l'HTML per questo task (copia il codice di rendering)
                                const cats = categories.filter(c => task.categories?.includes(c.id));
                                let typeLabel = '';
                                let taskIcon = '‚è∞';
                                
                                if (task.type === 'single') {
                                    taskIcon = 'üìÖ';
                                    typeLabel = 'üìÖ Singolo';
                                } else if (task.type === 'recurring') {
                                    taskIcon = 'üîÅ';
                                    const recurLabel = getRecurringLabel(task);
                                    typeLabel = `‚ôæÔ∏è Ricorrente ‚Ä¢ ${recurLabel}`;
                                } else if (task.type === 'simple_recurring') {
                                    taskIcon = 'üîÅ';
                                    const recurLabel = getRecurringLabel(task);
                                    typeLabel = `üîÅ Ricorrenza semplice ‚Ä¢ ${recurLabel}`;
                                } else if (task.type === 'multiple') {
                                    taskIcon = 'üìÖ';
                                    const remainingDates = (task.multiple_dates || []).length;
                                    typeLabel = `üìÖ Multiplo (${remainingDates} date)`;
                                } else if (task.type === 'free_repeat') {
                                    taskIcon = 'üîÑ';
                                    typeLabel = 'üîÑ A libera ripetizione';
                                } else if (task.type === 'workflow') {
                                    taskIcon = 'üîÄ';
                                    const steps = task.workflow_steps || [];
                                    const completed = steps.filter(s => s.status === 'completed').length;
                                    const failed = steps.filter(s => s.status === 'failed').length;
                                    typeLabel = `üîÄ Workflow ‚Ä¢ ${completed}‚úì${failed > 0 ? ' ' + failed + '‚úó' : ''} / ${steps.length} step`;
                                }
                                
                                let statusBadge = '';
                                if (task.status === 'terminato') {
                                    statusBadge = '<span style="background: #374151; color: white; padding: 0.15rem 0.4rem; border-radius: 0; font-size: 0.9rem; font-weight: 600;">‚õî Terminato</span>';
                                } else if (task.status === 'completed') {
                                    statusBadge = '<span style="background: var(--success); color: var(--dark); padding: 0.15rem 0.4rem; border-radius: 0; font-size: 0.9rem; font-weight: 600;">‚úì Completato</span>';
                                } else if (task.status === 'archived') {
                                    statusBadge = '<span style="background: var(--secondary); color: white; padding: 0.15rem 0.4rem; border-radius: 0; font-size: 0.9rem; font-weight: 600;">üì¶ Archiviato</span>';
                                }
                                
                                let categoriesHtml = '';
                                if (cats.length > 0) {
                                    categoriesHtml = cats.slice(0, 1).map(c => 
                                        `<span style="background: ${c.color}; color: white; padding: 0.25rem 0.6rem; border-radius: 0; font-size: 0.9rem; font-weight: 600;">${c.icon} ${c.name}</span>`
                                    ).join('');
                                }
                                
                                const priority = priorities.find(p => p.id === task.priority_id);
                                const priorityBadge = priority ? `<span style="background: ${priority.color}; color: white; padding: 0.25rem 0.6rem; border-radius: 0; font-size: 0.9rem; font-weight: 600; margin-right: 0.5rem;">üéØ ${priority.name}</span>` : '';
                                
                                return `
                                    <div class="card" style="background: white; border-radius: 0; padding: 0.75rem; margin-bottom: 1rem;">
                                        <div style="display: flex; justify-content: space-between; gap: 0.5rem; margin-bottom: 1rem;">
                                            <div>${statusBadge}</div>
                                            <div style="display: flex; gap: 0.5rem;">
                                                ${priorityBadge}${categoriesHtml}
                                            </div>
                                        </div>
                                        <div onclick="viewTask('${task.id}')" style="cursor: pointer; margin-bottom: 1rem;">
                                            <div style="display: flex; gap: 0.8rem;">
                                                <span style="font-size: 1.3rem;">${taskIcon}</span>
                                                <div style="flex: 1;">
                                                    <h3 style="margin: 0; font-size: var(--mgmt-title-size);">${task.title}</h3>
                                                    <p style="opacity: 0.6; margin: 0.5rem 0 0 0; font-size: var(--mgmt-meta-size);">${typeLabel}</p>
                                                </div>
                                            </div>
                                        </div>
                                        <div style="display: flex; gap: 0.8rem;">
                                            <button onclick="viewTask('${task.id}')" style="background: var(--accent); color: white; border: none; padding: 0.25rem 0.6rem; border-radius: 0; font-size: 0.9rem; cursor: pointer;">Vedi</button>
                                            <button onclick="editTask('${task.id}')" style="background: var(--primary); color: white; border: none; padding: 0.25rem 0.6rem; border-radius: 0; font-size: 0.9rem; cursor: pointer;">Modifica</button>
                                            ${task.status === 'active' ? `<button onclick="archiveTask('${task.id}')" style="background: var(--secondary); color: white; border: none; padding: 0.25rem 0.6rem; border-radius: 0; font-size: 0.9rem; cursor: pointer;">Archivia</button>` : `<button onclick="reactivateTask('${task.id}')" style="background: var(--warning); color: white; border: none; padding: 0.25rem 0.6rem; border-radius: 0; font-size: 0.9rem; cursor: pointer;">Riattiva</button>`}
                                        </div>
                                    </div>
                                `;
                            }).join('');
                            
                            finalHtml += `
                                <div class="card" style="margin-bottom: 1rem; padding: 0;">
                                    <div 
                                        onclick="toggleGroup('${groupId}')" 
                                        style="
                                            background: ${group.color}20;
                                            border: 2px solid ${group.color};
                                            padding: 0.75rem;
                                            cursor: pointer;
                                            display: flex;
                                            justify-content: space-between;
                                            align-items: center;
                                        "
                                    >
                                        <h3 style="margin: 0; color: ${group.color}; font-weight: 700;">
                                            ${group.name} (${group.tasks.length})
                                        </h3>
                                        <span id="${groupId}_icon" style="font-size: 1.5rem; color: ${group.color};">
                                            ${isExpanded ? '‚ñº' : '‚ñ∂'}
                                        </span>
                                    </div>
                                    <div id="${groupId}" style="display: ${isExpanded ? 'block' : 'none'}; padding: 0.75rem;">
                                        ${groupTasksHtml}
                                    </div>
                                </div>
                            `;
                        });
                    }
                    
                    listEl.innerHTML = finalHtml;
                } else {
                    // Nessun risultato
                    listEl.innerHTML = `
                        <div class="card" style="text-align: center; padding: 1.5rem;">
                            <h2 style="font-size: 3rem; margin-bottom: 1rem;">üîç</h2>
                            <h3 style="margin-bottom: 1rem;">Nessun task trovato</h3>
                            <p style="opacity: 0.7;">
                                ${searchFilter ? `Nessun task contiene "${searchFilter}"` : 'Prova a modificare i filtri'}
                            </p>
                        </div>
                    `;
                }
            }
        }

        function toggleFilterPanel(panelId, arrowId) {
            const panel = document.getElementById(panelId);
            const arrow = document.getElementById(arrowId);
            if (!panel) return;
            
            const isOpen = panel.style.display !== 'none';
            panel.style.display = isOpen ? 'none' : 'block';
            if (arrow) arrow.style.transform = isOpen ? 'rotate(0deg)' : 'rotate(90deg)';
            
            // Salva stato
            if (panelId === 'vistaPanel') mgmtFilterState.vistaPanelOpen = !isOpen;
            if (panelId === 'searchPanel') mgmtFilterState.searchPanelOpen = !isOpen;
        }

        function clearSearchFilter() {
            document.getElementById('filterSearch').value = '';
            applyTaskFilters();
        }

        function toggleGroup(groupId) {
            const groupElement = document.getElementById(groupId);
            const iconElement = document.getElementById(groupId + '_icon');
            
            if (groupElement && iconElement) {
                if (groupElement.style.display === 'none') {
                    groupElement.style.display = 'block';
                    iconElement.textContent = '‚ñº';
                } else {
                    groupElement.style.display = 'none';
                    iconElement.textContent = '‚ñ∂';
                }
            }
        }

        function renderCategories(containerElement = document) {
            // Aggiungi conteggio task per ordinamento
            const categoriesWithCount = categories.map(cat => {
                const taskCount = tasks.filter(t => t.categories?.includes(cat.id) && t.status === 'active').length;
                return { ...cat, taskCount };
            });
            
            // Ordina per numero task (decrescente)
            categoriesWithCount.sort((a, b) => b.taskCount - a.taskCount);
            
            const html = categoriesWithCount.map(cat => {
                const taskCount = cat.taskCount;
                const freeRepeatCount = tasks.filter(t => t.categories?.includes(cat.id) && t.type === 'free_repeat' && t.status === 'active').length;
                const canDelete = taskCount === 0;
                const showInDash = cat.show_in_dashboard || false;
                
                return `
                    <div class="card" style="background: white; border-radius: 0; padding: 0.75rem; margin-bottom: 1rem; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
                        <!-- Header: icona + nome + mostra dashboard + toggle, tutto in una riga -->
                        <div style="display: flex; justify-content: space-between; align-items: center; gap: 1rem; margin-bottom: 0.75rem;">
                            <div style="display: flex; align-items: center; gap: 0.75rem; flex: 1; min-width: 0;">
                                <div style="width: 44px; height: 44px; background: ${cat.color}; border-radius: 0; display: flex; align-items: center; justify-content: center; font-size: 1.3rem; flex-shrink: 0;">
                                    ${cat.icon}
                                </div>
                                <div style="min-width: 0;">
                                    <h3 style="margin: 0; font-size: 1.1rem; color: #333; font-weight: 700; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${cat.name}</h3>
                                    <p style="margin: 0.15rem 0 0 0; opacity: 0.6; font-size: 0.8rem;">${taskCount} task ${taskCount === 1 ? 'associato' : 'associati'}</p>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 0.5rem; flex-shrink: 0;">
                                <span style="font-size: 0.85rem; color: var(--accent); white-space: nowrap;">Mostra in Dashboard</span>
                                <label class="toggle-switch">
                                    <input type="checkbox" ${showInDash ? 'checked' : ''} 
                                           onchange="toggleDashboardVisibility('${cat.id}', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div style="display: flex; gap: 0.8rem; justify-content: flex-start; align-items: center;">
                            <button onclick="viewCategoryTasks('${cat.id}')" style="
                                background: var(--accent);
                                color: white;
                                border: none;
                                padding: 0.25rem 0.6rem;
                                border-radius: 0;
                                font-size: 0.9rem;
                                font-weight: 600;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                white-space: nowrap;
                            " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
                                Vedi Task
                            </button>
                            <button onclick="editCategory('${cat.id}')" style="
                                background: var(--primary);
                                color: white;
                                border: none;
                                padding: 0.25rem 0.6rem;
                                border-radius: 0;
                                font-size: 0.9rem;
                                font-weight: 600;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                white-space: nowrap;
                            " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
                                Modifica
                            </button>
                            ${canDelete ? 
                                `<button onclick="deleteCategory('${cat.id}')" style="
                                    background: var(--danger);
                                    color: white;
                                    border: none;
                                    padding: 0.25rem 0.6rem;
                                    border-radius: 0;
                                    font-size: 0.9rem;
                                    font-weight: 600;
                                    cursor: pointer;
                                    transition: all 0.2s ease;
                                    white-space: nowrap;
                                " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
                                    Elimina
                                </button>` :
                                `<button disabled title="Ci sono task associati" style="
                                    background: #D1D5DB;
                                    color: #9CA3AF;
                                    border: none;
                                    padding: 0.25rem 0.6rem;
                                    border-radius: 0;
                                    font-size: 0.9rem;
                                    font-weight: 600;
                                    cursor: not-allowed;
                                    white-space: nowrap;
                                ">
                                    Elimina
                                </button>`
                            }
                        </div>
                    </div>
                `;
            }).join('');
            
            const listEl = containerElement.querySelector('#categoriesList');
            if (listEl) {
                listEl.innerHTML = html;
            }
        }

        // ========================================
        // PROMEMORIA SCADUTI
        // ========================================
        
        function renderRemindersPage() {
            const now = new Date();
            const twentyFourHoursAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
            
            console.log('üîî Rendering reminders from', twentyFourHoursAgo, 'to', now);
            
            // Trova tutti i promemoria scaduti nelle ultime 24 ore
            const expiredReminders = [];
            
            tasks.filter(t => t.status === 'active' && t.reminders && t.reminders.length > 0).forEach(task => {
                // Determina la data target del task
                let targetDate = null;
                
                if (task.type === 'single') {
                    targetDate = new Date(task.start_date);
                } else if (task.type === 'recurring' || task.type === 'simple_recurring') {
                    if (task.next_occurrence_date) {
                        targetDate = new Date(task.next_occurrence_date);
                    }
                } else if (task.type === 'multiple') {
                    if (task.next_occurrence_date) {
                        targetDate = new Date(task.next_occurrence_date);
                    }
                }
                
                if (!targetDate) return;
                
                // Controlla ogni promemoria del task
                task.reminders.forEach(reminder => {
                    const reminderTime = calculateReminderTime(targetDate, reminder);
                    if (!reminderTime) return;

                    // Verifica se il promemoria √® scaduto nelle ultime 24 ore
                    if (reminderTime >= twentyFourHoursAgo && reminderTime <= now) {
                        // Salta i promemoria nascosti manualmente
                        const dateKey = targetDate.toISOString().split('T')[0];
                        if (localStorage.getItem(`dismissed_${task.id}_${reminder}_${dateKey}`)) return;

                        expiredReminders.push({
                            task: task,
                            reminder: reminder,
                            reminderTime: reminderTime,
                            targetDate: targetDate
                        });
                    }
                });
            });
            
            // Ordina per tempo di promemoria (pi√π recente prima)
            expiredReminders.sort((a, b) => b.reminderTime - a.reminderTime);
            
            console.log('üîî Found', expiredReminders.length, 'expired reminders');
            
            // Aggiorna badge nel menu
            updateRemindersBadge(expiredReminders.length);
            
            // Conta quanti task unici
            const uniqueTasks = [...new Set(expiredReminders.map(r => r.task.id))];
            
            // Aggiungi bottone "Cancella Tutti" in alto alla pagina
            const headerButtonsHtml = expiredReminders.length > 0 ? `
                <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-bottom: 1rem;">
                    <button class="btn btn-danger" onclick="clearAllReminders()">üóëÔ∏è Cancella Tutti i Promemoria</button>
                </div>
            ` : '';
            
            // Renderizza lista
            const html = expiredReminders.map(item => {
                const cats = categories.filter(c => item.task.categories?.includes(c.id));
                const timeSince = getTimeSince(item.reminderTime);
                const timeUntil = getTimeUntil(item.targetDate);
                
                // Conta quanti promemoria ha questo task nella lista
                const taskRemindersCount = expiredReminders.filter(r => r.task.id === item.task.id).length;
                
                // Determina se il task √® in ritardo
                const isOverdue = item.targetDate < now;
                const statusColor = isOverdue ? 'var(--danger)' : 'var(--accent)';
                const statusIcon = isOverdue ? '‚ö†Ô∏è' : 'üîî';
                const statusText = isOverdue ? 'SCADUTO' : 'IN ARRIVO';
                
                return `
                    <div class="card" style="border-left: 4px solid ${statusColor};">
                        <div style="display: flex; justify-content: space-between; align-items: start; gap: 1rem;">
                            <div style="flex: 1;">
                                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                    <span style="font-size: 1.5rem;">${statusIcon}</span>
                                    <h3 style="margin: 0;">${item.task.title}</h3>
                                    ${taskRemindersCount > 1 ? `<span style="background: var(--warning); color: var(--dark); padding: 0.1rem 0.25rem; border-radius: 0; font-size: 0.75rem; font-weight: 600;">${taskRemindersCount} promemoria</span>` : ''}
                                </div>
                                
                                <div style="margin: 0.5rem 0;">
                                    <span style="background: ${statusColor}20; color: ${statusColor}; padding: 0.15rem 0.4rem; border-radius: 0; font-size: 0.85rem; font-weight: 600;">
                                        ${statusText}
                                    </span>
                                </div>
                                
                                <p style="opacity: 0.8; margin: 0.5rem 0; font-size: 0.95rem;">
                                    üìã <strong>Promemoria:</strong> ${item.reminder} prima
                                </p>
                                
                                <p style="opacity: 0.7; font-size: 0.9rem; margin: 0.3rem 0;">
                                    üïê Scattato: ${timeSince}
                                </p>
                                
                                <p style="opacity: 0.7; font-size: 0.9rem; margin: 0.3rem 0;">
                                    üìÖ Scadenza: ${formatDateTime(item.targetDate)} ${isOverdue ? '(passata)' : `(${timeUntil})`}
                                </p>
                                
                                ${cats.length > 0 ? `
                                    <div class="category-pills" style="margin-top: 0.5rem;">
                                        ${cats.map(c => `<span class="category-pill" style="background: ${c.color}20; color: ${c.color}">${c.icon} ${c.name}</span>`).join('')}
                                    </div>
                                ` : ''}
                            </div>
                            
                            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                                <button class="btn btn-primary btn-small" onclick="viewTask('${item.task.id}')">üëÅÔ∏è Vedi</button>
                                <button class="btn btn-success btn-small" onclick="completeTaskFromReminder('${item.task.id}')">‚úì Completa</button>
                                ${taskRemindersCount > 1 ? `
                                    <button class="btn btn-warning btn-small" onclick="completeAllRemindersForTask('${item.task.id}')" title="Completa tutti i ${taskRemindersCount} promemoria di questo task">‚úì‚úì Completa Tutti</button>
                                ` : ''}
                                <button class="btn btn-secondary btn-small" onclick="dismissReminder('${item.task.id}', '${item.reminder}', '${item.targetDate.toISOString().split('T')[0]}')">‚úï Nascondi</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            const listEl = document.getElementById('remindersPageList');
            if (listEl) {
                if (html) {
                    listEl.innerHTML = headerButtonsHtml + html;
                } else {
                    listEl.innerHTML = `
                        <div class="card" style="text-align: center; padding: 1.5rem;">
                            <h2 style="font-size: 3rem; margin-bottom: 1rem;">‚úÖ</h2>
                            <h3 style="margin-bottom: 1rem;">Nessun promemoria scaduto</h3>
                            <p style="opacity: 0.7;">
                                Non ci sono promemoria scaduti nelle ultime 24 ore
                            </p>
                        </div>
                    `;
                }
            }
        }
        
        async function completeTaskFromReminder(taskId) {
            if (!confirm('Completare questo task?')) return;
            
            const task = tasks.find(t => t.id === taskId);
            if (!task) {
                alert('Task non trovato');
                return;
            }
            
            // Usa la funzione esistente completeTask
            await completeTask(taskId);
            
            // Ricarica la pagina promemoria
            renderRemindersPage();
            showToast('‚úÖ Task completato!');
        }
        
        async function completeAllRemindersForTask(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;
            
            if (!confirm(`Completare "${task.title}"?\n\nQuesto completer√† il task e rimuover√† tutti i suoi promemoria dalla lista.`)) {
                return;
            }
            
            await completeTask(taskId);
            renderRemindersPage();
            showToast('‚úÖ Task completato! Tutti i promemoria rimossi.');
        }
        
        function clearAllReminders() {
            if (!confirm('Vuoi cancellare TUTTI i promemoria dalla lista?\n\nQuesto rimuover√† i promemoria scaduti e permetter√† che scattino di nuovo.')) {
                return;
            }
            
            // Rimuovi tutti i flag "notified_" da localStorage
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('notified_')) {
                    keysToRemove.push(key);
                }
            }
            
            keysToRemove.forEach(key => localStorage.removeItem(key));
            
            console.log(`üóëÔ∏è Removed ${keysToRemove.length} notification flags from localStorage`);
            
            // Ricarica la pagina promemoria
            renderRemindersPage();
            
            showToast(`üóëÔ∏è ${keysToRemove.length} promemoria cancellati`);
        }

        function dismissReminder(taskId, reminder, dateKey) {
            localStorage.setItem(`dismissed_${taskId}_${reminder}_${dateKey}`, '1');
            renderRemindersPage();
            showToast('üîï Promemoria nascosto');
        }

        function renderUpcomingReminders() {
            const container = document.getElementById('remindersContainer');
            if (!container) return;

            const now = new Date();
            const sevenDaysFromNow = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);

            const upcomingReminders = [];

            tasks.filter(t => t.status === 'active' && t.reminders && t.reminders.length > 0).forEach(task => {
                let targetDate = null;

                if (task.type === 'single') {
                    targetDate = new Date(task.start_date);
                } else if (task.type === 'recurring' || task.type === 'simple_recurring') {
                    if (task.next_occurrence_date) {
                        targetDate = new Date(task.next_occurrence_date);
                    }
                } else if (task.type === 'multiple') {
                    if (task.next_occurrence_date) {
                        targetDate = new Date(task.next_occurrence_date);
                    }
                }

                if (!targetDate) return;

                task.reminders.forEach(reminder => {
                    const reminderTime = calculateReminderTime(targetDate, reminder);
                    if (!reminderTime) return;

                    if (reminderTime > now && reminderTime <= sevenDaysFromNow) {
                        upcomingReminders.push({
                            task: task,
                            reminder: reminder,
                            reminderTime: reminderTime,
                            targetDate: targetDate
                        });
                    }
                });
            });

            upcomingReminders.sort((a, b) => a.reminderTime - b.reminderTime);

            if (upcomingReminders.length === 0) {
                container.innerHTML = `
                    <div class="card" style="text-align: center; padding: 1.5rem;">
                        <h2 style="font-size: 3rem; margin-bottom: 1rem;">üìÖ</h2>
                        <h3 style="margin-bottom: 1rem;">Nessun promemoria nei prossimi 7 giorni</h3>
                        <p style="opacity: 0.7;">Non ci sono promemoria programmati per i prossimi 7 giorni</p>
                    </div>
                `;
                return;
            }

            const html = upcomingReminders.map(item => {
                const cats = categories.filter(c => item.task.categories?.includes(c.id));
                const timeUntilReminder = getTimeUntil(item.reminderTime);
                const timeUntilTask = getTimeUntil(item.targetDate);

                return `
                    <div class="card" style="border-left: 4px solid var(--accent);">
                        <div style="display: flex; justify-content: space-between; align-items: start; gap: 1rem;">
                            <div style="flex: 1;">
                                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                    <span style="font-size: 1.5rem;">üîî</span>
                                    <h3 style="margin: 0;">${item.task.title}</h3>
                                </div>
                                <p style="opacity: 0.8; margin: 0.5rem 0; font-size: 0.95rem;">
                                    üìã <strong>Promemoria:</strong> ${item.reminder} prima
                                </p>
                                <p style="opacity: 0.7; font-size: 0.9rem; margin: 0.3rem 0;">
                                    ‚è∞ Scatta tra: <strong>${timeUntilReminder}</strong>
                                </p>
                                <p style="opacity: 0.7; font-size: 0.9rem; margin: 0.3rem 0;">
                                    üìÖ Scadenza task: ${formatDateTime(item.targetDate)} (${timeUntilTask})
                                </p>
                                ${cats.length > 0 ? `
                                    <div class="category-pills" style="margin-top: 0.5rem;">
                                        ${cats.map(c => `<span class="category-pill" style="background: ${c.color}20; color: ${c.color}">${c.icon} ${c.name}</span>`).join('')}
                                    </div>
                                ` : ''}
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                                <button class="btn btn-primary btn-small" onclick="viewTask('${item.task.id}')">üëÅÔ∏è Vedi</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = html;
        }

        function updateRemindersBadge(count) {
            const menuItem = document.getElementById('remindersMenuItem');
            if (!menuItem) return;
            
            if (count > 0) {
                menuItem.innerHTML = `üîî <span style="background: var(--warning); color: #333; padding: 0; width: 1.2rem; height: 1.2rem; border-radius: 50%; font-size: 0.7rem; font-weight: 700; display: inline-flex; align-items: center; justify-content: center; position: absolute; top: 2px; right: 2px; line-height: 1;">${count}</span>`;
            } else {
                menuItem.innerHTML = 'üîî';
            }
        }
        
        function getTimeSince(date) {
            const now = new Date();
            const diff = now - new Date(date);
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            
            if (minutes < 1) return 'Ora';
            if (minutes < 60) return `${minutes} minuti fa`;
            if (hours < 24) return `${hours} ${hours === 1 ? 'ora' : 'ore'} fa`;
            return formatDateTime(date);
        }
        
        function getTimeUntil(date) {
            const now = new Date();
            const diff = new Date(date) - now;
            
            if (diff < 0) return 'Scaduto';
            
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);
            
            if (minutes < 1) return 'Ora!';
            if (minutes < 60) return `tra ${minutes} minuti`;
            if (hours < 24) return `tra ${hours} ${hours === 1 ? 'ora' : 'ore'}`;
            if (days < 7) return `tra ${days} ${days === 1 ? 'giorno' : 'giorni'}`;
            return formatDateTime(date);
        }

        // VIEW TASK
        function viewTask(id) {
            currentViewTaskId = id;
            const task = tasks.find(t => t.id === id);
            if (!task) return;
            
            const cats = categories.filter(c => task.categories?.includes(c.id));
            
            let details = `
                <div class="task-detail">
                    <div class="task-detail-row">
                        <span class="task-detail-label">Titolo:</span>
                        <span>${task.title}</span>
                    </div>
                    ${task.description ? `
                        <div class="task-detail-row">
                            <span class="task-detail-label">Descrizione:</span>
                            <span>${task.description}</span>
                        </div>
                    ` : ''}
                    <div class="task-detail-row">
                        <span class="task-detail-label">Tipo:</span>
                        <span>${task.type === 'single' ? 'Singolo' : task.type === 'recurring' ? 'Ricorrente' : task.type === 'simple_recurring' ? 'Ricorrenza semplice' : task.type === 'multiple' ? 'Multiplo' : task.type === 'workflow' ? 'Workflow' : 'A libera ripetizione'}</span>
                    </div>
            `;
            
            if (task.type === 'single') {
                details += `
                    <div class="task-detail-row">
                        <span class="task-detail-label">Inizio:</span>
                        <span>${isoToEu(task.start_date)}</span>
                    </div>
                    ${task.deadline ? `
                        <div class="task-detail-row">
                            <span class="task-detail-label">Scadenza:</span>
                            <span>${isoToEu(task.deadline)}</span>
                        </div>
                    ` : ''}
                `;
            } else if (task.type === 'simple_recurring') {
                details += `
                    <div class="task-detail-row">
                        <span class="task-detail-label">Prima occorrenza:</span>
                        <span>${isoToEu(task.start_date)}</span>
                    </div>
                    <div class="task-detail-row">
                        <span class="task-detail-label">Ripeti dopo:</span>
                        <span>${task.repeat_after_days} ${task.repeat_after_days === 1 ? 'giorno' : 'giorni'} dal completamento</span>
                    </div>
                    ${task.next_occurrence_date ? `
                        <div class="task-detail-row">
                            <span class="task-detail-label">Prossima occorrenza:</span>
                            <span>${isoToEu(task.next_occurrence_date)}</span>
                        </div>
                    ` : ''}
                    ${task.last_completed_date ? `
                        <div class="task-detail-row">
                            <span class="task-detail-label">Ultimo completamento:</span>
                            <span>${isoToEu(task.last_completed_date)}</span>
                        </div>
                    ` : ''}
                `;
            } else if (task.type === 'recurring' || task.type === 'free_repeat') {
                details += `
                    <div class="task-detail-row">
                        <span class="task-detail-label">Ricorrenza:</span>
                        <span>${getRecurringLabel(task)}</span>
                    </div>
                `;
                
                if (task.recurring_frequency === 'weekly' && task.recurring_days_of_week?.length) {
                    const dayNames = ['Dom', 'Lun', 'Mar', 'Mer', 'Gio', 'Ven', 'Sab'];
                    const days = task.recurring_days_of_week.map(d => dayNames[d]).join(', ');
                    details += `
                        <div class="task-detail-row">
                            <span class="task-detail-label">Giorni:</span>
                            <span>${days}</span>
                        </div>
                    `;
                } else if (task.recurring_frequency === 'monthly' && task.recurring_day_of_month?.length) {
                    const days = task.recurring_day_of_month.join(', ');
                    details += `
                        <div class="task-detail-row">
                            <span class="task-detail-label">Giorni del mese:</span>
                            <span>${days}</span>
                        </div>
                    `;
                } else if (task.recurring_frequency === 'yearly') {
                    const monthNames = ['', 'Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];
                    
                    let datesList = '';
                    if (task.recurring_dates && task.recurring_dates.length > 0) {
                        datesList = task.recurring_dates.map(dateStr => {
                            const [day, month] = dateStr.split('-');
                            return `${parseInt(day)} ${monthNames[parseInt(month)]}`;
                        }).join(', ');
                    } else if (task.recurring_day_of_year && task.recurring_month) {
                        datesList = `${task.recurring_day_of_year} ${monthNames[task.recurring_month]}`;
                    }
                    
                    details += `
                        <div class="task-detail-row">
                            <span class="task-detail-label">Date:</span>
                            <span>${datesList}</span>
                        </div>
                    `;
                }
            }
            
            // Mostra le date multiple se √® un task multiplo
            if (task.type === 'multiple' && task.multiple_dates && task.multiple_dates.length > 0) {
                const monthNames = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];
                const dayNames = ['Dom', 'Lun', 'Mar', 'Mer', 'Gio', 'Ven', 'Sab'];
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                // Trova la prossima data usando next_occurrence_date
                const allDates = task.multiple_dates;
                const totalDates = allDates.length;
                const nextOcc = task.next_occurrence_date ? task.next_occurrence_date.split('T')[0] : null;
                
                if (nextOcc) {
                    const remainingDates = allDates.filter(d => d >= nextOcc).length;
                    const nextDate = new Date(nextOcc + 'T00:00:00');
                    const dayName = dayNames[nextDate.getDay()];
                    const day = nextDate.getDate();
                    const monthName = monthNames[nextDate.getMonth()];
                    const year = nextDate.getFullYear();
                    
                    details += `
                        <div class="task-detail-row">
                            <span class="task-detail-label">Prossima data:</span>
                            <span style="font-weight: 700; color: var(--primary);">${dayName} ${day} ${monthName} ${year}</span>
                        </div>
                        <div class="task-detail-row">
                            <span class="task-detail-label">Date rimanenti:</span>
                            <span style="font-weight: 700;">${remainingDates} su ${totalDates}</span>
                        </div>
                    `;
                } else {
                    details += `
                        <div class="task-detail-row">
                            <span class="task-detail-label">Date:</span>
                            <span style="color: var(--muted);">Tutte le date sono passate (${totalDates} completate)</span>
                        </div>
                    `;
                }
            }
            
            // Workflow steps detail
            if (task.type === 'workflow' && task.workflow_steps) {
                const steps = task.workflow_steps;
                const completed = steps.filter(s => s.status === 'completed').length;
                const failed = steps.filter(s => s.status === 'failed').length;
                const done = completed + failed;
                const total = steps.length;
                const progressPct = total > 0 ? Math.round((done / total) * 100) : 0;
                const progressLabel = failed > 0 
                    ? `${completed}‚úì ${failed}‚úó / ${total} step (${progressPct}%)`
                    : `${completed}/${total} step (${progressPct}%)`;
                
                details += `
                    <div class="task-detail-row">
                        <span class="task-detail-label">Progresso:</span>
                        <span style="font-weight: 700;">${progressLabel}</span>
                    </div>
                    <div class="task-detail-row" style="flex-direction: column; gap: 0.5rem;">
                        <span class="task-detail-label">Step:</span>
                        <div style="width: 100%;">
                `;
                
                steps.forEach(step => {
                    const statusIcon = step.status === 'completed' ? '‚úÖ' : step.status === 'failed' ? '‚ùå' : step.status === 'active' ? '‚òê' : 'üîí';
                    const statusStyle = step.status === 'completed' ? 'text-decoration: line-through; opacity: 0.6;' : step.status === 'failed' ? 'opacity: 0.6;' : step.status === 'locked' ? 'opacity: 0.4;' : 'font-weight: 600;';
                    const depsText = step.depends_on.length > 0 
                        ? ` <span style="font-size: 0.75rem; color: #999;">(dopo: ${step.depends_on.map(d => {
                            const dep = steps.find(s => s.id === d);
                            return dep ? dep.title : '?';
                        }).join(', ')})</span>` : '';
                    
                    let dateInfo = '';
                    if (step.start_date) {
                        dateInfo += `<span style="font-size: 0.7rem; color: #888;">inizio: ${fmtDate(step.start_date)}</span>`;
                    }
                    if (step.completed_at) {
                        const label = step.status === 'failed' ? 'fallito' : 'completato';
                        const color = step.status === 'failed' ? 'var(--danger)' : 'var(--success)';
                        dateInfo += `<span style="font-size: 0.7rem; color: ${color};">${label}: ${fmtDate(step.completed_at)}</span>`;
                    }
                    
                    details += `
                        <div style="padding: 0.4rem; border-bottom: 1px solid #f0f0f0; ${statusStyle}">
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <span>${statusIcon}</span>
                                <span style="flex: 1;">${step.id}. ${step.title}${depsText}</span>
                            </div>
                            ${dateInfo ? `<div style="display: flex; gap: 0.8rem; margin-left: 1.5rem; margin-top: 0.15rem;">${dateInfo}</div>` : ''}
                        </div>
                    `;
                });
                
                details += `</div></div>`;
                
                // Mostra punti workflow
                const wfPts = task.workflow_points || {};
                details += `
                    <div class="task-detail-row">
                        <span class="task-detail-label">Punti Step:</span>
                        <span><span style="color: var(--success); font-weight: 700;">‚úì +${wfPts.step_success || 0}</span> / <span style="color: var(--danger); font-weight: 700;">‚úó ${wfPts.step_failure || 0}</span></span>
                    </div>
                    <div class="task-detail-row">
                        <span class="task-detail-label">Punti Task:</span>
                        <span><span style="color: var(--success); font-weight: 700;">‚úì +${wfPts.task_success || 0}</span> / <span style="color: var(--danger); font-weight: 700;">‚úó ${wfPts.task_failure || 0}</span></span>
                    </div>
                `;
            }
            
            if (cats.length) {
                details += `
                    <div class="task-detail-row">
                        <span class="task-detail-label">Categorie:</span>
                        <div class="category-pills">
                            ${cats.map(c => `<span class="category-pill" style="background: ${c.color}20; color: ${c.color}">${c.icon} ${c.name}</span>`).join('')}
                        </div>
                    </div>
                `;
            }
            
            if (task.reminders?.length) {
                details += `
                    <div class="task-detail-row">
                        <span class="task-detail-label">Promemoria:</span>
                        <span>${task.reminders.join(', ')}</span>
                    </div>
                `;
            }
            
            if (task.type !== 'workflow') {
                details += `
                    <div class="task-detail-row">
                        <span class="task-detail-label">Punti Successo:</span>
                        <span style="color: var(--success); font-weight: 700;">+${task.success_points}</span>
                    </div>
                `;
            }
            
            // Mostra fallimento/skip/ritardo in base al tipo
            if (task.type !== 'free_repeat' && task.type !== 'workflow') {
                details += `
                    <div class="task-detail-row">
                        <span class="task-detail-label">Punti Fallimento:</span>
                        <span style="color: var(--danger); font-weight: 700;">${task.failure_points}</span>
                    </div>
                `;
                
                if (task.type === 'single') {
                    details += `
                        <div class="task-detail-row">
                            <span class="task-detail-label">Punti Ritardo:</span>
                            <span style="color: #E67E22; font-weight: 700;">${task.late_points || 0}</span>
                        </div>
                    `;
                } else {
                    details += `
                        <div class="task-detail-row">
                            <span class="task-detail-label">Punti Skip:</span>
                            <span style="color: var(--warning); font-weight: 700;">${task.skip_points}</span>
                        </div>
                    `;
                }
            }
            
            details += `
                </div>
            `;
            
            document.getElementById('viewTaskContent').innerHTML = details;
            document.getElementById('viewTaskModal').classList.add('active');
        }

        function closeViewTaskModal() {
            document.getElementById('viewTaskModal').classList.remove('active');
            currentViewTaskId = null;
        }

        function editTaskFromView() {
            const taskId = currentViewTaskId;
            closeViewTaskModal();
            editTask(taskId);
        }

        function deleteTaskFromView() {
            const taskId = currentViewTaskId;
            closeViewTaskModal();
            deleteTask(taskId);
        }

        function archiveTaskFromView() {
            const taskId = currentViewTaskId;
            closeViewTaskModal();
            archiveTask(taskId);
        }

        function cloneTaskFromView() {
            const taskId = currentViewTaskId;
            closeViewTaskModal();
            cloneTask(taskId);
        }

        function cloneTask(id) {
            const task = tasks.find(t => t.id === id);
            if (!task) return;

            // Calcola il titolo con suffisso (n) incrementato
            const baseTitle = task.title.replace(/\s*\(\d+\)$/, '');
            const maxN = tasks.reduce((max, t) => {
                if (t.title === baseTitle) return Math.max(max, 1);
                const match = t.title.match(/^(.+?)\s*\((\d+)\)$/);
                if (match && match[1] === baseTitle) return Math.max(max, parseInt(match[2]));
                return max;
            }, 0);
            const newTitle = `${baseTitle} (${Math.max(maxN, 1) + 1})`;

            // Usa editTask per popolare tutti i campi del form
            editTask(id);

            // Override: nessun id (crea nuovo), nuovo titolo, titolo modale
            document.getElementById('editTaskId').value = '';
            document.getElementById('taskModalTitle').textContent = 'Clona Task';
            document.getElementById('taskTitle').value = newTitle;
        }

        async function archiveTask(id) {
            if (!confirm('Archiviare questo task?')) return;
            
            const { data, error } = await sb.from('ts_tasks')
                .update({ status: 'archived' })
                .eq('id', id)
                .select();
            
            if (data) {
                const index = tasks.findIndex(t => t.id === id);
                if (index !== -1) tasks[index] = data[0];
                renderTasks();
                renderDashboard();
                renderManagement();
            }
        }

        // CREATE/EDIT TASK
        function showCreateTaskModal() {
            console.log('üü¢ showCreateTaskModal called');
            document.getElementById('editTaskId').value = '';
            document.getElementById('taskModalTitle').textContent = 'Nuovo Task';
            document.getElementById('taskModal').classList.add('active');
            // Scroll al primo campo
            const modalContent = document.querySelector('#taskModal .modal-content');
            if (modalContent) modalContent.scrollTop = 0;
            document.getElementById('taskForm').reset();
            selectedCategories = [];
            reminders = [];
            console.log('üü¢ reminders reset to:', reminders);
            yearlyDates = []; // Reset date annuali
            multipleDates = []; // Reset date multiple
            wfResetSteps(); // Reset workflow steps
            renderCategoriesSelect();
            renderYearlyDates(); // Clear yearly dates display
            renderMultipleDates(); // Clear multiple dates display
            console.log('üü¢ About to call renderReminders()');
            renderReminders(); // Clear reminders display
            console.log('üü¢ Called renderReminders()');
            
            // Imposta data/ora corrente nel campo start_date
            const now = new Date();
            fpStart.setDate(now, false);

            // Imposta deadline a 23:59 dello stesso giorno
            const deadlineDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59);
            fpDeadline.setDate(deadlineDate, false);
            
            updateTaskFields();
        }

        function editTask(id) {
            const task = tasks.find(t => t.id === id);
            if (!task) return;
            
            document.getElementById('editTaskId').value = id;
            document.getElementById('taskModalTitle').textContent = 'Modifica Task';
            document.getElementById('taskTitle').value = task.title;
            document.getElementById('taskDescription').value = task.description || '';
            document.getElementById('taskType').value = task.type;
            document.getElementById('taskPriority').value = task.priority_id || '';
            
            // Date - imposta via Flatpickr (passa oggetto Date per evitare problemi
            // di parsing delle stringhe ISO di Supabase in Flatpickr)
            if (task.start_date) {
                fpStart.setDate(new Date(task.start_date), false);
            } else {
                fpStart.clear();
            }
            if (task.deadline) {
                fpDeadline.setDate(new Date(task.deadline), false);
            } else {
                fpDeadline.clear();
            }
            
            // Ricorrenza
            if (task.type === 'recurring') {
                document.getElementById('recurringFrequency').value = task.recurring_frequency;
                document.getElementById('recurringInterval').value = task.recurring_interval || 1;
                
                if (task.recurring_frequency === 'weekly' && task.recurring_days_of_week) {
                    document.querySelectorAll('.week-day').forEach(cb => {
                        cb.checked = task.recurring_days_of_week.includes(parseInt(cb.value));
                    });
                } else if (task.recurring_frequency === 'monthly') {
                    document.querySelectorAll('.month-day').forEach(cb => {
                        cb.checked = task.recurring_day_of_month && task.recurring_day_of_month.includes(parseInt(cb.value));
                    });
                } else if (task.recurring_frequency === 'yearly') {
                    // Carica date nel nuovo formato
                    if (task.recurring_dates && task.recurring_dates.length > 0) {
                        yearlyDates = [...task.recurring_dates];
                        renderYearlyDates();
                    } else if (task.recurring_day_of_year && task.recurring_month) {
                        // Compatibilit√† con vecchio formato
                        const dateStr = String(task.recurring_day_of_year).padStart(2, '0') + '-' + 
                                       String(task.recurring_month).padStart(2, '0');
                        yearlyDates = [dateStr];
                        renderYearlyDates();
                    }
                }
            } else if (task.type === 'simple_recurring') {
                document.getElementById('repeatAfterDays').value = task.repeat_after_days || 7;
            } else if (task.type === 'multiple') {
                // Carica date multiple
                if (task.multiple_dates && task.multiple_dates.length > 0) {
                    multipleDates = [...task.multiple_dates];
                    renderMultipleDates();
                }
            } else if (task.type === 'workflow') {
                // Carica workflow steps
                workflowSteps = task.workflow_steps ? JSON.parse(JSON.stringify(task.workflow_steps)) : [];
                wfRenderSteps();
                wfUpdateDependsList();
                // Carica punti workflow
                const wfPts = task.workflow_points || {};
                document.getElementById('wfStepSuccessPoints').value = wfPts.step_success ?? 5;
                document.getElementById('wfStepFailurePoints').value = wfPts.step_failure ?? -3;
                document.getElementById('wfTaskSuccessPoints').value = wfPts.task_success ?? 20;
                document.getElementById('wfTaskFailurePoints').value = wfPts.task_failure ?? -10;
            }
            
            // Categorie
            selectedCategories = task.categories || [];
            
            // Promemoria
            reminders = task.reminders || [];
            
            // Punti
            document.getElementById('successPoints').value = task.success_points;
            document.getElementById('failurePoints').value = task.failure_points;
            document.getElementById('skipPoints').value = task.skip_points;
            document.getElementById('latePoints').value = task.late_points || 0;
            
            renderCategoriesSelect();
            updateTaskFields();
            renderReminders();
            
            document.getElementById('taskModal').classList.add('active');
            // Scroll al primo campo
            const modalContentEdit = document.querySelector('#taskModal .modal-content');
            if (modalContentEdit) modalContentEdit.scrollTop = 0;
        }

        function closeTaskModal() {
            document.getElementById('taskModal').classList.remove('active');
        }

        function renderCategoriesSelect() {
            const listEl = document.getElementById('taskCategoriesSelect');
            if (!listEl) {
                console.error('‚ùå taskCategoriesSelect element not found');
                return;
            }
            
            // Conta task per categoria
            const categoriesWithCount = categories.map(cat => ({
                ...cat,
                taskCount: tasks.filter(t => t.categories?.includes(cat.id) && t.status === 'active').length
            }));
            
            // Ordina per numero task (decrescente)
            categoriesWithCount.sort((a, b) => b.taskCount - a.taskCount);
            
            listEl.innerHTML = `
                <!-- Disponibili: chip cliccabili a tutta larghezza -->
                <div style="display: flex; flex-wrap: wrap; gap: 0.4rem; padding: 0.5rem; background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 6px; min-height: 36px; margin-bottom: 0.5rem;">
                    ${categoriesWithCount.map(cat => {
                        const isSelected = selectedCategories.includes(cat.id);
                        return `<div onclick="${isSelected ? `unselectCategoryInline('${cat.id}')` : `selectCategoryInline('${cat.id}')`}" style="
                            display: inline-flex; align-items: center; gap: 0.3rem;
                            padding: 0.25rem 0.6rem; border-radius: 20px; cursor: pointer;
                            font-size: 0.85rem; transition: all 0.15s; user-select: none;
                            ${isSelected 
                                ? 'background: var(--accent); color: #fff; border: 1px solid var(--accent);' 
                                : 'background: #fff; color: #333; border: 1px solid #ddd;'}
                        " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
                            ${cat.icon} ${cat.name} <span style="opacity: 0.7; font-size: 0.75rem;">(${cat.taskCount})</span>
                            ${isSelected ? '<span style="margin-left: 0.2rem; font-size: 0.9rem;">‚úï</span>' : ''}
                        </div>`;
                    }).join('')}
                </div>
            `;
        }
        
        function selectCategoryInline(id) {
            console.log('üü¢ Selecting category:', id);
            if (!selectedCategories.includes(id)) {
                selectedCategories.push(id);
                renderCategoriesSelect();
            }
        }
        
        function unselectCategoryInline(id) {
            console.log('üî¥ Unselecting category:', id);
            selectedCategories = selectedCategories.filter(c => c !== id);
            renderCategoriesSelect();
        }

        function toggleCategory(id) {
            if (selectedCategories.includes(id)) {
                selectedCategories = selectedCategories.filter(c => c !== id);
            } else {
                selectedCategories.push(id);
            }
        }

        function updateTaskFields() {
            const type = document.getElementById('taskType').value;
            const startDateInput = document.getElementById('taskStartDate');
            
            // Nascondi tutti i gruppi
            document.getElementById('deadlineGroup').classList.add('hidden');
            document.getElementById('recurringGroup').classList.add('hidden');
            document.getElementById('intervalGroup').classList.add('hidden');
            document.getElementById('weekDaysGroup').classList.add('hidden');
            document.getElementById('monthDayGroup').classList.add('hidden');
            document.getElementById('yearDateGroup').classList.add('hidden');
            document.getElementById('simpleRecurringGroup').classList.add('hidden');
            document.getElementById('multipleDatesGroup').classList.add('hidden');
            document.getElementById('workflowGroup').classList.add('hidden');
            
            // Gestisci punti fallimento/skip/ritardo per tipo
            document.getElementById('workflowPointsGroup').style.display = 'none';
            document.getElementById('standardPointsGroup').style.display = 'grid';
            if (type === 'free_repeat' || type === 'workflow') {
                document.getElementById('failurePointsGroup').classList.add('hidden');
                document.getElementById('skipPointsGroup').classList.add('hidden');
                document.getElementById('latePointsGroup').classList.add('hidden');
                if (type === 'workflow') {
                    document.getElementById('standardPointsGroup').style.display = 'none';
                    document.getElementById('workflowPointsGroup').style.display = 'block';
                }
            } else if (type === 'single') {
                document.getElementById('failurePointsGroup').classList.remove('hidden');
                document.getElementById('skipPointsGroup').classList.add('hidden');
                document.getElementById('latePointsGroup').classList.remove('hidden');
            } else {
                document.getElementById('failurePointsGroup').classList.remove('hidden');
                document.getElementById('skipPointsGroup').classList.remove('hidden');
                document.getElementById('latePointsGroup').classList.add('hidden');
            }
            
            if (type === 'single') {
                document.getElementById('startDateGroup').classList.remove('hidden');
                startDateInput.required = true;
                document.getElementById('deadlineGroup').classList.remove('hidden');
            } else if (type === 'recurring') {
                document.getElementById('startDateGroup').classList.remove('hidden');
                startDateInput.required = true;
                document.getElementById('recurringGroup').classList.remove('hidden');
                document.getElementById('intervalGroup').classList.remove('hidden');
                updateRecurringFields();
            } else if (type === 'simple_recurring') {
                // Ricorrenza semplice: data/ora inizio + giorni dopo completamento
                document.getElementById('startDateGroup').classList.remove('hidden');
                startDateInput.required = true;
                document.getElementById('simpleRecurringGroup').classList.remove('hidden');
            } else if (type === 'multiple') {
                // Task multiplo: seleziona pi√π date specifiche
                document.getElementById('startDateGroup').classList.add('hidden');
                startDateInput.required = false;
                document.getElementById('multipleDatesGroup').classList.remove('hidden');
                // Inizializza con la data di oggi se non ci sono date
                if (multipleDates.length === 0) {
                    const today = new Date();
                    const todayStr = today.getFullYear() + '-' + String(today.getMonth() + 1).padStart(2, '0') + '-' + String(today.getDate()).padStart(2, '0');
                    multipleDates.push(todayStr);
                    updateMultipleDatesTextbox();
                }
            } else if (type === 'free_repeat') {
                // A libera ripetizione: nessuna data richiesta
                document.getElementById('startDateGroup').classList.add('hidden');
                startDateInput.required = false;
            } else if (type === 'workflow') {
                // Workflow: data inizio + step builder
                document.getElementById('startDateGroup').classList.remove('hidden');
                startDateInput.required = true;
                document.getElementById('workflowGroup').classList.remove('hidden');
            }
        }

        function updateRecurringFieldsFromStartDate() {
            // Chiamata quando cambia la start_date, aggiorna i campi ricorrenti
            const type = document.getElementById('taskType').value;
            if (type === 'recurring') {
                updateRecurringFields();
            }
        }
        
        // ========================================
        // WORKFLOW STEP MANAGEMENT
        // ========================================
        let workflowSteps = [];
        let wfEditingStepId = null;
        
        function wfToggleNone() {
            const noneCheckbox = document.getElementById('wfDepNone');
            if (noneCheckbox.checked) {
                // Deseleziona tutti gli altri
                document.querySelectorAll('.wf-dep-check').forEach(cb => cb.checked = false);
            }
        }
        
        function wfToggleDep(cb) {
            const noneCheckbox = document.getElementById('wfDepNone');
            if (cb.checked) {
                noneCheckbox.checked = false;
            }
            // Se nessuna dipendenza selezionata, riattiva "Nessuno"
            const anyChecked = document.querySelectorAll('.wf-dep-check:checked').length > 0;
            if (!anyChecked) noneCheckbox.checked = true;
        }
        
        function wfEditStep(stepId) {
            const step = workflowSteps.find(s => s.id === stepId);
            if (!step) return;
            
            wfEditingStepId = stepId;
            
            // Popola il form
            document.getElementById('wfNewStepTitle').value = step.title;
            
            // Aggiorna la lista dipendenze (esclude lo step in modifica)
            wfUpdateDependsList();
            
            // Seleziona le dipendenze corrette
            if (step.depends_on.length === 0) {
                document.getElementById('wfDepNone').checked = true;
            } else {
                document.getElementById('wfDepNone').checked = false;
                document.querySelectorAll('.wf-dep-check').forEach(cb => {
                    cb.checked = step.depends_on.includes(parseInt(cb.value));
                });
            }
            
            // Cambia bottone
            const btn = document.getElementById('wfAddBtn');
            btn.textContent = '‚úèÔ∏è Salva Modifica';
            btn.style.background = 'var(--warning)';
            
            // Mostra bottone annulla
            document.getElementById('wfCancelBtn').style.display = 'block';
        }
        
        function wfCancelEdit() {
            wfEditingStepId = null;
            document.getElementById('wfNewStepTitle').value = '';
            
            const btn = document.getElementById('wfAddBtn');
            btn.textContent = '+ Aggiungi Step';
            btn.style.background = '';
            document.getElementById('wfCancelBtn').style.display = 'none';
            
            wfUpdateDependsList();
            wfRenderGraphPreview();
        }
        
        function wfAddStep() {
            const titleInput = document.getElementById('wfNewStepTitle');
            const title = titleInput.value.trim();
            if (!title) {
                alert('Inserisci un nome per lo step');
                return;
            }
            
            const noneChecked = document.getElementById('wfDepNone').checked;
            let dependsOn = [];
            if (!noneChecked) {
                dependsOn = Array.from(document.querySelectorAll('.wf-dep-check:checked'))
                    .map(cb => parseInt(cb.value));
            }
            
            if (wfEditingStepId !== null) {
                // MODIFICA step esistente
                const step = workflowSteps.find(s => s.id === wfEditingStepId);
                if (step) {
                    step.title = title;
                    step.depends_on = dependsOn;
                    step.status = dependsOn.length === 0 ? 'active' : 'locked';
                }
                wfEditingStepId = null;
                
                const btn = document.getElementById('wfAddBtn');
                btn.textContent = '+ Aggiungi Step';
                btn.style.background = '';
                document.getElementById('wfCancelBtn').style.display = 'none';
            } else {
                // NUOVO step
                const stepId = workflowSteps.length + 1;
                workflowSteps.push({
                    id: stepId,
                    title: title,
                    depends_on: dependsOn,
                    status: dependsOn.length === 0 ? 'active' : 'locked'
                });
            }
            
            titleInput.value = '';
            wfRenderSteps();
            wfUpdateDependsList();
        }
        
        function wfRemoveStep(stepId) {
            // Se sto modificando questo step, annulla
            if (wfEditingStepId === stepId) wfCancelEdit();
            // Rimuovi lo step e tutte le dipendenze che puntano ad esso
            workflowSteps = workflowSteps.filter(s => s.id !== stepId);
            workflowSteps.forEach(s => {
                s.depends_on = s.depends_on.filter(d => d !== stepId);
                // Se non ha pi√π dipendenze, diventa active
                if (s.depends_on.length === 0) s.status = 'active';
            });
            // Crea mappa oldId ‚Üí newId
            const idMap = {};
            workflowSteps.forEach((s, i) => {
                idMap[s.id] = i + 1;
            });
            // Aggiorna wfEditingStepId se attivo
            if (wfEditingStepId !== null && idMap[wfEditingStepId] !== undefined) {
                wfEditingStepId = idMap[wfEditingStepId];
            }
            // Applica rinumerazione
            workflowSteps.forEach(s => {
                s.id = idMap[s.id];
                s.depends_on = s.depends_on.map(d => idMap[d]);
            });
            wfRenderSteps();
            wfUpdateDependsList();
        }
        
        function wfRenderSteps() {
            wfRenderGraphPreview();
        }
        
        function wfRenderGraphPreview() {
            const content = document.getElementById('wfGraphContent');
            if (!content) return;
            
            if (workflowSteps.length === 0) {
                content.innerHTML = '<p style="opacity: 0.5; font-size: 0.85rem; text-align: center;">Aggiungi almeno 2 step per vedere il grafo</p>';
                return;
            }
            
            if (workflowSteps.length === 1) {
                const step = workflowSteps[0];
                const palette = ['#2563EB','#8B5CF6','#059669','#D97706','#DC2626'];
                const color = palette[0];
                content.innerHTML = `
                    <div style="display:flex;justify-content:center;padding:0.5rem;">
                        <div style="background:white;border:2px solid ${color};border-radius:8px;padding:0.5rem 0.8rem;display:flex;align-items:center;gap:0.5rem;box-shadow:0 2px 6px rgba(0,0,0,0.1);">
                            <span style="background:${color};color:white;width:22px;height:22px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:11px;font-weight:800;">1</span>
                            <span style="font-weight:600;font-size:0.9rem;">${step.title}</span>
                            <button type="button" onclick="event.preventDefault();event.stopPropagation();wfEditStep(1)" style="background:none;border:none;cursor:pointer;font-size:0.85rem;padding:2px;">‚úèÔ∏è</button>
                            <button type="button" onclick="event.preventDefault();event.stopPropagation();wfRemoveStep(1)" style="background:none;border:none;cursor:pointer;font-size:0.85rem;padding:2px;">üóëÔ∏è</button>
                        </div>
                    </div>
                    <p style="opacity:0.4;font-size:0.8rem;text-align:center;margin-top:0.3rem;">Aggiungi un altro step</p>`;
                return;
            }
            
            // Calcola livelli
            const levels = wfCalcLevels(workflowSteps);
            const maxLevel = Math.max(...Object.values(levels), 0);
            
            // Dimensioni nodo pi√π grande per bottoni
            const nodeW = 140, nodeH = 64, gapX = 24, gapY = 50;
            const padX = 20, padY = 20;
            
            // Organizza step per livello
            const levelGroups = {};
            for (let l = 0; l <= maxLevel; l++) {
                levelGroups[l] = workflowSteps.filter(s => levels[s.id] === l);
            }
            const maxPerRow = Math.max(...Object.values(levelGroups).map(g => g.length), 1);
            
            const svgW = Math.max(padX * 2 + maxPerRow * nodeW + (maxPerRow - 1) * gapX, 300);
            const svgH = padY * 2 + (maxLevel + 1) * nodeH + maxLevel * gapY;
            
            // Calcola posizione centro di ogni nodo
            const nodePos = {};
            for (let l = 0; l <= maxLevel; l++) {
                const group = levelGroups[l];
                const totalW = group.length * nodeW + (group.length - 1) * gapX;
                const startX = (svgW - totalW) / 2;
                group.forEach((step, i) => {
                    nodePos[step.id] = {
                        x: startX + i * (nodeW + gapX) + nodeW / 2,
                        y: padY + l * (nodeH + gapY) + nodeH / 2
                    };
                });
            }
            
            // Colori
            const palette = ['#2563EB','#8B5CF6','#059669','#D97706','#DC2626','#0891B2','#7C3AED','#16A34A','#CA8A04','#E11D48'];
            const getColor = (id) => palette[(id - 1) % palette.length];
            
            // Costruisci SVG
            let svg = `<svg width="100%" viewBox="0 0 ${svgW} ${svgH}" style="display: block; max-width: 100%;" xmlns="http://www.w3.org/2000/svg">`;
            
            // Defs
            svg += `<defs>
                <marker id="wfArrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse">
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="#94a3b8"/>
                </marker>
                <filter id="wfShadow" x="-10%" y="-10%" width="130%" height="140%">
                    <feDropShadow dx="0" dy="2" stdDeviation="3" flood-opacity="0.12"/>
                </filter>
            </defs>`;
            
            // Disegna frecce
            workflowSteps.forEach(step => {
                step.depends_on.forEach(depId => {
                    const from = nodePos[depId];
                    const to = nodePos[step.id];
                    if (!from || !to) return;
                    
                    const x1 = from.x, y1 = from.y + nodeH / 2;
                    const x2 = to.x, y2 = to.y - nodeH / 2;
                    const midY = (y1 + y2) / 2;
                    
                    svg += `<path d="M ${x1} ${y1} C ${x1} ${midY}, ${x2} ${midY}, ${x2} ${y2}" 
                        fill="none" stroke="#94a3b8" stroke-width="2" marker-end="url(#wfArrow)" 
                        stroke-dasharray="${Math.abs(x1 - x2) > nodeW ? '6,3' : 'none'}"
                        opacity="0.7"/>`;
                });
            });
            
            // Disegna nodi con bottoni
            workflowSteps.forEach(step => {
                const pos = nodePos[step.id];
                if (!pos) return;
                const color = getColor(step.id);
                const x = pos.x - nodeW / 2;
                const y = pos.y - nodeH / 2;
                const isStart = step.depends_on.length === 0;
                const isEnd = !workflowSteps.some(s => s.depends_on.includes(step.id));
                
                // Nodo rettangolo arrotondato con ombra
                svg += `<g filter="url(#wfShadow)">
                    <rect x="${x}" y="${y}" width="${nodeW}" height="${nodeH}" rx="8" ry="8" 
                        fill="white" stroke="${color}" stroke-width="2.5"/>
                </g>`;
                
                // Pallino ID colorato
                svg += `<circle cx="${x + 16}" cy="${y + 20}" r="10" fill="${color}"/>
                    <text x="${x + 16}" y="${y + 21}" text-anchor="middle" dominant-baseline="central" 
                        fill="white" font-size="10" font-weight="800">${step.id}</text>`;
                
                // Titolo
                const maxChars = 10;
                const label = step.title.length > maxChars ? step.title.substring(0, maxChars) + '‚Ä¶' : step.title;
                svg += `<text x="${x + 32}" y="${y + 21}" dominant-baseline="central" 
                    fill="#333" font-size="11" font-weight="600">
                    <title>${step.title}</title>${label}</text>`;
                
                // Badge START / END
                if (isStart) {
                    svg += `<rect x="${x + nodeW - 38}" y="${y + 3}" width="34" height="13" rx="3" fill="#d1fae5"/>
                        <text x="${x + nodeW - 21}" y="${y + 12}" text-anchor="middle" fill="#065f46" font-size="7.5" font-weight="700">START</text>`;
                }
                if (isEnd) {
                    svg += `<rect x="${x + nodeW - 30}" y="${y + 3}" width="26" height="13" rx="3" fill="#dbeafe"/>
                        <text x="${x + nodeW - 17}" y="${y + 12}" text-anchor="middle" fill="#1e40af" font-size="7.5" font-weight="700">END</text>`;
                }
                
                // Bottoni modifica e cancella (SVG nativo)
                const btnY = y + nodeH - 22;
                const btnW = (nodeW - 12) / 2 - 2;
                // Bottone Modifica
                svg += `<g style="cursor:pointer" onclick="wfEditStep(${step.id})">
                    <rect x="${x + 4}" y="${btnY}" width="${btnW}" height="18" rx="3" fill="${color}" fill-opacity="0.1" stroke="${color}" stroke-opacity="0.4" stroke-width="1"/>
                    <text x="${x + 4 + btnW/2}" y="${btnY + 12}" text-anchor="middle" fill="${color}" font-size="9" font-weight="700">‚úè Modifica</text>
                </g>`;
                // Bottone Elimina
                svg += `<g style="cursor:pointer" onclick="wfRemoveStep(${step.id})">
                    <rect x="${x + 4 + btnW + 4}" y="${btnY}" width="${btnW}" height="18" rx="3" fill="#dc2626" fill-opacity="0.08" stroke="#fca5a5" stroke-width="1"/>
                    <text x="${x + 4 + btnW + 4 + btnW/2}" y="${btnY + 12}" text-anchor="middle" fill="#dc2626" font-size="9" font-weight="700">üóë Elimina</text>
                </g>`;
            });
            
            svg += '</svg>';
            content.innerHTML = svg;
        }
        
        // Trova tutti i discendenti di uno step (chi dipende da lui, direttamente o indirettamente)
        function wfGetDescendants(stepId) {
            const descendants = new Set();
            const queue = [stepId];
            while (queue.length > 0) {
                const current = queue.shift();
                workflowSteps.forEach(s => {
                    if (s.depends_on.includes(current) && !descendants.has(s.id)) {
                        descendants.add(s.id);
                        queue.push(s.id);
                    }
                });
            }
            return descendants;
        }
        
        function wfUpdateDependsList() {
            const container = document.getElementById('wfDependsOnList');
            if (!container) return;
            
            // Calcola discendenti dello step in modifica (per prevenire cicli)
            const forbidden = wfEditingStepId !== null ? wfGetDescendants(wfEditingStepId) : new Set();
            
            let html = `
                <label style="display: flex; align-items: center; gap: 0.4rem; padding: 0.3rem; cursor: pointer; font-size: 0.85rem;">
                    <input type="checkbox" id="wfDepNone" checked onchange="wfToggleNone()"> Nessuno (inizia subito)
                </label>
            `;
            
            workflowSteps.forEach(step => {
                // Non mostrare lo step in modifica
                if (step.id === wfEditingStepId) return;
                
                const isForbidden = forbidden.has(step.id);
                const disabledAttr = isForbidden ? 'disabled' : '';
                const labelStyle = isForbidden 
                    ? 'display: flex; align-items: center; gap: 0.4rem; padding: 0.3rem; font-size: 0.85rem; opacity: 0.35; cursor: not-allowed;'
                    : 'display: flex; align-items: center; gap: 0.4rem; padding: 0.3rem; cursor: pointer; font-size: 0.85rem;';
                const warningText = isForbidden ? ' <span style="color: var(--danger); font-size: 0.7rem;">(ciclo)</span>' : '';
                
                html += `
                    <label style="${labelStyle}">
                        <input type="checkbox" class="wf-dep-check" value="${step.id}" ${disabledAttr} onchange="wfToggleDep(this)"> ${step.id}. ${step.title}${warningText}
                    </label>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function wfResetSteps() {
            workflowSteps = [];
            wfEditingStepId = null;
            wfRenderSteps();
            wfUpdateDependsList();
        }

        function autoUpdateDeadline() {
            const startDateInput = document.getElementById('taskStartDate');
            const deadlineInput = document.getElementById('taskDeadline');
            
            if (!startDateInput.value || !deadlineInput.value) return;
            
            const startIso = euToIso(startDateInput.value) || startDateInput.value;
            const deadlineIso = euToIso(deadlineInput.value) || deadlineInput.value;
            const startDate = new Date(startIso);
            const deadline = new Date(deadlineIso);
            
            // Se start_date √® maggiore di deadline, aggiorna deadline
            if (startDate > deadline) {
                fpDeadline.setDate(startDate, false);
                console.log('‚ö†Ô∏è Deadline auto-aggiornata a start_date');
            }
        }

        function updateRecurringFields() {
            const freq = document.getElementById('recurringFrequency').value;
            
            const labels = {
                daily: 'giorni',
                weekly: 'settimane',
                monthly: 'mesi',
                yearly: 'anni'
            };
            document.getElementById('intervalLabel').textContent = labels[freq] || 'unit√†';
            
            document.getElementById('weekDaysGroup').classList.add('hidden');
            document.getElementById('monthDayGroup').classList.add('hidden');
            document.getElementById('yearDateGroup').classList.add('hidden');
            
            // Ottieni la start_date per pre-compilare i campi
            const startDateRaw = document.getElementById('taskStartDate').value;
            let startDate = null;
            if (startDateRaw) {
                const isoVal = euToIso(startDateRaw) || startDateRaw;
                startDate = new Date(isoVal);
            } else {
                startDate = new Date();
            }
            
            if (freq === 'weekly') {
                document.getElementById('weekDaysGroup').classList.remove('hidden');
                
                // Auto-seleziona il giorno della settimana dalla start_date
                const dayOfWeek = startDate.getDay(); // 0=Dom, 1=Lun, ..., 6=Sab
                document.querySelectorAll('.week-day').forEach(checkbox => {
                    if (parseInt(checkbox.value) === dayOfWeek) {
                        checkbox.checked = true;
                    }
                });
                
            } else if (freq === 'monthly') {
                document.getElementById('monthDayGroup').classList.remove('hidden');
                
                // Auto-seleziona il giorno del mese dalla start_date
                const dayOfMonth = startDate.getDate();
                document.querySelectorAll('.month-day').forEach(checkbox => {
                    if (parseInt(checkbox.value) === dayOfMonth) {
                        checkbox.checked = true;
                    }
                });
                
            } else if (freq === 'yearly') {
                document.getElementById('yearDateGroup').classList.remove('hidden');
                
                // Auto-aggiungi la data dalla start_date
                const day = startDate.getDate();
                const month = startDate.getMonth() + 1; // 0-indexed -> 1-indexed
                
                document.getElementById('quickDay').value = day;
                document.getElementById('quickMonth').value = month;
                
                // Se non ci sono date gi√† selezionate, aggiungi questa automaticamente
                if (yearlyDates.length === 0) {
                    const dateStr = String(day).padStart(2, '0') + '-' + String(month).padStart(2, '0');
                    yearlyDates.push(dateStr);
                    renderYearlyDates();
                }
            }
        }

        /* FUNZIONE NON USATA - COMMENTATA v16.0
        function addReminder() {
            console.log('üü° addReminder called');
            
            // Mostra modal con due liste
            showReminderSelectorModal();
        }
        */
        
        async function showReminderSelectorModal() {
            // Ricarica preset da DB ad ogni apertura
            await loadReminderPresets();

            // Crea modal overlay
            const modal = document.createElement('div');
            modal.id = 'reminderSelectorModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                padding: 0.5rem;
            `;
            
            // Lista promemoria da DB (cm_reminder_presets)
            const availableReminders = reminderPresets.map(p => p.label);

            // Filtra quelli gi√† selezionati
            const available = availableReminders.filter(r => !reminders.includes(r));
            
            modal.innerHTML = `
                <div style="background: var(--dark); border-radius: 0; padding: 1.0rem; max-width: 800px; width: 100%; max-height: 80vh; overflow: auto; border: 1px solid rgba(255,255,255,0.1);">
                    <h2 style="margin: 0 0 1.5rem 0; color: var(--accent);">üìã Seleziona Promemoria</h2>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 1.5rem;">
                        <!-- Lista Disponibili -->
                        <div>
                            <h3 style="margin: 0 0 1rem 0; font-size: 1rem; color: var(--accent);">Disponibili</h3>
                            <div id="availableList" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1); border-radius: 0; padding: 0.25rem; min-height: 300px; max-height: 400px; overflow-y: auto;">
                                ${available.map(r => `
                                    <div class="reminder-option" data-value="${r}" onclick="selectReminder('${r}')" style="
                                        background: rgba(255,255,255,0.05);
                                        padding: 0.4rem 0.5rem;
                                        margin: 0.5rem 0;
                                        border-radius: 0;
                                        cursor: pointer;
                                        transition: all 0.2s ease;
                                        border: 1px solid transparent;
                                    " onmouseover="this.style.background='rgba(52,152,219,0.2)'; this.style.borderColor='var(--accent)'" onmouseout="this.style.background='rgba(255,255,255,0.05)'; this.style.borderColor='transparent'">
                                        ${r}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        <!-- Lista Selezionati -->
                        <div>
                            <h3 style="margin: 0 0 1rem 0; font-size: 1rem; color: var(--success);">‚úì Selezionati</h3>
                            <div id="selectedList" style="background: rgba(46,204,113,0.1); border: 1px solid rgba(46,204,113,0.3); border-radius: 0; padding: 0.25rem; min-height: 300px; max-height: 400px; overflow-y: auto;">
                                ${reminders.map(r => `
                                    <div class="reminder-selected" data-value="${r}" onclick="unselectReminder('${r}')" style="
                                        background: rgba(46,204,113,0.15);
                                        padding: 0.4rem 0.5rem;
                                        margin: 0.5rem 0;
                                        border-radius: 0;
                                        cursor: pointer;
                                        transition: all 0.2s ease;
                                        border: 1px solid rgba(46,204,113,0.4);
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: center;
                                    " onmouseover="this.style.background='rgba(231,76,60,0.2)'; this.style.borderColor='var(--danger)'" onmouseout="this.style.background='rgba(46,204,113,0.15)'; this.style.borderColor='rgba(46,204,113,0.4)'">
                                        <span>${r}</span>
                                        <span style="color: var(--danger); font-weight: bold;">√ó</span>
                                    </div>
                                `).join('')}
                                ${reminders.length === 0 ? '<p style="opacity: 0.5; text-align: center; padding: 1.0rem;">Nessun promemoria selezionato</p>' : ''}
                            </div>
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                        <button onclick="closeReminderSelectorModal()" class="btn btn-secondary">Annulla</button>
                        <button onclick="confirmReminderSelection()" class="btn btn-success">‚úì Conferma</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function selectReminder(value) {
            console.log('üü¢ Selecting:', value);
            if (!reminders.includes(value)) {
                reminders.push(value);
                updateReminderSelectorLists();
            }
        }
        
        function unselectReminder(value) {
            console.log('üî¥ Unselecting:', value);
            const index = reminders.indexOf(value);
            if (index > -1) {
                reminders.splice(index, 1);
                updateReminderSelectorLists();
            }
        }
        
        function updateReminderSelectorLists() {
            const availableReminders = reminderPresets.map(p => p.label);
            
            const available = availableReminders.filter(r => !reminders.includes(r));
            
            // Aggiorna lista disponibili
            const availableList = document.getElementById('availableList');
            if (availableList) {
                availableList.innerHTML = available.map(r => `
                    <div class="reminder-option" data-value="${r}" onclick="selectReminder('${r}')" style="
                        background: rgba(255,255,255,0.05);
                        padding: 0.4rem 0.5rem;
                        margin: 0.5rem 0;
                        border-radius: 0;
                        cursor: pointer;
                        transition: all 0.2s ease;
                        border: 1px solid transparent;
                    " onmouseover="this.style.background='rgba(52,152,219,0.2)'; this.style.borderColor='var(--accent)'" onmouseout="this.style.background='rgba(255,255,255,0.05)'; this.style.borderColor='transparent'">
                        ${r}
                    </div>
                `).join('');
            }
            
            // Aggiorna lista selezionati
            const selectedList = document.getElementById('selectedList');
            if (selectedList) {
                selectedList.innerHTML = reminders.length > 0 ? reminders.map(r => `
                    <div class="reminder-selected" data-value="${r}" onclick="unselectReminder('${r}')" style="
                        background: rgba(46,204,113,0.15);
                        padding: 0.4rem 0.5rem;
                        margin: 0.5rem 0;
                        border-radius: 0;
                        cursor: pointer;
                        transition: all 0.2s ease;
                        border: 1px solid rgba(46,204,113,0.4);
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    " onmouseover="this.style.background='rgba(231,76,60,0.2)'; this.style.borderColor='var(--danger)'" onmouseout="this.style.background='rgba(46,204,113,0.15)'; this.style.borderColor='rgba(46,204,113,0.4)'">
                        <span>${r}</span>
                        <span style="color: var(--danger); font-weight: bold;">√ó</span>
                    </div>
                `).join('') : '<p style="opacity: 0.5; text-align: center; padding: 1.0rem;">Nessun promemoria selezionato</p>';
            }
        }
        
        function closeReminderSelectorModal() {
            const modal = document.getElementById('reminderSelectorModal');
            if (modal) {
                modal.remove();
            }
        }
        
        function confirmReminderSelection() {
            console.log('‚úÖ Confirmed reminders:', reminders);
            closeReminderSelectorModal();
            renderReminders();
        }

        function renderReminders() {
            console.log('üîµ renderReminders called, reminders:', reminders);
            const listEl = document.getElementById('remindersList');
            console.log('üîµ remindersList element:', listEl);
            
            if (!listEl) {
                console.error('‚ùå remindersList element not found');
                return;
            }
            
            // Lista promemoria da DB (cm_reminder_presets)
            const availableReminders = reminderPresets.map(p => p.label);
            
            listEl.innerHTML = `
                <!-- Disponibili: chip cliccabili a tutta larghezza -->
                <div style="display: flex; flex-wrap: wrap; gap: 0.4rem; padding: 0.5rem; background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 6px; min-height: 36px; margin-bottom: 0.5rem;">
                    ${availableReminders.map(r => {
                        const isSelected = reminders.includes(r);
                        return `<div onclick="${isSelected ? `unselectReminderInline('${r}')` : `selectReminderInline('${r}')`}" style="
                            display: inline-flex; align-items: center; gap: 0.3rem;
                            padding: 0.25rem 0.6rem; border-radius: 20px; cursor: pointer;
                            font-size: 0.85rem; transition: all 0.15s; user-select: none;
                            ${isSelected 
                                ? 'background: var(--accent); color: #fff; border: 1px solid var(--accent);' 
                                : 'background: #fff; color: #333; border: 1px solid #ddd;'}
                        " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
                            ${r}
                            ${isSelected ? '<span style="margin-left: 0.2rem; font-size: 0.9rem;">‚úï</span>' : ''}
                        </div>`;
                    }).join('')}
                </div>
            `;
            
            console.log('üîµ Chip+textbox rendered');
        }
        
        function selectReminderInline(value) {
            console.log('üü¢ Selecting inline:', value);
            if (!reminders.includes(value)) {
                reminders.push(value);
                renderReminders();
            }
        }
        
        function unselectReminderInline(value) {
            console.log('üî¥ Unselecting inline:', value);
            const index = reminders.indexOf(value);
            if (index > -1) {
                reminders.splice(index, 1);
                renderReminders();
            }
        }

        function removeReminder(i) {
            reminders.splice(i, 1);
            renderReminders();
        }

        async function saveTask(e) {
            e.preventDefault();
            
            const taskId = document.getElementById('editTaskId').value;
            const taskType = document.getElementById('taskType').value;
            const startDateRaw = document.getElementById('taskStartDate').value;
            const startDateValue = euToIso(startDateRaw) || startDateRaw || null;
            
            const taskData = {
                title: document.getElementById('taskTitle').value,
                description: document.getElementById('taskDescription').value || null,
                type: taskType,
                categories: selectedCategories,
                priority_id: document.getElementById('taskPriority').value || null,
                start_date: startDateValue || new Date().toISOString(),
                reminders: reminders,
                success_points: parseInt(document.getElementById('successPoints').value),
                failure_points: parseInt(document.getElementById('failurePoints').value),
                skip_points: parseInt(document.getElementById('skipPoints').value),
                late_points: parseInt(document.getElementById('latePoints').value) || 0,
                status: 'active'
            };
            
            if (taskType === 'single') {
                const deadlineRaw = document.getElementById('taskDeadline').value;
                taskData.deadline = euToIso(deadlineRaw) || deadlineRaw || null;
                // Imposta next_occurrence_date = start_date alla creazione
                taskData.next_occurrence_date = startDateValue;
            } else if (taskType === 'recurring') {
                taskData.recurring_frequency = document.getElementById('recurringFrequency').value;
                taskData.recurring_interval = parseInt(document.getElementById('recurringInterval').value) || 1;
                
                // Imposta next_occurrence_date = start_date alla creazione
                taskData.next_occurrence_date = startDateValue;
                
                if (taskData.recurring_frequency === 'weekly') {
                    taskData.recurring_days_of_week = Array.from(
                        document.querySelectorAll('.week-day:checked')
                    ).map(i => parseInt(i.value));
                } else if (taskData.recurring_frequency === 'monthly') {
                    taskData.recurring_day_of_month = Array.from(
                        document.querySelectorAll('.month-day:checked')
                    ).map(i => parseInt(i.value));
                } else if (taskData.recurring_frequency === 'yearly') {
                    // Usa nuovo formato recurring_dates
                    const datesInput = document.getElementById('recurringDates').value;
                    taskData.recurring_dates = datesInput ? JSON.parse(datesInput) : [];
                    
                    // Mantieni compatibilit√† con vecchio formato (per task esistenti)
                    if (taskData.recurring_dates.length > 0) {
                        const [day, month] = taskData.recurring_dates[0].split('-');
                        taskData.recurring_day_of_year = parseInt(day);
                        taskData.recurring_month = parseInt(month);
                    }
                }
            } else if (taskType === 'simple_recurring') {
                // Ricorrenza semplice
                taskData.repeat_after_days = parseInt(document.getElementById('repeatAfterDays').value) || 7;
                // next_occurrence_date viene impostata alla start_date alla creazione
                taskData.next_occurrence_date = startDateValue;
            } else if (taskType === 'multiple') {
                // Task multiplo: salva le date come array in un campo JSON
                const datesInput = document.getElementById('multipleDatesData').value;
                taskData.multiple_dates = datesInput ? JSON.parse(datesInput) : [];
                
                // La prossima occorrenza √® la PRIMA data della lista (ordinata)
                if (taskData.multiple_dates && taskData.multiple_dates.length > 0) {
                    // Ordina le date
                    const sortedDates = [...taskData.multiple_dates].sort();
                    taskData.next_occurrence_date = sortedDates[0] + 'T00:00:00';
                }
            } else if (taskType === 'workflow') {
                // Workflow: salva gli step
                if (workflowSteps.length < 2) {
                    alert('Un workflow deve avere almeno 2 step');
                    return;
                }
                const taskStartDate = startDateValue || new Date().toISOString();
                
                if (taskId) {
                    // UPDATE: preserva stato degli step gi√† completati/falliti
                    const existingTask = tasks.find(t => t.id === taskId);
                    const existingSteps = existingTask?.workflow_steps || [];
                    
                    workflowSteps.forEach(step => {
                        // Cerca step esistente con stesso id
                        const existing = existingSteps.find(s => s.id === step.id);
                        if (existing && (existing.status === 'completed' || existing.status === 'failed')) {
                            // Preserva stato, date e completed_at
                            step.status = existing.status;
                            step.start_date = existing.start_date;
                            step.completed_at = existing.completed_at;
                        } else if (existing && existing.status === 'active') {
                            step.status = 'active';
                            step.start_date = existing.start_date || taskStartDate;
                            step.completed_at = null;
                        } else {
                            // Step nuovo o locked
                            step.completed_at = step.completed_at || null;
                            if (step.depends_on.length === 0) {
                                step.start_date = step.start_date || taskStartDate;
                                step.status = step.status || 'active';
                            } else {
                                // Controlla se tutte le dipendenze sono completate/fallite
                                const allDepsDone = step.depends_on.every(depId => {
                                    const dep = workflowSteps.find(s => s.id === depId);
                                    return dep && (dep.status === 'completed' || dep.status === 'failed');
                                });
                                if (allDepsDone) {
                                    step.status = step.status === 'locked' ? 'active' : (step.status || 'active');
                                    step.start_date = step.start_date || new Date().toISOString();
                                } else {
                                    step.start_date = null;
                                    step.status = 'locked';
                                }
                            }
                        }
                    });
                    // Ricalcola next_occurrence_date
                    const allDone = workflowSteps.every(s => s.status === 'completed' || s.status === 'failed');
                    taskData.next_occurrence_date = wfCalcNextOccurrence(workflowSteps, allDone);
                } else {
                    // CREAZIONE: inizializza tutti gli step
                    workflowSteps.forEach(step => {
                        step.completed_at = null;
                        if (step.depends_on.length === 0) {
                            step.start_date = taskStartDate;
                            step.status = 'active';
                        } else {
                            step.start_date = null;
                            step.status = 'locked';
                        }
                    });
                    taskData.next_occurrence_date = taskStartDate;
                }
                
                taskData.workflow_steps = workflowSteps;
                taskData.start_date = taskStartDate;
                // Punti workflow (salva in campo JSON dedicato)
                taskData.workflow_points = {
                    step_success: parseInt(document.getElementById('wfStepSuccessPoints').value) || 5,
                    step_failure: parseInt(document.getElementById('wfStepFailurePoints').value) || -3,
                    task_success: parseInt(document.getElementById('wfTaskSuccessPoints').value) || 20,
                    task_failure: parseInt(document.getElementById('wfTaskFailurePoints').value) || -10
                };
                // Azzera i punti standard (non usati per workflow)
                taskData.success_points = 0;
                taskData.failure_points = 0;
                taskData.skip_points = 0;
            }
            
            if (taskId) {
                // UPDATE
                const { data, error } = await sb.from('ts_tasks').update(taskData).eq('id', taskId).select();
                if (error) {
                    console.error('‚ùå UPDATE ERROR:', error);
                    debugLog('‚ùå UPDATE ERROR: ' + JSON.stringify(error));
                    alert('ERRORE SALVATAGGIO:\n' + JSON.stringify(error, null, 2));
                    return;
                }
                // Aggiorna cache locale se Supabase restituisce il row (dipende da RLS SELECT)
                if (data && data[0]) {
                    const index = tasks.findIndex(t => t.id === taskId);
                    if (index !== -1) tasks[index] = data[0];
                }
                // Sincronizza regole promemoria SEMPRE dopo update riuscito
                console.log(`üîµ saveTask UPDATE ‚Üí reminders al momento del save:`, reminders);
                const updateDueDate = taskData.next_occurrence_date || taskData.start_date || null;
                await syncNotificationRules(taskId, taskType, reminders, updateDueDate, taskData.title);
            } else {
                // INSERT
                console.log('üîµ INSERTING task:', taskData);
                debugLog('üîµ INSERTING task type:', taskData.type);

                const { data, error } = await sb.from('ts_tasks').insert([taskData]).select();

                if (error) {
                    console.error('‚ùå INSERT ERROR:', error);
                    debugLog('‚ùå INSERT ERROR: ' + JSON.stringify(error));
                    alert('ERRORE SALVATAGGIO:\n' + JSON.stringify(error, null, 2));
                    return;
                }

                if (data) {
                    console.log('‚úÖ Task inserted:', data[0]);
                    debugLog('‚úÖ Task inserted successfully');
                    tasks.push(data[0]);
                    const insertDueDate = data[0].next_occurrence_date || data[0].start_date || null;
                    await syncNotificationRules(data[0].id, taskType, reminders, insertDueDate, taskData.title);
                } else {
                    console.warn('‚ö†Ô∏è No data returned from insert');
                    debugLog('‚ö†Ô∏è No data returned from insert');
                }
            }
            
            closeTaskModal();
            renderDashboard();
            renderTasks();
            renderManagement();
        }

        async function completeWorkflowStep(taskId, stepId) {
            try {
                const task = tasks.find(t => t.id === taskId);
                if (!task || !task.workflow_steps) return;
                
                const steps = JSON.parse(JSON.stringify(task.workflow_steps));
                const step = steps.find(s => s.id === stepId);
                if (!step || step.status !== 'active') return;
                
                const now = new Date().toISOString();
                const wfPoints = task.workflow_points || { step_success: 5, step_failure: -3, task_success: 20, task_failure: -10 };
                
                // Segna come completato
                step.status = 'completed';
                step.completed_at = now;
                
                // Sblocca step dipendenti (completed O failed contano come "fatto")
                wfUnlockSuccessors(steps, now);
                
                // Controlla se workflow finito (nessuno step locked o active)
                const allDone = steps.every(s => s.status === 'completed' || s.status === 'failed');
                
                // Calcola next_occurrence_date = min(start_date) degli step active
                const nextOccurrence = wfCalcNextOccurrence(steps, allDone);
                
                // Salva history per lo step completato
                await sb.from('ts_history').insert([{
                    task_id: taskId,
                    action: 'completed',
                    points: wfPoints.step_success,
                    timestamp: now
                }]);
                
                // Aggiorna task (NON auto-completa, l'utente decide dal popup)
                const updateData = {
                    workflow_steps: steps,
                    last_completed_date: now,
                    next_occurrence_date: nextOccurrence
                };
                
                await sb.from('ts_tasks').update(updateData).eq('id', taskId);
                
                await loadTasks();
                await loadHistory();
                renderDashboard();
                renderCalendar();
                renderManagement();
                
                showToast(`‚úÖ Step "${step.title}" completato! +${wfPoints.step_success} pt`);
            } catch (error) {
                console.error('Error completing workflow step:', error);
                showToast('‚ùå Errore nel completare lo step');
            }
        }
        
        async function failWorkflowStep(taskId, stepId) {
            try {
                const task = tasks.find(t => t.id === taskId);
                if (!task || !task.workflow_steps) return;
                
                const steps = JSON.parse(JSON.stringify(task.workflow_steps));
                const step = steps.find(s => s.id === stepId);
                if (!step || step.status !== 'active') return;
                
                const now = new Date().toISOString();
                const wfPoints = task.workflow_points || { step_success: 5, step_failure: -3, task_success: 20, task_failure: -10 };
                
                // Segna come fallito (il workflow prosegue)
                step.status = 'failed';
                step.completed_at = now;
                
                // Sblocca successori (failed conta come "fatto")
                wfUnlockSuccessors(steps, now);
                
                // Controlla se workflow finito
                const allDone = steps.every(s => s.status === 'completed' || s.status === 'failed');
                
                const nextOccurrence = wfCalcNextOccurrence(steps, allDone);
                
                // Salva history per step fallito
                await sb.from('ts_history').insert([{
                    task_id: taskId,
                    action: 'failed',
                    points: wfPoints.step_failure,
                    timestamp: now
                }]);
                
                // Salva history per step fallito
                await sb.from('ts_history').insert([{
                    task_id: taskId,
                    action: 'failed',
                    points: wfPoints.step_failure,
                    timestamp: now
                }]);
                
                // Aggiorna task (NON auto-completa, l'utente decide dal popup)
                const updateData = {
                    workflow_steps: steps,
                    last_completed_date: now,
                    next_occurrence_date: nextOccurrence
                };
                
                await sb.from('ts_tasks').update(updateData).eq('id', taskId);
                
                await loadTasks();
                await loadHistory();
                renderDashboard();
                renderCalendar();
                renderManagement();
                
                showToast(`‚ùå Step "${step.title}" fallito (${wfPoints.step_failure} pt)`);
            } catch (error) {
                console.error('Error failing workflow step:', error);
                showToast('‚ùå Errore');
            }
        }
        
        // Funzioni helper per workflow
        function wfUnlockSuccessors(steps, now) {
            steps.forEach(s => {
                if (s.status === 'locked' && s.depends_on.length > 0) {
                    const allDepsDone = s.depends_on.every(depId => {
                        const dep = steps.find(d => d.id === depId);
                        return dep && (dep.status === 'completed' || dep.status === 'failed');
                    });
                    if (allDepsDone) {
                        s.status = 'active';
                        s.start_date = now;
                    }
                }
            });
        }
        
        function wfCalcNextOccurrence(steps, allDone) {
            if (allDone) {
                // Tutti completati/falliti: usa la data massima di completamento
                const completedDates = steps
                    .filter(s => s.completed_at)
                    .map(s => new Date(s.completed_at));
                if (completedDates.length > 0) {
                    return new Date(Math.max(...completedDates)).toISOString();
                }
                return null;
            }
            const activeStartDates = steps
                .filter(s => s.status === 'active' && s.start_date)
                .map(s => new Date(s.start_date));
            if (activeStartDates.length > 0) {
                return new Date(Math.min(...activeStartDates)).toISOString();
            }
            return null;
        }

        // ========================================
        // WORKFLOW POPUP
        // ========================================
        let currentWorkflowPopupId = null;
        
        function openWorkflowPopup(taskId) {
            currentWorkflowPopupId = taskId;
            const task = tasks.find(t => t.id === taskId);
            if (!task || !task.workflow_steps) return;
            
            document.getElementById('wfPopupTitle').textContent = 'üîÄ ' + task.title;
            renderWorkflowPopup(task);
            document.getElementById('workflowPopupModal').classList.add('active');
        }
        
        function closeWorkflowPopup() {
            document.getElementById('workflowPopupModal').classList.remove('active');
            currentWorkflowPopupId = null;
        }
        
        function renderWorkflowPopup(task) {
            const steps = task.workflow_steps || [];
            const wfPts = task.workflow_points || {};
            const completedCount = steps.filter(s => s.status === 'completed').length;
            const failedCount = steps.filter(s => s.status === 'failed').length;
            const doneCount = completedCount + failedCount;
            const total = steps.length;
            const allDone = steps.every(s => s.status === 'completed' || s.status === 'failed');
            const progressPct = total > 0 ? Math.round((doneCount / total) * 100) : 0;
            
            // Calcola livelli per il grafo
            const levels = wfCalcLevels(steps);
            const maxLevel = Math.max(...Object.values(levels), 0);
            
            // Barra progresso
            let html = `
                <div style="margin-bottom: 1.2rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.3rem;">
                        <span style="font-size: 0.85rem; font-weight: 600; color: #333;">${progressPct}% completato</span>
                        <span style="font-size: 0.8rem; color: #666;">${completedCount}‚úì ${failedCount > 0 ? failedCount + '‚úó ' : ''}/ ${total} step</span>
                    </div>
                    <div style="background: #e9ecef; height: 8px; overflow: hidden;">
                        <div style="background: ${failedCount > 0 ? 'linear-gradient(90deg, var(--success), #E74C3C)' : 'var(--success)'}; height: 100%; width: ${progressPct}%; transition: width 0.3s;"></div>
                    </div>
                </div>
            `;
            
            // Grafo SVG
            const nodeW = 140, nodeH = 48, activeNodeH = 74, gapX = 20, gapY = 55;
            const padX = 20, padY = 20;
            
            const levelGroups = {};
            for (let l = 0; l <= maxLevel; l++) {
                levelGroups[l] = steps.filter(s => levels[s.id] === l);
            }
            const maxPerRow = Math.max(...Object.values(levelGroups).map(g => g.length), 1);
            const svgW = Math.max(padX * 2 + maxPerRow * nodeW + (maxPerRow - 1) * gapX, 300);
            
            // Calcola altezza per livello (active hanno nodo pi√π alto)
            const levelHasActive = {};
            for (let l = 0; l <= maxLevel; l++) {
                levelHasActive[l] = levelGroups[l].some(s => s.status === 'active');
            }
            
            // Calcola posizioni Y per livello
            const levelY = {};
            let cumY = padY;
            for (let l = 0; l <= maxLevel; l++) {
                const h = levelHasActive[l] ? activeNodeH : nodeH;
                levelY[l] = cumY + h / 2;
                cumY += h + gapY;
            }
            const svgH = cumY - gapY + padY;
            
            const nodePos = {};
            for (let l = 0; l <= maxLevel; l++) {
                const group = levelGroups[l];
                const totalW = group.length * nodeW + (group.length - 1) * gapX;
                const startX = (svgW - totalW) / 2;
                group.forEach((step, i) => {
                    const h = step.status === 'active' ? activeNodeH : nodeH;
                    nodePos[step.id] = {
                        x: startX + i * (nodeW + gapX) + nodeW / 2,
                        y: levelY[l],
                        h: h
                    };
                });
            }
            
            const statusColors = {
                completed: { fill: '#d1fae5', stroke: '#059669', text: '#065f46' },
                failed:    { fill: '#fecaca', stroke: '#dc2626', text: '#991b1b' },
                active:    { fill: '#dbeafe', stroke: '#2563EB', text: '#1e40af' },
                locked:    { fill: '#f3f4f6', stroke: '#9ca3af', text: '#6b7280' }
            };
            const statusIcon = { completed: '‚úì', failed: '‚úó', active: '‚ñ∂', locked: 'üîí' };
            
            let svg = `<svg width="100%" viewBox="0 0 ${svgW} ${svgH}" style="display: block; max-width: 100%;" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <marker id="wfPopArrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                        <path d="M 0 0 L 10 5 L 0 10 z" fill="#94a3b8"/>
                    </marker>
                    <filter id="wfPopShadow" x="-10%" y="-10%" width="130%" height="140%">
                        <feDropShadow dx="0" dy="2" stdDeviation="3" flood-opacity="0.1"/>
                    </filter>
                </defs>`;
            
            // Frecce
            steps.forEach(step => {
                step.depends_on.forEach(depId => {
                    const from = nodePos[depId];
                    const to = nodePos[step.id];
                    if (!from || !to) return;
                    const x1 = from.x, y1 = from.y + from.h / 2;
                    const x2 = to.x, y2 = to.y - to.h / 2;
                    const midY = (y1 + y2) / 2;
                    const depStep = steps.find(s => s.id === depId);
                    const lineColor = depStep && (depStep.status === 'completed' || depStep.status === 'failed') ? '#059669' : '#94a3b8';
                    svg += `<path d="M ${x1} ${y1} C ${x1} ${midY}, ${x2} ${midY}, ${x2} ${y2}" 
                        fill="none" stroke="${lineColor}" stroke-width="2" marker-end="url(#wfPopArrow)" opacity="0.6"/>`;
                });
            });
            
            // Nodi
            steps.forEach(step => {
                const pos = nodePos[step.id];
                if (!pos) return;
                const c = statusColors[step.status] || statusColors.locked;
                const h = pos.h;
                const x = pos.x - nodeW / 2, y = pos.y - h / 2;
                const icon = statusIcon[step.status] || '?';
                const maxChars = 12;
                const label = step.title.length > maxChars ? step.title.substring(0, maxChars) + '‚Ä¶' : step.title;
                
                // Glow per step attivi
                if (step.status === 'active') {
                    svg += `<rect x="${x - 3}" y="${y - 3}" width="${nodeW + 6}" height="${h + 6}" rx="11" ry="11" 
                        fill="none" stroke="#2563EB" stroke-width="1" opacity="0.3" stroke-dasharray="4,3">
                        <animate attributeName="opacity" values="0.3;0.7;0.3" dur="2s" repeatCount="indefinite"/>
                    </rect>`;
                }
                
                svg += `<g filter="url(#wfPopShadow)">
                    <rect x="${x}" y="${y}" width="${nodeW}" height="${h}" rx="8" ry="8" fill="${c.fill}" stroke="${c.stroke}" stroke-width="2"/>
                </g>`;
                
                // Icona stato
                svg += `<circle cx="${x + 16}" cy="${y + 20}" r="11" fill="${c.stroke}"/>
                    <text x="${x + 16}" y="${y + 21}" text-anchor="middle" dominant-baseline="central" fill="white" font-size="11" font-weight="800">${icon}</text>`;
                
                // Titolo
                svg += `<text x="${x + 34}" y="${y + 16}" dominant-baseline="central" fill="${c.text}" font-size="11" font-weight="700">
                    <title>${step.title}</title>${label}</text>`;
                
                // Data
                let dateText = '';
                if (step.completed_at) {
                    dateText = (step.status === 'failed' ? '‚úó ' : '‚úì ') + fmtDate(step.completed_at);
                } else if (step.start_date) {
                    dateText = 'üìÖ ' + fmtDate(step.start_date);
                }
                if (dateText) {
                    svg += `<text x="${x + 34}" y="${y + 30}" fill="${c.text}" font-size="8" opacity="0.7">${dateText}</text>`;
                }
                
                // Bottoni ‚úì / ‚úó dentro il nodo per step attivi
                if (step.status === 'active') {
                    const bY = y + h - 26;
                    const bW = (nodeW - 16) / 2 - 2;
                    // Bottone OK
                    svg += `<g style="cursor:pointer" onclick="wfPopupCompleteStep('${task.id}', ${step.id})">
                        <rect x="${x + 6}" y="${bY}" width="${bW}" height="20" rx="4" fill="#4CAF50"/>
                        <text x="${x + 6 + bW/2}" y="${bY + 14}" text-anchor="middle" fill="white" font-size="10" font-weight="800">‚úì OK</text>
                    </g>`;
                    // Bottone Fail
                    svg += `<g style="cursor:pointer" onclick="wfPopupFailStep('${task.id}', ${step.id})">
                        <rect x="${x + 6 + bW + 4}" y="${bY}" width="${bW}" height="20" rx="4" fill="#E74C3C"/>
                        <text x="${x + 6 + bW + 4 + bW/2}" y="${bY + 14}" text-anchor="middle" fill="white" font-size="10" font-weight="800">‚úó Fail</text>
                    </g>`;
                }
            });
            
            svg += '</svg>';
            html += `<div style="margin-bottom: 0.5rem; overflow-x: auto;">${svg}</div>`;
            
            // Punti info
            html += `
                <div style="display: flex; gap: 1rem; justify-content: center; margin: 1rem 0; font-size: 0.8rem; color: #666;">
                    <span>Step: <b style="color: var(--success);">+${wfPts.step_success || 0}</b> / <b style="color: var(--danger);">${wfPts.step_failure || 0}</b></span>
                    <span>Task: <b style="color: var(--success);">+${wfPts.task_success || 0}</b> / <b style="color: var(--danger);">${wfPts.task_failure || 0}</b></span>
                </div>
            `;
            
            // Bottoni task in fondo
            html += `
                <div style="display: flex; gap: 0.75rem; margin-top: 1rem; padding-top: 1rem; border-top: 2px solid #e9ecef;">
                    <button onclick="wfPopupCompleteTask('${task.id}')" 
                        style="flex: 1; padding: 0.6rem; background: ${allDone ? '#4CAF50' : '#ccc'}; color: white; border: none; font-size: 0.95rem; font-weight: 700; cursor: ${allDone ? 'pointer' : 'not-allowed'}; opacity: ${allDone ? '1' : '0.6'};"
                        ${allDone ? '' : 'disabled'}>
                        ‚úì Completa Task
                    </button>
                    <button onclick="wfPopupFailTask('${task.id}')" 
                        style="flex: 1; padding: 0.6rem; background: #E74C3C; color: white; border: none; font-size: 0.95rem; font-weight: 700; cursor: pointer;">
                        ‚úó Fallisci Task
                    </button>
                    <button onclick="closeWorkflowPopup()" 
                        style="padding: 0.6rem 1rem; background: #6c757d; color: white; border: none; font-size: 0.95rem; cursor: pointer;">
                        Chiudi
                    </button>
                </div>
            `;
            
            document.getElementById('wfPopupContent').innerHTML = html;
        }
        
        // Calcola i livelli (profondit√†) di ogni step per il layout a grafo
        function wfCalcLevels(steps) {
            const levels = {};
            const computed = new Set();
            
            function getLevel(stepId) {
                if (computed.has(stepId)) return levels[stepId];
                const step = steps.find(s => s.id === stepId);
                if (!step) return 0;
                
                if (step.depends_on.length === 0) {
                    levels[stepId] = 0;
                } else {
                    levels[stepId] = Math.max(...step.depends_on.map(d => getLevel(d))) + 1;
                }
                computed.add(stepId);
                return levels[stepId];
            }
            
            steps.forEach(s => getLevel(s.id));
            return levels;
        }
        
        // Azioni dal popup
        async function wfPopupCompleteStep(taskId, stepId) {
            await completeWorkflowStep(taskId, stepId);
            // Riapri popup aggiornato
            const task = tasks.find(t => t.id === taskId);
            if (task && task.status === 'active') {
                renderWorkflowPopup(task);
            } else {
                closeWorkflowPopup();
            }
        }
        
        async function wfPopupFailStep(taskId, stepId) {
            await failWorkflowStep(taskId, stepId);
            const task = tasks.find(t => t.id === taskId);
            if (task && task.status === 'active') {
                renderWorkflowPopup(task);
            } else {
                closeWorkflowPopup();
            }
        }
        
        async function wfPopupCompleteTask(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;
            const steps = task.workflow_steps || [];
            const allDone = steps.every(s => s.status === 'completed' || s.status === 'failed');
            if (!allDone) {
                showToast('‚ö†Ô∏è Completa prima tutti gli step');
                return;
            }
            
            if (!confirm('Segnare il workflow come completato?')) return;
            
            const wfPts = task.workflow_points || {};
            const now = new Date().toISOString();
            
            await sb.from('ts_history').insert([{
                task_id: taskId,
                action: 'completed',
                points: wfPts.task_success || 0,
                timestamp: now
            }]);
            
            const completedDates = steps.filter(s => s.completed_at).map(s => new Date(s.completed_at));
            const maxDate = completedDates.length > 0 ? new Date(Math.max(...completedDates)).toISOString() : now;
            
            await sb.from('ts_tasks').update({
                status: 'completed',
                last_completed_date: now,
                next_occurrence_date: maxDate
            }).eq('id', taskId);
            
            await loadTasks();
            await loadHistory();
            renderDashboard();
            renderCalendar();
            renderManagement();
            closeWorkflowPopup();
            showToast('üéâ Workflow completato! +' + (wfPts.task_success || 0) + ' pt');
        }
        
        async function wfPopupFailTask(taskId) {
            if (!confirm('Segnare il workflow intero come fallito?')) return;
            
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;
            
            const wfPts = task.workflow_points || {};
            const now = new Date().toISOString();
            
            await sb.from('ts_history').insert([{
                task_id: taskId,
                action: 'failed',
                points: wfPts.task_failure || 0,
                timestamp: now
            }]);
            
            const steps = task.workflow_steps || [];
            const completedDates = steps.filter(s => s.completed_at).map(s => new Date(s.completed_at));
            const maxDate = completedDates.length > 0 ? new Date(Math.max(...completedDates)).toISOString() : now;
            
            await sb.from('ts_tasks').update({
                status: 'completed',
                last_completed_date: now,
                next_occurrence_date: maxDate
            }).eq('id', taskId);
            
            await loadTasks();
            await loadHistory();
            renderDashboard();
            renderCalendar();
            renderManagement();
            closeWorkflowPopup();
            showToast('‚ùå Workflow fallito (' + (wfPts.task_failure || 0) + ' pt)');
        }

        async function completeTask(id) {
            if (!confirm('Segnare task come completato?')) return;
            
            try {
                const task = tasks.find(t => t.id === id);
                if (!task) {
                    showToast('‚ùå Task non trovato');
                    return;
                }
                
                debugLog('‚úÖ Completing task:', task.title, 'type:', task.type);
                
                // Per task singoli, verifica se il completamento √® in ritardo rispetto alla deadline
                let completionPoints = task.success_points;
                let completionAction = 'completed';
                
                if (task.type === 'single' && task.deadline) {
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const deadlineStr = task.deadline.includes('T') ? task.deadline.split('T')[0] : task.deadline;
                    const deadline = new Date(deadlineStr + 'T00:00:00');
                    
                    if (today > deadline) {
                        completionPoints = task.late_points || 0;
                        completionAction = 'completed_late';
                        debugLog('‚è∞ LATE! Using late_points:', completionPoints);
                    }
                }
                
                await sb.from('ts_history').insert([{
                    task_id: id,
                    action: 'completed',
                    points: completionPoints,
                    timestamp: new Date().toISOString()
                }]);
                
                // Determina la data di completamento (next_occurrence_date o start_date)
                const completedDate = task.next_occurrence_date || task.start_date || new Date().toISOString();
                
                if (task.type === 'single') {
                    debugLog('üìÖ Type: SINGLE - marking as terminato');
                    await sb.from('ts_tasks').update({
                        status: 'terminato',
                        last_completed_date: completedDate
                    }).eq('id', id);
                    await deleteNotificationRules(id);
                } else if (task.type === 'simple_recurring') {
                    debugLog('üîÅ Type: SIMPLE_RECURRING - calculating next date');
                    // Calcola la prossima occorrenza dalla next_occurrence_date + repeat_after_days
                    const baseDate = new Date(task.next_occurrence_date || task.start_date);
                    const nextDate = new Date(baseDate);
                    nextDate.setDate(baseDate.getDate() + (task.repeat_after_days || 7));
                    debugLog('üîÅ Next date:', nextDate.toISOString());
                    
                    await sb.from('ts_tasks').update({ 
                        last_completed_date: completedDate,
                        next_occurrence_date: nextDate.toISOString()
                    }).eq('id', id);
                    
                    debugLog('üîÅ Updated simple_recurring task');
                } else if (task.type === 'recurring') {
                    debugLog('‚ôæÔ∏è Type: RECURRING - calculating next date');
                    // Calcola la prossima occorrenza dalla next_occurrence_date (o start_date se non esiste)
                    const baseDate = task.next_occurrence_date ? new Date(task.next_occurrence_date) : new Date(task.start_date);
                    debugLog('üìÖ BaseDate for next calc:', baseDate.toISOString());
                    
                    const nextDate = getNextRecurringDate(task, baseDate);
                    debugLog('üìÖ Calculated nextDate:', nextDate ? nextDate.toISOString() : 'NULL');
                    
                    await sb.from('ts_tasks').update({ 
                        last_completed_date: completedDate,
                        next_occurrence_date: nextDate ? nextDate.toISOString() : null
                    }).eq('id', id);
                    
                    debugLog('‚úÖ Updated recurring task');
                } else if (task.type === 'multiple') {
                    debugLog('üìÖ Type: MULTIPLE - moving to next date');
                    
                    // Assicurati che multiple_dates sia un array
                    let datesArray = task.multiple_dates;
                    if (typeof datesArray === 'string') {
                        datesArray = JSON.parse(datesArray);
                    }
                    
                    // Ordina le date
                    const sortedDates = [...datesArray].sort();
                    
                    debugLog('üîµ sortedDates: ' + JSON.stringify(sortedDates));
                    debugLog('üîµ next_occurrence_date: ' + task.next_occurrence_date);
                    
                    // Trova l'indice della data corrente
                    // IMPORTANTE: Estrarre la data SENZA conversione UTC
                    const currentDateStr = task.next_occurrence_date.split('T')[0]; // Prende solo YYYY-MM-DD
                    const currentIndex = sortedDates.indexOf(currentDateStr);
                    
                    debugLog('üîµ currentDateStr: ' + currentDateStr);
                    debugLog('üîµ currentIndex: ' + currentIndex);
                    debugLog('üîµ array length: ' + sortedDates.length);
                    
                    // Calcola la prossima data
                    let nextOccurrence = null;
                    
                    if (currentIndex !== -1 && currentIndex < sortedDates.length - 1) {
                        // C'√® ancora una data successiva
                        nextOccurrence = sortedDates[currentIndex + 1] + 'T00:00:00';
                        debugLog('‚úÖ Next date found: ' + nextOccurrence);
                    } else {
                        if (currentIndex === -1) {
                            debugLog('‚ùå currentDate NOT FOUND in array!');
                        } else {
                            debugLog('‚ùå Was last date in array');
                        }
                    }
                    // Se nextOccurrence √® null, era l'ultima data
                    
                    await sb.from('ts_tasks').update({
                        last_completed_date: completedDate,
                        next_occurrence_date: nextOccurrence,
                        status: nextOccurrence === null ? 'terminato' : 'active'
                    }).eq('id', id);

                    debugLog('‚úÖ Updated multiple task, next: ' + nextOccurrence);
                } else {
                    // free_repeat
                    await sb.from('ts_tasks').update({ last_completed_date: completedDate }).eq('id', id);
                }
                
                await loadTasks();
                await loadHistory();
                
                // Refresh della vista corrente
                renderDashboard();
                renderCalendar();
                renderManagement();
                
                showToast(completionAction === 'completed_late' ? '‚è∞ Task completato in ritardo!' : '‚úÖ Task completato!');
            } catch (error) {
                console.error('Error completing task:', error);
                showToast('‚ùå Errore nel completare il task');
            }
        }

        async function failTask(id) {
            if (!confirm('Segnare task come fallito?')) return;
            
            const task = tasks.find(t => t.id === id);
            
            await sb.from('ts_history').insert([{
                task_id: id,
                action: 'failed',
                points: task.failure_points,
                timestamp: new Date().toISOString()
            }]);
            
            // Determina la data di completamento
            const failedDate = task.next_occurrence_date || task.start_date || new Date().toISOString();
            
            // Task singoli: chiudi il task
            if (task.type === 'single') {
                await sb.from('ts_tasks').update({
                    status: 'terminato',
                    last_completed_date: failedDate
                }).eq('id', id);
                await deleteNotificationRules(id);

                await loadTasks();
                
            // Per ricorrenza semplice, sposta alla prossima occorrenza
            } else if (task.type === 'simple_recurring') {
                const baseDate = new Date(task.next_occurrence_date || task.start_date);
                const nextDate = new Date(baseDate);
                nextDate.setDate(baseDate.getDate() + (task.repeat_after_days || 7));
                
                await sb.from('ts_tasks').update({ 
                    next_occurrence_date: nextDate.toISOString()
                }).eq('id', id);
                
                await loadTasks();
                
            // Per ricorrenti avanzati, calcola prossima occorrenza
            } else if (task.type === 'recurring') {
                const baseDate = task.next_occurrence_date ? new Date(task.next_occurrence_date) : new Date(task.start_date);
                const nextDate = getNextRecurringDate(task, baseDate);
                
                // Se non c'√® prossima occorrenza, chiudi il task
                if (!nextDate) {
                    await sb.from('ts_tasks').update({
                        next_occurrence_date: null,
                        status: 'completed'
                    }).eq('id', id);
                    await deleteNotificationRules(id);
                } else {
                    await sb.from('ts_tasks').update({ 
                        next_occurrence_date: nextDate.toISOString()
                    }).eq('id', id);
                }
                
                await loadTasks();
                
            // Per task multipli, passa alla prossima data
            } else if (task.type === 'multiple') {
                // Assicurati che multiple_dates sia un array
                let datesArray = task.multiple_dates;
                if (typeof datesArray === 'string') {
                    datesArray = JSON.parse(datesArray);
                }
                
                // Ordina le date
                const sortedDates = [...datesArray].sort();
                
                // Trova l'indice della data corrente
                // IMPORTANTE: Estrarre la data SENZA conversione UTC
                const currentDateStr = task.next_occurrence_date.split('T')[0];
                const currentIndex = sortedDates.indexOf(currentDateStr);
                
                // Calcola la prossima data
                let nextOccurrence = null;
                
                if (currentIndex !== -1 && currentIndex < sortedDates.length - 1) {
                    // C'√® ancora una data successiva
                    nextOccurrence = sortedDates[currentIndex + 1] + 'T00:00:00';
                }
                // Se nextOccurrence √® null, era l'ultima data
                
                await sb.from('ts_tasks').update({
                    next_occurrence_date: nextOccurrence,
                    status: nextOccurrence === null ? 'terminato' : 'active'
                }).eq('id', id);
                if (nextOccurrence === null) await deleteNotificationRules(id);

                await loadTasks();
            }

            await loadHistory();

            showToast('‚úó Task fallito');
            
            // Refresh della vista corrente
            renderDashboard();
            renderCalendar();
            renderManagement();
        }
        
        async function skipTask(id) {
            const task = tasks.find(t => t.id === id);
            
            let newDate;
            let skipMessage;
            
            // Per task ricorrenti (recurring e simple_recurring), salta automaticamente alla prossima occorrenza
            if (task.type === 'simple_recurring') {
                // Chiedi conferma
                if (!confirm('Saltare questo task alla prossima occorrenza?')) return;
                
                // Per ricorrenza semplice, calcola dalla next_occurrence_date + repeat_after_days
                const baseDate = new Date(task.next_occurrence_date || task.start_date);
                newDate = new Date(baseDate);
                newDate.setDate(baseDate.getDate() + (task.repeat_after_days || 7));
                skipMessage = 'Task saltato alla prossima occorrenza';
                
            } else if (task.type === 'recurring') {
                // Chiedi conferma
                if (!confirm('Saltare questo task alla prossima occorrenza?')) return;
                
                // Per ricorrenti avanzati, usa la funzione di calcolo della prossima data
                const baseDate = task.next_occurrence_date ? new Date(task.next_occurrence_date) : new Date(task.start_date);
                newDate = getNextRecurringDate(task, baseDate);
                
                if (!newDate) {
                    showToast('‚ùå Impossibile calcolare la prossima occorrenza');
                    return;
                }
                skipMessage = 'Task saltato alla prossima occorrenza';
                
            } else if (task.type === 'multiple') {
                // Per task multipli, passa alla prossima data nella lista
                if (!confirm('Saltare questo task alla prossima data?')) return;
                
                // Assicurati che multiple_dates sia un array
                let datesArray = task.multiple_dates;
                if (typeof datesArray === 'string') {
                    datesArray = JSON.parse(datesArray);
                }
                
                // Ordina le date
                const sortedDates = [...datesArray].sort();
                
                // Trova l'indice della data corrente
                // IMPORTANTE: Estrarre la data SENZA conversione UTC
                const currentDateStr = task.next_occurrence_date.split('T')[0];
                const currentIndex = sortedDates.indexOf(currentDateStr);
                
                // Calcola la prossima data
                if (currentIndex !== -1 && currentIndex < sortedDates.length - 1) {
                    // C'√® ancora una data successiva
                    newDate = new Date(sortedDates[currentIndex + 1] + 'T00:00:00');
                    skipMessage = 'Task saltato alla prossima data';
                } else {
                    // Era l'ultima data, chiudi il task
                    await sb.from('ts_history').insert([{
                        task_id: id,
                        action: 'skipped',
                        points: task.skip_points,
                        timestamp: new Date().toISOString()
                    }]);
                    
                    await sb.from('ts_tasks').update({
                        next_occurrence_date: null,
                        status: 'completed'
                    }).eq('id', id);
                    await deleteNotificationRules(id);

                    await loadTasks();
                    await loadHistory();
                    renderDashboard();
                    renderCalendar();
                    renderManagement();

                    showToast('‚úÖ Ultima data saltata, task completato');
                    return;
                }
                
            } else {
                // Per task singoli, chiedi quanti giorni
                const defaultDays = settings['default_skip_days'] || '1';
                const daysInput = prompt('Di quanti giorni vuoi spostare il task in avanti?', defaultDays);
                
                // Se annulla, esci
                if (daysInput === null) return;
                
                const days = parseInt(daysInput);
                
                // Valida input
                if (isNaN(days) || days < 1) {
                    alert('Inserisci un numero valido di giorni (minimo 1)');
                    return;
                }
                
                // Calcola nuova data: dalla next_occurrence_date + giorni inseriti
                const baseDate = new Date(task.next_occurrence_date || task.start_date);
                newDate = new Date(baseDate);
                newDate.setDate(baseDate.getDate() + days);
                
                const dayLabel = days === 1 ? 'giorno' : 'giorni';
                skipMessage = `Task spostato di ${days} ${dayLabel}`;
            }
            
            // Registra skip nella history
            await sb.from('ts_history').insert([{
                task_id: id,
                action: 'skipped',
                points: task.skip_points,
                timestamp: new Date().toISOString()
            }]);
            
            // Aggiorna in base al tipo di task
            if (task.type === 'single') {
                // Per task singoli, aggiorna next_occurrence_date
                await sb.from('ts_tasks').update({ 
                    next_occurrence_date: newDate.toISOString()
                }).eq('id', id);
                
            } else if (task.type === 'simple_recurring' || task.type === 'recurring') {
                // Per ricorrenti, aggiorna next_occurrence_date
                await sb.from('ts_tasks').update({ 
                    next_occurrence_date: newDate.toISOString()
                }).eq('id', id);
                
            } else if (task.type === 'multiple') {
                // Per task multipli, aggiorna solo next_occurrence_date
                await sb.from('ts_tasks').update({ 
                    next_occurrence_date: newDate.toISOString()
                }).eq('id', id);
            }
            
            await loadTasks();
            await loadHistory();
            
            showToast(`‚è≠ ${skipMessage}`);
            
            // Refresh della vista corrente
            renderDashboard();
            renderCalendar();
            renderManagement();
        }

        async function deleteTask(id) {
            if (!confirm('Eliminare questo task?')) return;

            await deleteNotificationRules(id);
            await sb.from('ts_tasks').delete().eq('id', id);
            tasks = tasks.filter(t => t.id !== id);
            renderTasks();
            renderDashboard();
            renderManagement();
        }

        async function reactivateTask(id) {
            if (!confirm('Riattivare questo task?')) return;
            
            const { data, error } = await sb.from('ts_tasks')
                .update({ status: 'active' })
                .eq('id', id)
                .select();
            
            if (data) {
                const index = tasks.findIndex(t => t.id === id);
                if (index !== -1) tasks[index] = data[0];
                renderTasks();
                renderDashboard();
                renderManagement();
            }
        }

        // SETTINGS MANAGEMENT
        function applyFontScale() {
            const scale = parseInt(settings['dashboard_font_scale'] || '100') / 100;
            document.documentElement.style.setProperty('--dash-title-size', (1.05 * scale) + 'rem');
            document.documentElement.style.setProperty('--dash-meta-size', (0.82 * scale) + 'rem');
            document.documentElement.style.setProperty('--dash-title-size-mobile', (0.88 * scale) + 'rem');
            document.documentElement.style.setProperty('--dash-meta-size-mobile', (0.72 * scale) + 'rem');
            document.documentElement.style.setProperty('--mgmt-title-size', (1.1 * scale) + 'rem');
            document.documentElement.style.setProperty('--mgmt-meta-size', (0.9 * scale) + 'rem');
        }
        
        function applyFontScalePreview(val) {
            const scale = parseInt(val) / 100;
            const titleSize = (1.05 * scale) + 'rem';
            const metaSize = (0.82 * scale) + 'rem';
            const previewTitle = document.getElementById('fontPreviewTitle');
            const previewMeta = document.getElementById('fontPreviewMeta');
            if (previewTitle) previewTitle.style.fontSize = titleSize;
            if (previewMeta) previewMeta.style.fontSize = metaSize;
        }
        
        async function renderSettings() {
            // Carica i valori correnti
            const upcomingDays = parseInt(settings['dashboard_upcoming_days'] || '10');
            document.getElementById('settingUpcomingDays').value = upcomingDays;
            
            const fontScale = parseInt(settings['dashboard_font_scale'] || '100');
            document.getElementById('settingFontScale').value = fontScale;
            document.getElementById('fontScaleLabel').textContent = fontScale + '%';
            applyFontScalePreview(fontScale);
            
            // Renderizza lista priorit√†
            renderPrioritiesList();
            
            // Aggiorna stato notifiche
            updateNotificationStatus();
        }
        
        // ========================================
        // APPUNTI
        // ========================================
        
        async function loadNotes() {
            console.log('üîµ loadNotes() called');
            try {
                const { data, error } = await sb.from('ts_notes').select('*').order('date', { ascending: false });
                console.log('üîµ Notes query result:', { data, error });
                
                if (error) {
                    console.error('‚ùå Error loading notes:', error);
                    alert('Errore caricamento appunti: ' + error.message);
                    return;
                }
                
                if (data) {
                    notes = data;
                    console.log('‚úÖ Loaded notes:', notes.length, notes);
                } else {
                    notes = [];
                    console.log('‚ö†Ô∏è No notes data returned');
                }
            } catch (err) {
                console.error('‚ùå Exception in loadNotes:', err);
                alert('Errore: ' + err.message);
            }
        }
        
        function renderNotes(containerElement = document) {
            console.log('üîµ renderNotes() called, notes:', notes.length);
            
            const listEl = containerElement.querySelector('#notesList');
            console.log('üîµ notesList element:', listEl);
            
            if (!listEl) {
                console.error('‚ùå Element notesList not found!');
                return;
            }
            
            if (!notes || notes.length === 0) {
                console.log('‚ö†Ô∏è No notes to display');
                listEl.innerHTML = '<div class="card" style="background: white; border-radius: 0; padding: 1.0rem; text-align: center;"><p style="opacity: 0.7;">Nessun appunto. Clicca su "Nuovo Appunto" per iniziare.</p></div>';
                return;
            }
            
            const html = notes.map(note => {
                const date = note.date ? new Date(note.date) : null;
                const dateStr = date ? formatDateTime(date) : 'Nessuna data';
                const content = note.content || '';
                const preview = content.length > 150 ? content.substring(0, 150) + '...' : content;
                
                return `
                    <div class="card" style="background: white; border-radius: 0; padding: 0.75rem; margin-bottom: 1rem; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
                        <!-- Note Content -->
                        <div onclick="viewNote('${note.id}')" style="cursor: pointer; margin-bottom: 1.5rem;">
                            <div style="display: flex; align-items: flex-start; gap: 0.8rem;">
                                <span style="font-size: 1.3rem; color: #666; min-width: 30px;">üìù</span>
                                <div style="flex: 1;">
                                    <h3 style="margin: 0; font-size: 1.1rem; color: #333; font-weight: 600; line-height: 1.4;">${note.title}</h3>
                                    <p style="opacity: 0.6; margin: 0.5rem 0 0 0; font-size: 0.85rem;">üìÖ ${dateStr}</p>
                                    ${preview ? `<p style="opacity: 0.7; margin: 0.8rem 0 0 0; font-size: 0.9rem; line-height: 1.5;">${preview}</p>` : ''}
                                </div>
                            </div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div style="display: flex; gap: 0.8rem; justify-content: flex-start; align-items: center;">
                            <button onclick="viewNote('${note.id}')" style="
                                background: var(--accent);
                                color: white;
                                border: none;
                                padding: 0.25rem 0.6rem;
                                border-radius: 0;
                                font-size: 0.9rem;
                                font-weight: 600;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                white-space: nowrap;
                            " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
                                Vedi
                            </button>
                            <button onclick="editNote('${note.id}')" style="
                                background: var(--primary);
                                color: white;
                                border: none;
                                padding: 0.25rem 0.6rem;
                                border-radius: 0;
                                font-size: 0.9rem;
                                font-weight: 600;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                white-space: nowrap;
                            " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
                                Modifica
                            </button>
                            <button onclick="convertNoteToTask('${note.id}')" style="
                                background: var(--success);
                                color: white;
                                border: none;
                                padding: 0.25rem 0.6rem;
                                border-radius: 0;
                                font-size: 0.9rem;
                                font-weight: 600;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                white-space: nowrap;
                            " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'" title="Converti in Task">
                                Task
                            </button>
                            <button onclick="deleteNote('${note.id}')" style="
                                background: var(--danger);
                                color: white;
                                border: none;
                                padding: 0.25rem 0.6rem;
                                border-radius: 0;
                                font-size: 0.9rem;
                                font-weight: 600;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                white-space: nowrap;
                            " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
                                Elimina
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
            
            console.log('‚úÖ Generated HTML length:', html.length);
            listEl.innerHTML = html;
            console.log('‚úÖ renderNotes completed');
        }
        
        function showAddNoteModal() {
            document.getElementById('noteModalTitle').textContent = 'Nuovo Appunto';
            document.getElementById('editNoteId').value = '';
            document.getElementById('noteForm').reset();
            
            // Imposta data/ora corrente
            fpNoteDate.setDate(new Date(), false);

            document.getElementById('noteModal').classList.add('active');
        }
        
        function editNote(id) {
            const note = notes.find(n => n.id === id);
            if (!note) return;
            
            document.getElementById('noteModalTitle').textContent = 'Modifica Appunto';
            document.getElementById('editNoteId').value = id;
            document.getElementById('noteTitle').value = note.title;
            if (note.date) fpNoteDate.setDate(note.date, false); else fpNoteDate.clear();
            document.getElementById('noteContent').value = note.content || '';
            
            document.getElementById('noteModal').classList.add('active');
        }
        
        function viewNote(id) {
            const note = notes.find(n => n.id === id);
            if (!note) return;
            
            const date = note.date ? new Date(note.date) : null;
            const dateStr = date ? formatDateTime(date) : 'Nessuna data';
            
            const content = `
                <div class="card">
                    <h2 style="margin-bottom: 1rem;">${note.title}</h2>
                    <p style="opacity: 0.7; font-size: 0.9rem; margin-bottom: 1.5rem;">üìÖ ${dateStr}</p>
                    ${note.content ? `<div style="white-space: pre-wrap; line-height: 1.6;">${note.content}</div>` : '<p style="opacity: 0.5;">Nessun contenuto</p>'}
                </div>
                <div style="display: flex; gap: 1rem; margin-top: 1.5rem;">
                    <button class="btn btn-primary" onclick="editNote('${note.id}'); closeViewNoteModal();">Modifica</button>
                    <button class="btn btn-danger" onclick="deleteNote('${note.id}'); closeViewNoteModal();">Elimina</button>
                    <button class="btn btn-secondary" onclick="closeViewNoteModal()">Chiudi</button>
                </div>
            `;
            
            // Riuso viewTaskModal per mostrare la nota
            document.querySelector('#viewTaskModal .modal-title').textContent = 'Dettaglio Appunto';
            document.getElementById('viewTaskContent').innerHTML = content;
            document.getElementById('viewTaskModal').classList.add('active');
        }
        
        function closeViewNoteModal() {
            document.getElementById('viewTaskModal').classList.remove('active');
        }
        
        async function saveNote(e) {
            e.preventDefault();
            
            const noteId = document.getElementById('editNoteId').value;
            const noteDateRaw = document.getElementById('noteDate').value;
            const noteData = {
                title: document.getElementById('noteTitle').value,
                date: euToIso(noteDateRaw) || noteDateRaw || null,
                content: document.getElementById('noteContent').value || null
            };
            
            if (noteId) {
                // UPDATE
                const { data, error } = await sb.from('ts_notes').update(noteData).eq('id', noteId).select();
                if (data) {
                    const index = notes.findIndex(n => n.id === noteId);
                    if (index !== -1) notes[index] = data[0];
                }
            } else {
                // INSERT
                const { data, error } = await sb.from('ts_notes').insert([noteData]).select();
                if (data) {
                    notes.unshift(data[0]);
                }
            }
            
            closeNoteModal();
            renderNotes();
        }
        
        async function deleteNote(id) {
            if (!confirm('Eliminare questo appunto?')) return;
            
            await sb.from('ts_notes').delete().eq('id', id);
            notes = notes.filter(n => n.id !== id);
            renderNotes();
        }
        
        function convertNoteToTask(noteId) {
            const note = notes.find(n => n.id === noteId);
            if (!note) {
                alert('Appunto non trovato');
                return;
            }
            
            // Apri il modal di creazione task
            showCreateTaskModal();
            
            // Pre-compila i campi con i dati dell'appunto
            document.getElementById('taskTitle').value = note.title;
            
            // Se c'√® una data, impostala come start_date
            if (note.date) {
                fpStart.setDate(new Date(note.date), false);
            }
            
            // Se c'√® contenuto, mettilo nella descrizione
            if (note.content) {
                document.getElementById('taskDescription').value = note.content;
            }
            
            // Trova la categoria "Appunti" se esiste
            const appuntiCategory = categories.find(c => 
                c.name.toLowerCase().includes('appunt') || 
                c.name.toLowerCase().includes('note')
            );
            
            if (appuntiCategory) {
                selectedCategories = [appuntiCategory.id];
                renderCategoriesSelect();
            }
            
            // Mostra toast
            showToast('üìù Appunto caricato nel form task!');
            
            // Opzionale: chiedi se vuoi eliminare l'appunto dopo la conversione
            setTimeout(() => {
                if (confirm('Vuoi eliminare l\'appunto originale dopo averlo convertito?')) {
                    deleteNote(noteId);
                }
            }, 500);
        }
        
        function closeNoteModal() {
            document.getElementById('noteModal').classList.remove('active');
        }

        // ========================================
        // QUICK NOTE (Appunto veloce dal bottone +)
        // ========================================
        
        function showQuickNoteModal() {
            document.getElementById('quickNoteForm').reset();
            
            // Imposta data/ora corrente
            fpQuickNoteDate.setDate(new Date(), false);
            
            document.getElementById('quickNoteModal').classList.add('active');
            
            // Focus sul campo nome dopo un attimo (per mobile)
            setTimeout(() => {
                document.getElementById('quickNoteName').focus();
            }, 100);
        }
        
        async function saveQuickNote(e) {
            e.preventDefault();
            
            const quickDateRaw = document.getElementById('quickNoteDate').value;
            const noteData = {
                title: document.getElementById('quickNoteName').value,
                date: euToIso(quickDateRaw) || quickDateRaw || null,
                content: null // Appunto veloce non ha contenuto
            };
            
            // INSERT
            const { data, error } = await sb.from('ts_notes').insert([noteData]).select();
            if (data) {
                notes.unshift(data[0]);
            }
            
            closeQuickNoteModal();
            
            // Se siamo nella pagina appunti, aggiorna la lista
            if (!document.getElementById('notesPage').classList.contains('hidden')) {
                renderNotes();
            }
            
            // Feedback visivo
            showToast('‚úì Appunto salvato!');
        }
        
        function closeQuickNoteModal() {
            document.getElementById('quickNoteModal').classList.remove('active');
        }
        
        function showToast(message) {
            // Crea toast temporaneo
            const toast = document.createElement('div');
            toast.textContent = message;
            toast.style.cssText = `
                position: fixed;
                bottom: 2rem;
                left: 50%;
                transform: translateX(-50%);
                background: var(--success);
                color: var(--dark);
                padding: 0.5rem 1.0rem;
                border-radius: 0;
                font-weight: 600;
                z-index: 10000;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                animation: slideUp 0.3s ease;
            `;
            
            document.body.appendChild(toast);
            
            // Rimuovi dopo 2 secondi
            setTimeout(() => {
                toast.style.animation = 'slideDown 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }, 2000);
        }

        // ========================================
        // SISTEMA NOTIFICHE BROWSER
        // ========================================
        
        let notificationPermission = 'default';
        let notificationCheckInterval = null;
        
        /*
         * NOTIFICHE BROWSER
         * 
         * COMPATIBILIT√Ä:
         * ‚úÖ Firefox: Funziona perfettamente
         * ‚ö†Ô∏è Chrome: Richiede HTTPS o localhost
         *    - Su file:// non funziona
         *    - Su http:// non funziona  
         *    - Serve https:// oppure http://localhost
         * 
         * SOLUZIONE PER CHROME:
         * - Hostare su Netlify (https automatico)
         * - Oppure usare server locale con HTTPS
         * - Oppure testare su http://localhost
         */
        async function initNotificationSystem() {
            console.log('üîî ===== NOTIFICATION SYSTEM INIT =====');
            console.log('üîî Initializing notification system...');
            console.log('üîî Window has Notification:', 'Notification' in window);
            console.log('üîî Current URL protocol:', window.location.protocol);
            
            // Controlla permesso corrente
            if ('Notification' in window) {
                notificationPermission = Notification.permission;
                console.log('üîî Current notification permission:', notificationPermission);
                
                // Avviso se su Chrome senza HTTPS
                if (window.location.protocol === 'file:' && navigator.userAgent.includes('Chrome')) {
                    console.warn('‚ö†Ô∏è Chrome richiede HTTPS per le notifiche. Usa Firefox o hosta su HTTPS.');
                }
                
                // Se non √® stato mai chiesto, mostra banner
                if (notificationPermission === 'default') {
                    console.log('üîî Permission is default, showing banner...');
                    showNotificationPermissionBanner();
                } else if (notificationPermission === 'granted') {
                    console.log('üîî Permission granted, starting checks...');
                    startNotificationChecks();
                } else if (notificationPermission === 'denied') {
                    console.log('‚ö†Ô∏è Permission denied by user');
                }
            } else {
                console.warn('‚ö†Ô∏è Browser does not support notifications');
            }
            
            console.log('üîî ===== NOTIFICATION SYSTEM INIT COMPLETE =====');
        }
        
        function showNotificationPermissionBanner() {
            console.log('üîî Showing notification permission banner');
            // Crea banner per richiedere permesso
            const banner = document.createElement('div');
            banner.id = 'notificationBanner';
            banner.style.cssText = `
                position: fixed;
                top: 1rem;
                left: 50%;
                transform: translateX(-50%);
                z-index: 9999;
                background: linear-gradient(135deg, var(--accent), var(--primary));
                color: white;
                padding: 0.5rem 0.75rem;
                border-radius: 0;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                display: flex;
                align-items: center;
                gap: 1rem;
                max-width: 90%;
                animation: slideDown 0.4s ease;
            `;
            
            banner.innerHTML = `
                <span style="font-size: 1.5rem;">üîî</span>
                <div style="flex: 1;">
                    <strong style="display: block; margin-bottom: 0.3rem;">Attiva le Notifiche</strong>
                    <small style="opacity: 0.9;">Ricevi promemoria per i tuoi task</small>
                </div>
                <button onclick="requestNotificationPermission()" class="btn btn-success btn-small">Attiva</button>
                <button onclick="closeNotificationBanner()" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 0.25rem; cursor: pointer; border-radius: 0;">‚úï</button>
            `;
            
            document.body.appendChild(banner);
        }
        
        function closeNotificationBanner() {
            const banner = document.getElementById('notificationBanner');
            if (banner) {
                banner.style.animation = 'slideUp 0.3s ease';
                setTimeout(() => banner.remove(), 300);
            }
        }
        
        async function requestNotificationPermission() {
            if (!('Notification' in window)) {
                alert('Il tuo browser non supporta le notifiche');
                return;
            }
            
            const permission = await Notification.requestPermission();
            notificationPermission = permission;
            
            closeNotificationBanner();
            
            if (permission === 'granted') {
                showToast('‚úÖ Notifiche attivate!');
                
                // Mostra notifica di test
                new Notification('Task Manager v6', {
                    body: 'Notifiche attivate con successo! üéâ',
                    icon: 'üìù',
                    badge: 'üîî'
                });
                
                // Avvia controlli periodici
                startNotificationChecks();
                
                // Aggiorna UI con un piccolo delay per dare tempo al DOM
                setTimeout(() => {
                    updateNotificationStatus();
                }, 100);
            } else if (permission === 'denied') {
                alert('Notifiche bloccate. Puoi attivarle dalle impostazioni del browser.');
                setTimeout(() => {
                    updateNotificationStatus();
                }, 100);
            }
        }
        
        function startNotificationChecks() {
            console.log('üîî Starting notification checks (every minute)');
            
            // Check immediato
            checkAndNotifyReminders();
            
            // Check ogni minuto
            if (notificationCheckInterval) {
                clearInterval(notificationCheckInterval);
            }
            
            notificationCheckInterval = setInterval(() => {
                checkAndNotifyReminders();
            }, 60000); // Ogni 60 secondi
        }
        
        /* FUNZIONE NON USATA - COMMENTATA v16.0
        function stopNotificationChecks() {
            if (notificationCheckInterval) {
                clearInterval(notificationCheckInterval);
                notificationCheckInterval = null;
                console.log('üîî Notification checks stopped');
            }
        }
        */
        
        function checkAndNotifyReminders() {
            console.log('üîî ===== CHECK REMINDERS START =====');
            console.log('üîî Notification permission:', notificationPermission);
            
            if (notificationPermission !== 'granted') {
                console.log('‚ö†Ô∏è Notifications not granted, skipping check');
                return;
            }
            
            const now = new Date();
            console.log('üîî Checking reminders at', now.toLocaleString('it-IT'));
            console.log('üîî Total tasks:', tasks.length);
            
            const tasksWithReminders = tasks.filter(t => t.status === 'active' && t.reminders && t.reminders.length > 0);
            console.log('üîî Tasks with reminders:', tasksWithReminders.length);
            
            // Controlla tutti i task attivi con promemoria
            tasksWithReminders.forEach(task => {
                console.log('üìã Checking task:', task.title, '| Type:', task.type, '| Reminders:', task.reminders);
                
                // Determina la data target del task
                let targetDate = null;
                
                if (task.type === 'single') {
                    targetDate = new Date(task.start_date);
                    console.log('  ‚Üí Single task, target:', targetDate);
                } else if (task.type === 'recurring' || task.type === 'simple_recurring') {
                    if (task.next_occurrence_date) {
                        targetDate = new Date(task.next_occurrence_date);
                        console.log('  ‚Üí Recurring task, next occurrence:', targetDate);
                    } else {
                        console.log('  ‚Üí No next_occurrence_date');
                    }
                } else if (task.type === 'multiple') {
                    if (task.next_occurrence_date) {
                        targetDate = new Date(task.next_occurrence_date);
                        console.log('  ‚Üí Multiple task, next occurrence:', targetDate);
                    } else {
                        console.log('  ‚Üí No next_occurrence_date');
                    }
                }
                
                if (!targetDate) {
                    console.log('  ‚ùå No target date, skipping');
                    return;
                }
                
                // Controlla ogni promemoria
                task.reminders.forEach(reminder => {
                    console.log('  üîî Checking reminder:', reminder);
                    const reminderTime = calculateReminderTime(targetDate, reminder);
                    console.log('    ‚Üí Reminder time:', reminderTime);
                    console.log('    ‚Üí Current time:', now);
                    if (reminderTime) {
                        const diff = now - reminderTime;
                        console.log('    ‚Üí Time diff (ms):', diff, '| Within 30s:', Math.abs(diff) < 30000);
                    }
                    
                    const shouldNotify = shouldTriggerReminder(now, targetDate, reminder, task.id);
                    console.log('    ‚Üí Should notify:', shouldNotify);
                    
                    if (shouldNotify) {
                        console.log('    ‚úÖ SENDING NOTIFICATION');
                        sendNotification(task, reminder, targetDate);
                    }
                });
            });
            
            console.log('üîî ===== CHECK REMINDERS END =====');
            
            // Aggiorna badge / ricarica coda se siamo nella pagina
            if (!document.getElementById('remindersPage').classList.contains('hidden') && currentRemindersView === 'notifiche') {
                loadQueueItems();
            } else {
                loadQueueBadge();
            }
        }
        
        function updateRemindersCount() {
            const now = new Date();
            const twentyFourHoursAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
            let count = 0;
            
            tasks.filter(t => t.status === 'active' && t.reminders && t.reminders.length > 0).forEach(task => {
                let targetDate = null;
                
                if (task.type === 'single') {
                    targetDate = new Date(task.start_date);
                } else if (task.type === 'recurring' || task.type === 'simple_recurring') {
                    if (task.next_occurrence_date) {
                        targetDate = new Date(task.next_occurrence_date);
                    }
                } else if (task.type === 'multiple') {
                    if (task.next_occurrence_date) {
                        targetDate = new Date(task.next_occurrence_date);
                    }
                }
                
                if (!targetDate) return;
                
                task.reminders.forEach(reminder => {
                    const reminderTime = calculateReminderTime(targetDate, reminder);
                    if (reminderTime && reminderTime >= twentyFourHoursAgo && reminderTime <= now) {
                        count++;
                    }
                });
            });
            
            updateRemindersBadge(count);
        }
        
        function shouldTriggerReminder(now, targetDate, reminder, taskId) {
            // Calcola quando dovrebbe scattare il promemoria
            const reminderTime = calculateReminderTime(targetDate, reminder);
            if (!reminderTime) return false;
            
            // Il promemoria deve scattare quando:
            // - reminderTime √® nel passato o presente (now >= reminderTime)
            // - ma NON troppo nel passato (max 2 minuti fa)
            const timeDiff = now - reminderTime; // Positivo se reminderTime √® passato
            
            // Se √® nel futuro, non notificare ancora
            if (timeDiff < 0) {
                console.log('    ‚Üí Reminder is in the future, not yet time');
                return false;
            }
            
            // Se √® troppo vecchio (pi√π di 2 minuti fa), non notificare
            if (timeDiff > 120000) { // 2 minuti
                console.log('    ‚Üí Reminder is too old (>2 minutes)');
                return false;
            }
            
            // Evita notifiche duplicate usando localStorage
            const notificationKey = `notified_${taskId}_${reminder}_${targetDate.toISOString()}`;
            if (localStorage.getItem(notificationKey)) {
                console.log('    ‚Üí Already notified for this reminder');
                return false; // Gi√† notificato
            }
            
            // Segna come notificato
            localStorage.setItem(notificationKey, 'true');
            
            // Pulisci notifiche vecchie (pi√π di 7 giorni)
            cleanOldNotificationFlags();
            
            return true;
        }
        
        function calculateReminderTime(targetDate, reminder) {
            // Rimuovi "prima" se presente e trimma
            let reminderLower = reminder.toLowerCase().replace('prima', '').trim();
            const target = new Date(targetDate);
            
            console.log('  ‚Üí Parsing reminder:', reminder, '‚Üí', reminderLower);
            
            if (reminderLower.includes('ora') || reminderLower.includes('ore') || reminderLower.includes('hour')) {
                const hours = parseInt(reminderLower) || 1;
                const result = new Date(target.getTime() - hours * 60 * 60 * 1000);
                console.log('  ‚Üí Calculated as hours:', hours, '‚Üí Result:', result);
                return result;
            } else if (reminderLower.includes('giorno') || reminderLower.includes('giorni') || reminderLower.includes('day')) {
                const days = parseInt(reminderLower) || 1;
                const result = new Date(target.getTime() - days * 24 * 60 * 60 * 1000);
                console.log('  ‚Üí Calculated as days:', days, '‚Üí Result:', result);
                return result;
            } else if (reminderLower.includes('settimana') || reminderLower.includes('settimane') || reminderLower.includes('week')) {
                const weeks = parseInt(reminderLower) || 1;
                const result = new Date(target.getTime() - weeks * 7 * 24 * 60 * 60 * 1000);
                console.log('  ‚Üí Calculated as weeks:', weeks, '‚Üí Result:', result);
                return result;
            } else if (reminderLower.includes('minuto') || reminderLower.includes('minuti') || reminderLower.includes('minute')) {
                const minutes = parseInt(reminderLower) || 15;
                const result = new Date(target.getTime() - minutes * 60 * 1000);
                console.log('  ‚Üí Calculated as minutes:', minutes, '‚Üí Result:', result);
                return result;
            }
            
            console.log('  ‚Üí Could not parse reminder format');
            return null;
        }
        
        function sendNotification(task, reminder, targetDate) {
            console.log('üîî Sending notification for:', task.title);
            
            const notification = new Notification(`üîî Promemoria: ${task.title}`, {
                body: `${reminder}\nScadenza: ${formatDateTime(targetDate)}`,
                icon: 'üìù',
                badge: 'üîî',
                tag: task.id, // Evita duplicati
                requireInteraction: false,
                vibrate: [200, 100, 200]
            });
            
            // Click sulla notifica apre il task
            notification.onclick = function() {
                window.focus();
                viewTask(task.id);
                notification.close();
            };
        }
        
        function cleanOldNotificationFlags() {
            const sevenDaysAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;
            
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('notified_')) {
                    // Estrai la data dall'ultimo segmento del key
                    const parts = key.split('_');
                    const dateStr = parts[parts.length - 1];
                    try {
                        const date = new Date(dateStr);
                        if (date.getTime() < sevenDaysAgo) {
                            localStorage.removeItem(key);
                        }
                    } catch (e) {
                        // Ignora errori di parsing
                    }
                }
            }
        }
        
        function manageNotifications() {
            if (!('Notification' in window)) {
                alert('Il tuo browser non supporta le notifiche browser. Prova con Chrome, Firefox o Edge.');
                return;
            }
            
            const permission = Notification.permission;
            
            if (permission === 'default') {
                // Non ancora richiesto, chiedi ora
                requestNotificationPermission();
            } else if (permission === 'denied') {
                // Bloccato, mostra istruzioni
                alert(`Le notifiche sono bloccate.

Per attivarle:
1. Click sull'icona üîí nella barra indirizzi
2. Cerca "Notifiche" o "Notifications"
3. Cambia da "Blocca" a "Consenti"
4. Ricarica la pagina`);
            } else if (permission === 'granted') {
                // Gi√† attive, mostra opzioni
                const disable = confirm('Notifiche attive.\n\nVuoi disattivarle? (Dovrai farlo dalle impostazioni del browser)');
                if (disable) {
                    alert(`Per disattivare le notifiche:
1. Click sull'icona üîí nella barra indirizzi
2. Cerca "Notifiche" o "Notifications"
3. Cambia da "Consenti" a "Blocca"
4. Ricarica la pagina`);
                } else {
                    // Mostra notifica di test
                    new Notification('Test Notifica', {
                        body: 'Le notifiche funzionano correttamente! ‚úÖ',
                        icon: 'üìù',
                        badge: 'üîî'
                    });
                }
            }
            
            updateNotificationStatus();
        }
        
        function updateNotificationStatus() {
            console.log('üîî updateNotificationStatus called');
            const statusEl = document.getElementById('notificationStatus');
            const buttonEl = document.getElementById('notificationButton');
            
            console.log('üîî statusEl:', statusEl);
            console.log('üîî buttonEl:', buttonEl);
            
            if (!statusEl || !buttonEl) {
                console.warn('‚ö†Ô∏è Status or button element not found, retrying in 200ms...');
                // Riprova dopo un breve delay se gli elementi non esistono ancora
                setTimeout(() => {
                    const retryStatusEl = document.getElementById('notificationStatus');
                    const retryButtonEl = document.getElementById('notificationButton');
                    if (retryStatusEl && retryButtonEl) {
                        console.log('‚úÖ Elements found on retry');
                        updateNotificationStatusInternal(retryStatusEl, retryButtonEl);
                    } else {
                        console.error('‚ùå Elements still not found after retry');
                    }
                }, 200);
                return;
            }
            
            updateNotificationStatusInternal(statusEl, buttonEl);
        }
        
        function updateNotificationStatusInternal(statusEl, buttonEl) {
            const permission = ('Notification' in window) ? Notification.permission : 'unsupported';
            console.log('üîî Current permission:', permission);
            
            if (permission === 'granted') {
                console.log('üîî Setting status to GRANTED');
                statusEl.innerHTML = '<span style="background: var(--success); color: var(--dark); padding: 0.2rem 0.4rem; border-radius: 0; font-size: 0.9rem; font-weight: 600;">‚úì Attive</span>';
                buttonEl.textContent = 'Test Notifica';
                buttonEl.className = 'btn btn-success';
            } else if (permission === 'denied') {
                console.log('üîî Setting status to DENIED');
                statusEl.innerHTML = '<span style="background: var(--danger); color: white; padding: 0.2rem 0.4rem; border-radius: 0; font-size: 0.9rem; font-weight: 600;">‚úó Bloccate</span>';
                buttonEl.textContent = 'Vedi Istruzioni';
                buttonEl.className = 'btn btn-danger';
            } else if (permission === 'default') {
                console.log('üîî Setting status to DEFAULT');
                statusEl.innerHTML = '<span style="background: var(--warning); color: var(--dark); padding: 0.2rem 0.4rem; border-radius: 0; font-size: 0.9rem; font-weight: 600;">‚ö† Non Attive</span>';
                buttonEl.textContent = 'Attiva Notifiche';
                buttonEl.className = 'btn btn-accent';
            } else {
                console.log('üîî Setting status to UNSUPPORTED');
                statusEl.innerHTML = '<span style="background: var(--secondary); color: white; padding: 0.2rem 0.4rem; border-radius: 0; font-size: 0.9rem; font-weight: 600;">‚úó Non Supportate</span>';
                buttonEl.textContent = 'Browser Non Supportato';
                buttonEl.className = 'btn btn-secondary';
                buttonEl.disabled = true;
            }
        }

        async function saveSettings() {
            const upcomingDays = parseInt(document.getElementById('settingUpcomingDays').value);
            const fontScale = parseInt(document.getElementById('settingFontScale').value);
            
            if (upcomingDays < 1 || upcomingDays > 90) {
                alert('Il numero di giorni per "Prossimi alla scadenza" deve essere tra 1 e 90');
                return;
            }
            
            try {
                // Salva dashboard_upcoming_days
                const { data: existing1 } = await sb.from('ts_settings')
                    .select('id')
                    .eq('key', 'dashboard_upcoming_days')
                    .maybeSingle();
                
                if (existing1) {
                    await sb.from('ts_settings')
                        .update({ 
                            value: upcomingDays.toString(), 
                            updated_at: new Date().toISOString() 
                        })
                        .eq('key', 'dashboard_upcoming_days');
                } else {
                    const newId = crypto.randomUUID();
                    await sb.from('ts_settings').insert([{
                        id: newId,
                        key: 'dashboard_upcoming_days',
                        value: upcomingDays.toString()
                    }]);
                }
                
                // Salva dashboard_font_scale
                const { data: existing2 } = await sb.from('ts_settings')
                    .select('id')
                    .eq('key', 'dashboard_font_scale')
                    .maybeSingle();
                
                if (existing2) {
                    await sb.from('ts_settings')
                        .update({ 
                            value: fontScale.toString(), 
                            updated_at: new Date().toISOString() 
                        })
                        .eq('key', 'dashboard_font_scale');
                } else {
                    const newId = crypto.randomUUID();
                    await sb.from('ts_settings').insert([{
                        id: newId,
                        key: 'dashboard_font_scale',
                        value: fontScale.toString()
                    }]);
                }
                
                await loadSettings();
                applyFontScale();
                renderDashboard();
                showToast('‚úÖ Impostazioni salvate');
            } catch (error) {
                console.error('Error saving settings:', error);
                alert('Errore nel salvare le impostazioni');
            }
        }
        // CATEGORY MANAGEMENT
        async function toggleDashboardVisibility(categoryId, show) {
            console.log('Toggling dashboard visibility for category:', categoryId, 'to:', show);
            
            try {
                const { data, error } = await sb.from('cm_categories')
                    .update({ show_in_dashboard: show })
                    .eq('id', categoryId)
                    .select();
                
                if (error) {
                    console.error('Error updating category:', error);
                    alert('Errore nell\'aggiornamento: ' + error.message);
                } else if (data) {
                    const index = categories.findIndex(c => c.id === categoryId);
                    if (index !== -1) categories[index] = data[0];
                    console.log('Category updated successfully');
                    renderDashboard(); // Aggiorna la dashboard
                }
            } catch (e) {
                console.error('Exception updating category:', e);
                alert('Errore: ' + e.message);
            }
        }

        function editCategory(id) {
            const cat = categories.find(c => c.id === id);
            if (!cat) return;
            
            const newName = prompt('Nuovo nome categoria:', cat.name);
            if (!newName) return;
            
            const newColor = prompt('Nuovo colore (es: #FF3366):', cat.color);
            if (!newColor) return;
            
            const newIcon = prompt('Nuova icona emoji:', cat.icon);
            if (!newIcon) return;
            
            updateCategory(id, newName, newColor, newIcon);
        }

        async function updateCategory(id, name, color, icon) {
            const { data, error } = await sb.from('cm_categories')
                .update({ name, color, icon })
                .eq('id', id)
                .select();
            
            if (data) {
                const index = categories.findIndex(c => c.id === id);
                if (index !== -1) categories[index] = data[0];
                renderCategories();
                renderTasks();
                renderDashboard();
            }
        }

        async function deleteCategory(id) {
            const cat = categories.find(c => c.id === id);
            const taskCount = tasks.filter(t => t.categories?.includes(id)).length;
            
            if (taskCount > 0) {
                alert('Impossibile eliminare: ci sono ancora task associati a questa categoria');
                return;
            }
            
            if (!confirm(`Eliminare la categoria "${cat.name}"?`)) return;
            
            await sb.from('cm_categories').delete().eq('id', id);
            categories = categories.filter(c => c.id !== id);
            renderCategories();
        }

        function viewCategoryTasks(categoryId) {
            const cat = categories.find(c => c.id === categoryId);
            if (!cat) return;
            
            const categoryTasks = tasks.filter(t => 
                t.categories?.includes(categoryId) && t.status === 'active'
            );
            
            let html = `
                <div class="task-detail">
                    <div class="task-detail-row">
                        <span class="task-detail-label">Categoria:</span>
                        <span>${cat.icon} ${cat.name}</span>
                    </div>
                    <div class="task-detail-row">
                        <span class="task-detail-label">Colore:</span>
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <div style="width: 30px; height: 30px; background: ${cat.color}; border-radius: 0;"></div>
                            <span>${cat.color}</span>
                        </div>
                    </div>
                    <div class="task-detail-row">
                        <span class="task-detail-label">Task totali:</span>
                        <span>${categoryTasks.length}</span>
                    </div>
                </div>
                
                <h3 style="margin-top: 2rem; margin-bottom: 1rem; color: var(--accent);">Task associati:</h3>
            `;
            
            if (categoryTasks.length === 0) {
                html += '<p style="opacity: 0.7;">Nessun task in questa categoria</p>';
            } else {
                html += categoryTasks.map(task => {
                    const typeLabel = task.type === 'single' ? 'üìÖ Singolo' : '‚ôæÔ∏è ' + getRecurringLabel(task);
                    return `
                        <div class="card" style="cursor: pointer;" onclick="closeViewCategoryModal(); viewTask('${task.id}')">
                            <h3>${task.title}</h3>
                            <p style="opacity: 0.7; margin-top: 0.3rem;">${typeLabel}</p>
                            ${task.description ? `<p style="margin-top: 0.5rem; font-size: 0.9rem;">${task.description}</p>` : ''}
                        </div>
                    `;
                }).join('');
            }
            
            document.getElementById('viewCategoryContent').innerHTML = html;
            document.getElementById('viewCategoryModal').classList.add('active');
        }

        function closeViewCategoryModal() {
            document.getElementById('viewCategoryModal').classList.remove('active');
        }

        function showCategoriesPopup(categoriesList) {
            const content = document.getElementById('categoriesPopupContent');
            content.innerHTML = categoriesList.map(cat => `
                <div style="
                    display: flex;
                    align-items: center;
                    gap: 1rem;
                    padding: 0.5rem;
                    background: ${cat.color}15;
                    border: 2px solid ${cat.color};
                    border-radius: 0;
                ">
                    <span style="font-size: 1.5rem;">${cat.icon}</span>
                    <span style="font-weight: 600; color: ${cat.color}; font-size: 1.1rem;">${cat.name}</span>
                </div>
            `).join('');
            document.getElementById('categoriesPopupModal').classList.add('active');
        }

        function closeCategoriesPopup() {
            document.getElementById('categoriesPopupModal').classList.remove('active');
        }

        // ===== PLANNER / CALENDAR FUNCTIONS =====
        let currentPlannerView = 'dashboard';
        let currentManagementView = 'tasks';
        // Stato filtri per la pagina Gestione/Tasks
        let mgmtFilterState = {
            search: '',
            category: '',
            priority: '',
            status: 'active',
            groupBy: 'none',
            groupsExpanded: false,
            vistaPanelOpen: false,
            searchPanelOpen: false
        };
        let currentRemindersView = 'notifiche';
        let snoozingItemId = null;
        let currentPlannerDate = new Date();

        function switchPlannerView(view) {
            currentPlannerView = view;
            
            // Aggiorna i bottoni
            document.getElementById('btnDashboardView').className = view === 'dashboard' ? 'btn btn-primary' : 'btn btn-secondary';
            document.getElementById('btnWeekView').className = view === 'week' ? 'btn btn-primary' : 'btn btn-secondary';
            document.getElementById('btnMonthView').className = view === 'month' ? 'btn btn-primary' : 'btn btn-secondary';
            
            renderCalendar();
        }

        function switchManagementView(view) {
            currentManagementView = view;
            
            // Aggiorna i bottoni
            document.getElementById('btnTasksView').className = view === 'tasks' ? 'btn btn-primary' : 'btn btn-secondary';
            document.getElementById('btnCategoriesView').className = view === 'categories' ? 'btn btn-primary' : 'btn btn-secondary';
            document.getElementById('btnNotesView').className = view === 'notes' ? 'btn btn-primary' : 'btn btn-secondary';
            
            renderManagement();
        }

        function switchRemindersView(view) {
            currentRemindersView = view;
            document.getElementById('btnNotificheView').className       = view === 'notifiche' ? 'btn btn-primary' : 'btn btn-secondary';
            document.getElementById('btnHistoryRemindersView').className = view === 'history'   ? 'btn btn-primary' : 'btn btn-secondary';
            renderRemindersContainer();
        }

        function renderRemindersContainer() {
            if (currentRemindersView === 'notifiche') {
                loadQueueItems();
            } else if (currentRemindersView === 'history') {
                renderHistoryPage();
            }
        }

        // ‚îÄ‚îÄ Queue functions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        async function loadQueueItems() {
            const container = document.getElementById('remindersContainer');
            if (!container) return;

            const userId = decodeJWT(sbAccessToken)?.sub;
            if (!userId) {
                container.innerHTML = '<div class="card" style="color:var(--danger)">‚ùå Utente non autenticato</div>';
                return;
            }

            container.innerHTML = '<div style="text-align:center;padding:2rem;opacity:0.6;">‚è≥ Caricamento...</div>';

            const authSb = getAuthSb();
            const { data: items, error } = await authSb
                .from('cm_notification_queue')
                .select('*')
                .eq('user_id', userId)
                .order('fire_at', { ascending: false })
                .limit(100);

            if (error) {
                container.innerHTML = `<div class="card" style="color:var(--danger)">‚ùå Errore: ${error.message}</div>`;
                return;
            }

            const pendingCount = (items ?? []).filter(i => i.status === 'pending' || i.status === 'sending').length;
            updateRemindersBadge(pendingCount);

            if (!items || items.length === 0) {
                container.innerHTML = `
                    <div class="card" style="text-align:center;padding:2rem;">
                        <div style="font-size:3rem;margin-bottom:1rem;">üîî</div>
                        <h3>Nessuna notifica in coda</h3>
                    </div>`;
                return;
            }

            container.innerHTML = items.map(item => renderQueueItem(item)).join('');
        }

        function renderQueueItem(item) {
            const cfg = {
                pending:   { color: 'var(--warning)',   icon: '‚è≥', label: 'In attesa' },
                sending:   { color: 'var(--accent)',    icon: 'üì§', label: 'In invio'  },
                sent:      { color: 'var(--success)',   icon: '‚úÖ', label: 'Inviata'   },
                failed:    { color: 'var(--danger)',    icon: '‚ùå', label: 'Fallita'   },
                cancelled: { color: 'var(--muted)',     icon: 'üö´', label: 'Annullata' },
                snoozed:   { color: 'var(--secondary)', icon: 'üí§', label: 'Sospesa'   },
            };
            const s      = cfg[item.status] || { color: 'var(--muted)', icon: '‚ùì', label: item.status };
            const fireAt = new Date(item.fire_at);
            const isPast = fireAt < new Date();
            const fireStr = fireAt.toLocaleString('it-IT', { day:'2-digit', month:'2-digit', year:'numeric', hour:'2-digit', minute:'2-digit' });
            const canSnooze   = item.status === 'pending' || item.status === 'sending' || item.status === 'sent';
            const canCancel   = canSnooze || item.status === 'snoozed';
            const isCancelled = item.status === 'cancelled';

            return `
                <div class="card" style="border-left:4px solid ${s.color};margin-bottom:0.75rem;${isCancelled ? 'opacity:0.72;' : ''}">
                    <div style="display:flex;justify-content:space-between;align-items:start;gap:1rem;">
                        <div style="flex:1;min-width:0;">
                            <div style="display:flex;align-items:center;gap:0.5rem;margin-bottom:0.4rem;flex-wrap:wrap;">
                                <span>${s.icon}</span>
                                <strong style="font-size:1rem;">${item.title}</strong>
                                <span class="queue-status-badge" style="background:${s.color}20;color:${s.color};">${s.label}</span>
                                ${item.send_count > 0 ? `<span class="queue-attempt-badge">${item.send_count}/5 tent.</span>` : ''}
                            </div>
                            <p style="opacity:0.75;margin:0.3rem 0;font-size:0.9rem;">${item.body}</p>
                            <p style="opacity:0.6;font-size:0.82rem;margin:0.3rem 0;">
                                üìÖ ${item.status === 'snoozed' ? 'Si risveglia' : isPast ? 'Scattata' : 'Scatta'}: <strong>${fireStr}</strong>
                                ¬∑ ${isPast && item.status !== 'snoozed' ? getTimeSince(fireAt) + ' fa' : 'tra ' + getTimeUntil(fireAt)}
                            </p>
                            <p style="opacity:0.5;font-size:0.78rem;margin:0.2rem 0;">üì± ${item.channel} ¬∑ ${item.app}</p>
                        </div>
                        ${canCancel ? `
                        <div style="display:flex;flex-direction:column;gap:0.4rem;flex-shrink:0;">
                            ${canSnooze ? `<button class="btn btn-secondary btn-small" onclick="openSnoozeModal('${item.id}')">‚è∏Ô∏è Sospendi</button>` : ''}
                            <button class="btn btn-danger btn-small" onclick="closeQueueItem('${item.id}')">‚úï Chiudi</button>
                        </div>` : ''}
                        ${isCancelled ? `
                        <div style="flex-shrink:0;">
                            <button class="btn btn-danger btn-small" onclick="deleteQueueItem('${item.id}')">üóëÔ∏è Elimina</button>
                        </div>` : ''}
                    </div>
                </div>`;
        }

        async function closeQueueItem(id) {
            if (!confirm('Annullare questa notifica?')) return;
            const userId = decodeJWT(sbAccessToken)?.sub;
            const authSb = getAuthSb();
            const { error } = await authSb
                .from('cm_notification_queue')
                .update({ status: 'cancelled' })
                .eq('id', id)
                .eq('user_id', userId);
            if (error) { showToast('‚ùå Errore: ' + error.message); return; }
            showToast('üö´ Notifica annullata');
            loadQueueItems();
        }

        async function deleteQueueItem(id) {
            if (!confirm('Eliminare definitivamente questa notifica?')) return;
            const userId = decodeJWT(sbAccessToken)?.sub;
            const authSb = getAuthSb();
            const { error } = await authSb
                .from('cm_notification_queue')
                .delete()
                .eq('id', id)
                .eq('user_id', userId)
                .eq('status', 'cancelled');
            if (error) { showToast('‚ùå Errore: ' + error.message); return; }
            showToast('üóëÔ∏è Notifica eliminata');
            loadQueueItems();
        }

        function openSnoozeModal(id) {
            snoozingItemId = id;
            document.getElementById('snoozeCustomMinutes').value = '';
            document.getElementById('snoozeModal').classList.add('active');
        }

        function closeSnoozeModal() {
            snoozingItemId = null;
            document.getElementById('snoozeModal').classList.remove('active');
        }

        async function confirmSnooze(minutes) {
            if (!snoozingItemId) return;
            const userId   = decodeJWT(sbAccessToken)?.sub;
            const authSb   = getAuthSb();
            const newFireAt = new Date(Date.now() + minutes * 60 * 1000).toISOString();
            const { error } = await authSb
                .from('cm_notification_queue')
                .update({ status: 'snoozed', send_count: 0, fire_at: newFireAt })
                .eq('id', snoozingItemId)
                .eq('user_id', userId);
            closeSnoozeModal();
            if (error) { showToast('‚ùå Errore: ' + error.message); return; }
            const label = minutes < 60 ? `${minutes} min` : minutes < 1440 ? `${minutes / 60} ore` : '1 giorno';
            showToast(`‚è∏Ô∏è Sospesa per ${label}`);
            loadQueueItems();
        }

        async function confirmSnoozeCustom() {
            const minutes = parseInt(document.getElementById('snoozeCustomMinutes').value);
            if (!minutes || minutes < 1) { showToast('‚ö†Ô∏è Inserisci un numero valido di minuti'); return; }
            await confirmSnooze(minutes);
        }

        async function loadQueueBadge() {
            const userId = decodeJWT(sbAccessToken)?.sub;
            if (!userId) return;
            const authSb = getAuthSb();
            const { count } = await authSb
                .from('cm_notification_queue')
                .select('id', { count: 'exact', head: true })
                .eq('user_id', userId)
                .in('status', ['pending', 'sending']);
            updateRemindersBadge(count ?? 0);
        }
        
        function renderHistoryPage() {
            const container = document.getElementById('remindersContainer');
            if (!container) return;
            
            // Ordina history per timestamp (pi√π recente prima)
            const sortedHistory = [...history].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            // Raggruppa per data
            const groupedByDate = {};
            sortedHistory.forEach(h => {
                const date = new Date(h.timestamp).toLocaleDateString('it-IT', { 
                    weekday: 'long', 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });
                if (!groupedByDate[date]) {
                    groupedByDate[date] = [];
                }
                groupedByDate[date].push(h);
            });
            
            let html = '';
            
            // Cronologia raggruppata per data
            if (Object.keys(groupedByDate).length === 0) {
                html += `
                    <div class="card" style="text-align: center; padding: 2rem;">
                        <h2 style="font-size: 3rem; margin-bottom: 1rem;">üìã</h2>
                        <h3 style="margin-bottom: 0.5rem;">Nessuna attivit√† registrata</h3>
                        <p style="opacity: 0.7;">Completa, salta o segna come falliti dei task per vedere qui lo storico</p>
                    </div>
                `;
            } else {
                Object.keys(groupedByDate).forEach(date => {
                    const items = groupedByDate[date];
                    
                    html += `
                        <div class="card" style="margin-bottom: 1rem;">
                            <div style="margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 2px solid var(--border);">
                                <h3 style="margin: 0; color: var(--accent);">${date}</h3>
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                                ${items.map(h => {
                                    const task = tasks.find(t => t.id === h.task_id);
                                    const taskTitle = task ? task.title : 'Task eliminato';
                                    const time = new Date(h.timestamp).toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });
                                    
                                    let actionIcon, actionText, actionColor;
                                    if (h.action === 'completed') {
                                        actionIcon = '‚úÖ';
                                        actionText = 'Completato';
                                        actionColor = 'var(--success)';
                                    } else if (h.action === 'failed') {
                                        actionIcon = '‚ùå';
                                        actionText = 'Fallito';
                                        actionColor = 'var(--danger)';
                                    } else if (h.action === 'skipped') {
                                        actionIcon = '‚è≠Ô∏è';
                                        actionText = 'Saltato';
                                        actionColor = 'var(--warning)';
                                    } else {
                                        actionIcon = 'üìù';
                                        actionText = h.action;
                                        actionColor = 'var(--muted)';
                                    }
                                    
                                    return `
                                        <div style="display: flex; align-items: center; gap: 1rem; padding: 0.75rem; background: var(--input-bg); border-left: 3px solid ${actionColor};">
                                            <span style="font-size: 1.5rem;">${actionIcon}</span>
                                            <div style="flex: 1;">
                                                <div style="font-weight: 600; margin-bottom: 0.25rem;">${taskTitle}</div>
                                                <div style="font-size: 0.85rem; opacity: 0.7;">
                                                    ${actionText} ‚Ä¢ ${time}
                                                    ${h.notes ? ` ‚Ä¢ ${h.notes}` : ''}
                                                </div>
                                            </div>
                                            <div style="text-align: right; font-weight: 700; color: ${h.points > 0 ? 'var(--success)' : 'var(--danger)'};">
                                                ${h.points > 0 ? '+' : ''}${h.points}
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                });
            }
            
            container.innerHTML = html;
        }

        function renderManagement() {
            const container = document.getElementById('managementContainer');
            if (!container) return;
            
            if (currentManagementView === 'tasks') {
                // Mostra il contenuto della pagina Tasks
                const tasksContent = document.getElementById('tasksPage').cloneNode(true);
                tasksContent.classList.remove('hidden');
                tasksContent.id = '';
                container.innerHTML = tasksContent.innerHTML;
                
                // Ripristina stato pannelli collapsible
                const vistaPanel = container.querySelector('#vistaPanel');
                const vistaArrow = container.querySelector('#vistaArrow');
                if (vistaPanel) {
                    vistaPanel.style.display = mgmtFilterState.vistaPanelOpen ? 'block' : 'none';
                    if (vistaArrow) vistaArrow.style.transform = mgmtFilterState.vistaPanelOpen ? 'rotate(90deg)' : 'rotate(0deg)';
                    // Rewire click handler per pannello Vista
                    vistaPanel.previousElementSibling.onclick = () => {
                        const open = vistaPanel.style.display !== 'none';
                        vistaPanel.style.display = open ? 'none' : 'block';
                        vistaArrow.style.transform = open ? 'rotate(0deg)' : 'rotate(90deg)';
                        mgmtFilterState.vistaPanelOpen = !open;
                    };
                }
                const searchPanel = container.querySelector('#searchPanel');
                const searchArrow = container.querySelector('#searchArrow');
                if (searchPanel) {
                    searchPanel.style.display = mgmtFilterState.searchPanelOpen ? 'block' : 'none';
                    if (searchArrow) searchArrow.style.transform = mgmtFilterState.searchPanelOpen ? 'rotate(90deg)' : 'rotate(0deg)';
                    // Rewire click handler per pannello Cerca
                    searchPanel.previousElementSibling.onclick = () => {
                        const open = searchPanel.style.display !== 'none';
                        searchPanel.style.display = open ? 'none' : 'block';
                        searchArrow.style.transform = open ? 'rotate(0deg)' : 'rotate(90deg)';
                        mgmtFilterState.searchPanelOpen = !open;
                    };
                }
                
                // IMPORTANTE: cerca gli elementi DENTRO il container, non globalmente!
                const categoryFilter = container.querySelector('#filterCategory');
                if (categoryFilter) {
                    const currentValue = categoryFilter.value;
                    
                    // Calcola il conteggio di task per ogni categoria
                    const categoriesWithCount = categories.map(cat => {
                        const count = tasks.filter(t => 
                            t.categories?.includes(cat.id) && 
                            t.status === 'active'
                        ).length;
                        return { ...cat, taskCount: count };
                    });
                    
                    // Ordina per numero di task (decrescente)
                    categoriesWithCount.sort((a, b) => b.taskCount - a.taskCount);
                    
                    categoryFilter.innerHTML = '<option value="">Tutte le categorie</option>' + 
                        categoriesWithCount.map(cat => 
                            `<option value="${cat.id}">${cat.icon} ${cat.name} (${cat.taskCount})</option>`
                        ).join('');
                    categoryFilter.value = currentValue;
                }
                
                // Popola il filtro priorit√†
                const filterPrioritySelect = container.querySelector('#filterPriority');
                if (filterPrioritySelect) {
                    const currentValue = filterPrioritySelect.value;
                    filterPrioritySelect.innerHTML = '<option value="">Tutte le priorit√†</option>' + 
                        priorities.map(p => `<option value="${p.id}">${p.name}</option>`).join('');
                    filterPrioritySelect.value = currentValue;
                }
                
                // Aggiungi event listeners ai filtri (con salvataggio stato)
                const searchInput = container.querySelector('#filterSearch');
                if (searchInput) {
                    searchInput.value = mgmtFilterState.search;
                    searchInput.addEventListener('input', () => {
                        mgmtFilterState.search = searchInput.value;
                        applyTaskFilters(container);
                    });
                }
                
                if (categoryFilter) {
                    categoryFilter.value = mgmtFilterState.category;
                    categoryFilter.addEventListener('change', () => {
                        mgmtFilterState.category = categoryFilter.value;
                        applyTaskFilters(container);
                    });
                }
                
                if (filterPrioritySelect) {
                    filterPrioritySelect.value = mgmtFilterState.priority;
                    filterPrioritySelect.addEventListener('change', () => {
                        mgmtFilterState.priority = filterPrioritySelect.value;
                        applyTaskFilters(container);
                    });
                }
                
                const statusFilter = container.querySelector('#filterStatus');
                if (statusFilter) {
                    statusFilter.value = mgmtFilterState.status;
                    statusFilter.addEventListener('change', () => {
                        mgmtFilterState.status = statusFilter.value;
                        applyTaskFilters(container);
                    });
                }
                
                // Event listeners per visualizzazione (con salvataggio stato)
                const groupBySelect = container.querySelector('#groupBy');
                if (groupBySelect) {
                    groupBySelect.value = mgmtFilterState.groupBy;
                    groupBySelect.addEventListener('change', () => {
                        mgmtFilterState.groupBy = groupBySelect.value;
                        applyTaskFilters(container);
                    });
                }
                
                const groupsStateToggle = container.querySelector('#groupsStateToggle');
                if (groupsStateToggle) {
                    groupsStateToggle.checked = mgmtFilterState.groupsExpanded;
                    const label = container.querySelector('#expandLabel');
                    if (label) {
                        label.textContent = mgmtFilterState.groupsExpanded ? 'Comprimi tutti' : 'Espandi tutti';
                    }
                    groupsStateToggle.addEventListener('change', () => {
                        mgmtFilterState.groupsExpanded = groupsStateToggle.checked;
                        const lbl = container.querySelector('#expandLabel');
                        if (lbl) {
                            lbl.textContent = groupsStateToggle.checked ? 'Comprimi tutti' : 'Espandi tutti';
                        }
                        applyTaskFilters(container);
                    });
                }
                
                // Handler per il bottone pulisci ricerca nel contesto management
                const clearBtn = container.querySelector('#clearSearchBtn');
                if (clearBtn) {
                    clearBtn.onclick = () => {
                        const si = container.querySelector('#filterSearch');
                        if (si) si.value = '';
                        mgmtFilterState.search = '';
                        applyTaskFilters(container);
                    };
                }
                
                // Riapplica i filtri - PASSA IL CONTAINER!
                applyTaskFilters(container);
            } else if (currentManagementView === 'categories') {
                // Mostra il contenuto della pagina Categories
                const categoriesContent = document.getElementById('categoriesPage').cloneNode(true);
                categoriesContent.classList.remove('hidden');
                categoriesContent.id = '';
                container.innerHTML = categoriesContent.innerHTML;
                renderCategories(container);
            } else if (currentManagementView === 'notes') {
                // Mostra il contenuto della pagina Notes
                const notesContent = document.getElementById('notesPage').cloneNode(true);
                notesContent.classList.remove('hidden');
                notesContent.id = '';
                container.innerHTML = notesContent.innerHTML;
                renderNotes(container);
            }
        }

        /* FUNZIONE NON USATA - COMMENTATA v16.0
        function goToToday() {
            currentPlannerDate = new Date();
            renderCalendar();
        }
        */

        /* FUNZIONE NON USATA - COMMENTATA v16.0
        async function refreshPlannerData() {
            showToast('üîÑ Aggiornamento dati...');
            await loadTasks();
            await loadHistory();
            
            // Log di debug dettagliato
            console.log('=== PLANNER DATA DEBUG ===');
            console.log('Total tasks:', tasks.length);
            console.log('Active tasks:', tasks.filter(t => t.status === 'active').length);
            
            if (tasks.length > 0) {
                const sampleTask = tasks[0];
                console.log('Sample task:', {
                    id: sampleTask.id,
                    title: sampleTask.title,
                    status: sampleTask.status,
                    type: sampleTask.type,
                    start_date: sampleTask.start_date,
                    next_occurrence_date: sampleTask.next_occurrence_date,
                    next_due: sampleTask.next_due,
                    multiple_dates: sampleTask.multiple_dates
                });
            }
            
            console.log('Total history:', history.length);
            if (history.length > 0) {
                const sampleHistory = history[0];
                console.log('Sample history:', {
                    id: sampleHistory.id,
                    task_id: sampleHistory.task_id,
                    completed_at: sampleHistory.completed_at,
                    action: sampleHistory.action
                });
            }
            
            // Test con data di oggi
            const today = new Date();
            const todayStr = today.toISOString().split('T')[0];
            console.log('Testing for today:', todayStr);
            
            // Controlla task con start_date
            const todayTasksByStartDate = tasks.filter(t => {
                if (!t.start_date) return false;
                const taskDate = t.start_date.split('T')[0];
                return taskDate === todayStr;
            });
            console.log('Tasks by start_date for today:', todayTasksByStartDate.length);
            
            // Controlla task con next_occurrence_date
            const todayTasksByNextOcc = tasks.filter(t => {
                if (!t.next_occurrence_date) return false;
                const taskDate = t.next_occurrence_date.split('T')[0];
                return taskDate === todayStr;
            });
            console.log('Tasks by next_occurrence_date for today:', todayTasksByNextOcc.length);
            
            // Mostra tutte le date presenti nei task
            console.log('=== All task dates ===');
            tasks.slice(0, 5).forEach(t => {
                console.log(`Task: ${t.title}`, {
                    type: t.type,
                    start_date: t.start_date,
                    next_occurrence_date: t.next_occurrence_date,
                    next_due: t.next_due
                });
            });
            
            renderCalendar();
            showToast('‚úÖ Dati aggiornati! Controlla console per dettagli');
        }
        */

        function renderCalendar() {
            console.log('Rendering calendar - View:', currentPlannerView);
            console.log('Current date:', currentPlannerDate);
            console.log('Available tasks:', tasks.length);
            console.log('Available history:', history.length);
            
            // Aggiorna info debug
            const debugTasks = document.getElementById('plannerDebugTasks');
            if (debugTasks) debugTasks.textContent = tasks.filter(t => t.status === 'active').length;
            
            // Aggiorna display periodo corrente
            updatePeriodDisplay();
            
            if (currentPlannerView === 'dashboard') {
                renderDashboard(); // Ora usa la funzione unificata
            } else if (currentPlannerView === 'week') {
                renderWeekView();
            } else {
                renderMonthView();
            }
        }

        function updatePeriodDisplay() {
            const monthDisplay = document.getElementById('currentMonthDisplay');
            const navigationBar = document.getElementById('plannerNavigation');
            
            if (!monthDisplay) return;
            
            if (currentPlannerView === 'dashboard') {
                monthDisplay.textContent = 'Dashboard';
                if (navigationBar) navigationBar.style.display = 'none';
            } else {
                if (navigationBar) navigationBar.style.display = 'block';
                
                if (currentPlannerView === 'week') {
                    const startOfWeek = getStartOfWeek(currentPlannerDate);
                    const endOfWeek = new Date(startOfWeek);
                    endOfWeek.setDate(endOfWeek.getDate() + 6);
                    monthDisplay.textContent = `${formatCalendarDate(startOfWeek, 'dd MMM')} - ${formatCalendarDate(endOfWeek, 'dd MMM yyyy')}`;
                } else {
                    const monthName = currentPlannerDate.toLocaleDateString('it-IT', { month: 'long', year: 'numeric' });
                    monthDisplay.textContent = monthName.charAt(0).toUpperCase() + monthName.slice(1);
                }
            }
        }

        function navigatePlanner(delta) {
            if (currentPlannerView === 'week') {
                navigatePlannerWeek(delta);
            } else {
                navigatePlannerMonth(delta);
            }
        }

        function renderDashboard() {
            // QUESTA √à LA FUNZIONE CORRETTA (ex renderDashboardInPlanner)
            // La vecchia renderDashboard con i log √® stata sostituita da questa
            const container = document.getElementById('calendarContainer');
            
            // Chiama la funzione renderDashboard esistente per ottenere l'HTML
            const now = new Date();
            const today = new Date(now);
            today.setHours(0, 0, 0, 0);
            
            const todayEnd = new Date(today);
            todayEnd.setHours(23, 59, 59, 999);
            
            const upcomingDays = parseInt(settings['dashboard_upcoming_days'] || '10');
            const nextNDays = new Date(today);
            nextNDays.setDate(nextNDays.getDate() + upcomingDays);
            
            const activeTasks = tasks.filter(t => t.status === 'active');
            const freeRepeatTasks = activeTasks.filter(t => t.type === 'free_repeat');
            const scheduledTasks = activeTasks.filter(t => t.type !== 'free_repeat');
            
            const overdueTasks = scheduledTasks.filter(t => {
                if (t.type === 'single' && t.start_date) {
                    const startDate = new Date(t.start_date);
                    return startDate < today;
                }
                if ((t.type === 'simple_recurring' || t.type === 'recurring' || t.type === 'multiple' || t.type === 'workflow') && t.next_occurrence_date) {
                    const nextOcc = new Date(t.next_occurrence_date);
                    return nextOcc < today;
                }
                return false;
            }).sort((a, b) => {
                const dateA = new Date(a.next_occurrence_date || a.start_date || 0);
                const dateB = new Date(b.next_occurrence_date || b.start_date || 0);
                return dateA - dateB;
            });
            
            const todayTasks = scheduledTasks.filter(t => isTaskDueToday(t, today)).sort((a, b) => {
                const dateA = new Date(a.next_occurrence_date || a.start_date || 0);
                const dateB = new Date(b.next_occurrence_date || b.start_date || 0);
                return dateA - dateB;
            });
            
            const upcomingTasks = scheduledTasks.filter(t => {
                const tomorrow = new Date(today);
                tomorrow.setDate(tomorrow.getDate() + 1);
                
                if (t.type === 'single' && t.start_date) {
                    const startDate = new Date(t.start_date);
                    startDate.setHours(0, 0, 0, 0);
                    return startDate >= tomorrow && startDate <= nextNDays;
                }
                
                if ((t.type === 'simple_recurring' || t.type === 'recurring' || t.type === 'multiple' || t.type === 'workflow') && t.next_occurrence_date) {
                    const nextOccurrence = new Date(t.next_occurrence_date);
                    nextOccurrence.setHours(0, 0, 0, 0);
                    return nextOccurrence >= tomorrow && nextOccurrence <= nextNDays;
                }
                
                return false;
            }).sort((a, b) => {
                const dateA = new Date(a.next_occurrence_date || a.start_date || 0);
                const dateB = new Date(b.next_occurrence_date || b.start_date || 0);
                return dateA - dateB;
            });
            
            const renderTaskCard = (task, sectionColor, index) => {
                const cats = categories.filter(c => task.categories?.includes(c.id));
                
                let taskIcon = '‚è∞';
                if (task.type === 'recurring' || task.type === 'simple_recurring') {
                    taskIcon = 'üîÅ';
                } else if (task.type === 'multiple') {
                    taskIcon = 'üìÖ';
                } else if (task.type === 'free_repeat') {
                    taskIcon = 'üîÑ';
                } else if (task.type === 'workflow') {
                    taskIcon = 'üîÄ';
                }
                
                let categoriesHtml = '';
                if (cats.length > 0) {
                    categoriesHtml = cats.slice(0, 2).map(c => 
                        `<span class="dash-task-cat-chip" style="background: ${c.color}; color: white; padding: 0.2rem 0.5rem; border-radius: 0; font-size: 0.8rem; font-weight: 600; white-space: nowrap;">${c.icon} ${c.name}</span>`
                    ).join('');
                    if (cats.length > 2) {
                        categoriesHtml += `<span class="dash-task-cat-chip" style="background: #6B7280; color: white; padding: 0.2rem 0.4rem; border-radius: 0; font-size: 0.8rem; font-weight: 600;">+${cats.length - 2}</span>`;
                    }
                }
                
                let dateStr = '';
                if (task.type === 'single' && task.start_date) {
                    dateStr = formatDateTime(task.start_date);
                } else if ((task.type === 'simple_recurring' || task.type === 'recurring') && task.next_occurrence_date) {
                    dateStr = formatDateTime(task.next_occurrence_date);
                } else if (task.next_due) {
                    dateStr = formatDateTime(task.next_due);
                }
                
                let typeLabel = '';
                if (task.type === 'simple_recurring' || task.type === 'recurring') {
                    typeLabel = getDetailedRecurringLabel(task);
                } else if (task.type === 'multiple') {
                    const allDates = (task.multiple_dates || []);
                    const totalDates = allDates.length;
                    const nextOcc = task.next_occurrence_date ? task.next_occurrence_date.split('T')[0] : null;
                    if (nextOcc) {
                        const remainingDates = allDates.filter(d => d >= nextOcc).length;
                        const nextDate = new Date(nextOcc + 'T00:00:00');
                        const monthNames = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];
                        const nextDateStr = `${nextDate.getDate()} ${monthNames[nextDate.getMonth()]}`;
                        typeLabel = `Prossima: ${nextDateStr} ‚Ä¢ ${remainingDates}/${totalDates} date`;
                    } else {
                        typeLabel = `${totalDates} date completate`;
                    }
                } else if (task.type === 'free_repeat') {
                    typeLabel = 'Libera ripetizione';
                } else if (task.type === 'workflow') {
                    const steps = task.workflow_steps || [];
                    const completed = steps.filter(s => s.status === 'completed').length;
                    const failed = steps.filter(s => s.status === 'failed').length;
                    typeLabel = `Progresso: ${completed}‚úì${failed > 0 ? ' ' + failed + '‚úó' : ''} / ${steps.length} step`;
                } else if (task.type === 'single') {
                    typeLabel = 'Singolo';
                }
                
                // Per workflow, rendering compatto - click apre popup
                if (task.type === 'workflow') {
                    const steps = task.workflow_steps || [];
                    const completedSteps = steps.filter(s => s.status === 'completed').length;
                    const failedSteps = steps.filter(s => s.status === 'failed').length;
                    const doneSteps = completedSteps + failedSteps;
                    const totalSteps = steps.length;
                    const progressPct = totalSteps > 0 ? Math.round((doneSteps / totalSteps) * 100) : 0;
                    const activeCount = steps.filter(s => s.status === 'active').length;
                    const progressLabel = failedSteps > 0 
                        ? `${completedSteps}‚úì ${failedSteps}‚úó / ${totalSteps} ‚Ä¢ ${activeCount} da fare` 
                        : `${completedSteps}/${totalSteps} completati ‚Ä¢ ${activeCount} da fare`;
                    
                    return `
                        <div class="card dash-task" style="background: white; border-radius: 0; padding: 0.75rem; margin-bottom: 0.6rem; box-shadow: 0 2px 8px rgba(0,0,0,0.08); cursor: pointer;" onclick="openWorkflowPopup('${task.id}')">
                            <div class="dash-task-body" style="display: flex; align-items: flex-start; gap: 0.8rem;">
                                <span class="dash-task-icon" style="font-size: 1.3rem; color: #666; min-width: 30px;">${taskIcon}</span>
                                <div class="dash-task-info" style="flex: 1;">
                                    <h3 class="dash-task-title" style="margin: 0; font-size: var(--dash-title-size); color: #333; font-weight: 600; line-height: 1.4;">${task.title}</h3>
                                    <div style="margin-top: 0.3rem; background: #e9ecef; height: 6px; overflow: hidden;">
                                        <div style="background: ${failedSteps > 0 ? '#E74C3C' : 'var(--success)'}; height: 100%; width: ${progressPct}%; transition: width 0.3s;"></div>
                                    </div>
                                    <p class="dash-task-meta" style="margin: 0.2rem 0 0 0; font-size: var(--dash-meta-size); color: #666;">${progressLabel}</p>
                                </div>
                            </div>
                            <div class="dash-task-actions" style="display: flex; gap: 0.5rem; justify-content: flex-start; align-items: center; flex-wrap: wrap; margin-top: 0.5rem;">
                                <button class="dash-task-btn" onclick="event.stopPropagation(); openWorkflowPopup('${task.id}')" style="background: #2563EB; color: white; border: none; padding: 0.2rem 0.5rem; border-radius: 0; font-size: 0.85rem; font-weight: 600; cursor: pointer; white-space: nowrap;" onmouseover="this.style.background='#1d4ed8'" onmouseout="this.style.background='#2563EB'">
                                    üîÄ Gestisci
                                </button>
                                ${categoriesHtml ? `<div class="dash-task-cats" style="display: flex; gap: 0.4rem; align-items: center; flex-wrap: wrap; margin-left: auto;">${categoriesHtml}</div>` : ''}
                            </div>
                        </div>
                    `;
                }
                
                return `
                    <div class="card dash-task" style="background: white; border-radius: 0; padding: 0.75rem; margin-bottom: 0.6rem; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
                        
                        <div class="dash-task-body" onclick="viewTask('${task.id}')" style="cursor: pointer; margin-bottom: 0.75rem; display: flex; align-items: flex-start; gap: 0.8rem;">
                            <span class="dash-task-icon" style="font-size: 1.3rem; color: #666; min-width: 30px;">${taskIcon}</span>
                            <div class="dash-task-info" style="flex: 1;">
                                <h3 class="dash-task-title" style="margin: 0; font-size: var(--dash-title-size); color: #333; font-weight: 600; line-height: 1.4;">${task.title}</h3>
                                ${dateStr ? `<p class="dash-task-meta" style="margin: 0.2rem 0 0 0; font-size: var(--dash-meta-size); color: #000;">${dateStr}</p>` : ''}
                                ${typeLabel ? `<p class="dash-task-meta" style="margin: 0.2rem 0 0 0; font-size: var(--dash-meta-size); color: #000;">${typeLabel}</p>` : ''}
                            </div>
                        </div>
                        
                        <div class="dash-task-actions" style="display: flex; gap: 0.5rem; justify-content: flex-start; align-items: center; flex-wrap: wrap;">
                            <button class="dash-task-btn" onclick="event.stopPropagation(); completeTask('${task.id}')" style="background: #4CAF50; color: white; border: none; padding: 0.2rem 0.5rem; border-radius: 0; font-size: 0.85rem; font-weight: 600; cursor: pointer; white-space: nowrap;" onmouseover="this.style.background='#45a049'" onmouseout="this.style.background='#4CAF50'">
                                Completato
                            </button>
                            ${task.type !== 'free_repeat' ? `
                            <button class="dash-task-btn" onclick="event.stopPropagation(); failTask('${task.id}')" style="background: #E74C3C; color: white; border: none; padding: 0.2rem 0.5rem; border-radius: 0; font-size: 0.85rem; font-weight: 600; cursor: pointer; white-space: nowrap;" onmouseover="this.style.background='#c0392b'" onmouseout="this.style.background='#E74C3C'">
                                Fallito
                            </button>
                            ` : ''}
                            ${(task.type === 'recurring' || task.type === 'simple_recurring' || task.type === 'multiple') ? `
                            <button class="dash-task-btn" onclick="event.stopPropagation(); skipTask('${task.id}')" style="background: #F39C12; color: white; border: none; padding: 0.2rem 0.5rem; border-radius: 0; font-size: 0.85rem; font-weight: 600; cursor: pointer; white-space: nowrap;" onmouseover="this.style.background='#e67e22'" onmouseout="this.style.background='#F39C12'">
                                Salta
                            </button>
                            ` : ''}
                            ${categoriesHtml ? `<div class="dash-task-cats" style="display: flex; gap: 0.4rem; align-items: center; flex-wrap: wrap; margin-left: auto;">${categoriesHtml}</div>` : ''}
                        </div>
                    </div>
                `;
            };
            
            let html = '';
            
            const totalScore = history.reduce((sum, h) => sum + (h.points || 0), 0);
            const completedCount = history.filter(h => h.action === 'completed').length;
            const failedCount = history.filter(h => h.action === 'failed').length;
            const skippedCount = history.filter(h => h.action === 'skipped').length;
            
            debugLog('üìä CALENDAR BADGES - Total: ' + totalScore + ' | Completed: ' + completedCount + ' | Failed: ' + failedCount + ' | Skipped: ' + skippedCount + ' | History items: ' + history.length);
            
            html += `
                <div class="dash-badges" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin-bottom: 2rem;">
                    <div class="card dash-badge" style="background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%); color: white; text-align: center; padding: 1rem;">
                        <div class="dash-badge-value" style="font-size: 2.5rem; font-weight: 900; margin-bottom: 0.25rem;">${totalScore}</div>
                        <div class="dash-badge-label" style="font-size: 0.9rem; font-weight: 600; opacity: 0.9;">PUNTEGGIO</div>
                    </div>
                    <div class="card dash-badge" style="background: var(--success)20; color: var(--success); text-align: center; padding: 1rem; border: 2px solid var(--success);">
                        <div class="dash-badge-value" style="font-size: 2.5rem; font-weight: 900; margin-bottom: 0.25rem;">${completedCount}</div>
                        <div class="dash-badge-label" style="font-size: 0.9rem; font-weight: 600;">COMPLETATI</div>
                    </div>
                    <div class="card dash-badge" style="background: var(--danger)20; color: var(--danger); text-align: center; padding: 1rem; border: 2px solid var(--danger);">
                        <div class="dash-badge-value" style="font-size: 2.5rem; font-weight: 900; margin-bottom: 0.25rem;">${failedCount}</div>
                        <div class="dash-badge-label" style="font-size: 0.9rem; font-weight: 600;">FALLITI</div>
                    </div>
                    <div class="card dash-badge" style="background: var(--warning)20; color: var(--warning); text-align: center; padding: 1rem; border: 2px solid var(--warning);">
                        <div class="dash-badge-value" style="font-size: 2.5rem; font-weight: 900; margin-bottom: 0.25rem;">${skippedCount}</div>
                        <div class="dash-badge-label" style="font-size: 0.9rem; font-weight: 600;">SALTATI</div>
                    </div>
                </div>
            `;
            
            html += `<div class="dash-sections-grid">`;
            
            if (overdueTasks.length > 0) {
                html += `
                    <div class="card dash-section" style="border-left: 4px solid var(--danger); margin-bottom: 1.5rem;">
                        <h2 class="dash-section-title" style="color: var(--danger); font-size: 1.4rem; font-weight: 900; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                            ‚ö†Ô∏è SCADUTI (${overdueTasks.length})
                        </h2>
                        <div class="dash-task-grid">
                            ${overdueTasks.map((t, i) => renderTaskCard(t, 'var(--danger)', i)).join('')}
                        </div>
                    </div>
                `;
            }
            
            if (todayTasks.length > 0) {
                html += `
                    <div class="card dash-section" style="border-left: 4px solid var(--primary); margin-bottom: 1.5rem;">
                        <h2 class="dash-section-title" style="color: var(--primary); font-size: 1.4rem; font-weight: 900; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                            üéØ OGGI (${todayTasks.length})
                        </h2>
                        <div class="dash-task-grid">
                            ${todayTasks.map((t, i) => renderTaskCard(t, 'var(--primary)', i)).join('')}
                        </div>
                    </div>
                `;
            }
            
            if (upcomingTasks.length > 0) {
                html += `
                    <div class="card dash-section" style="border-left: 4px solid var(--warning); margin-bottom: 1.5rem;">
                        <h2 class="dash-section-title" style="color: var(--warning); font-size: 1.4rem; font-weight: 900; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                            üìÖ PROSSIMI (${upcomingTasks.length})
                        </h2>
                        <div class="dash-task-grid">
                            ${upcomingTasks.map((t, i) => renderTaskCard(t, 'var(--warning)', i)).join('')}
                        </div>
                    </div>
                `;
            }
            
            if (freeRepeatTasks.length > 0) {
                html += `<div class="card dash-section dash-section--full" style="border-left: 4px solid var(--accent); margin-bottom: 1.5rem;">
                        <h2 class="dash-section-title" style="color: var(--accent); font-size: 1.4rem; font-weight: 900; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                            üîÑ A LIBERA RIPETIZIONE (${freeRepeatTasks.length})
                        </h2>
                `;
                
                const tasksByCategory = {};
                freeRepeatTasks.forEach(task => {
                    const taskCats = task.categories || [];
                    taskCats.forEach(catId => {
                        const cat = categories.find(c => c.id === catId);
                        if (cat && cat.show_in_dashboard) {
                            if (!tasksByCategory[catId]) {
                                tasksByCategory[catId] = [];
                            }
                            tasksByCategory[catId].push(task);
                        }
                    });
                });
                
                let totalTasksToShow = 0;
                Object.values(tasksByCategory).forEach(tasks => {
                    totalTasksToShow += tasks.length;
                });
                
                if (totalTasksToShow === 0) {
                    html += '<p style="opacity: 0.7;">Nessuna categoria configurata per la dashboard. Vai su "Categorie" per attivarle.</p>';
                } else {
                    Object.keys(tasksByCategory).forEach(catId => {
                        const cat = categories.find(c => c.id === catId);
                        const catTasks = tasksByCategory[catId].sort((a, b) => a.title.localeCompare(b.title));
                        const catName = `${cat.icon} ${cat.name}`;
                        const catColor = cat.color;
                        
                        html += `
                            <div class="dash-cat-group" style="margin-bottom: 1.5rem;">
                                <h3 class="dash-cat-title" style="color: ${catColor}; font-size: 1.2rem; font-weight: 700; margin-bottom: 0.75rem;">
                                    ${catName} (${catTasks.length})
                                </h3>
                                <div class="dash-task-grid">
                                    ${catTasks.map((t, i) => renderTaskCard(t, catColor, i)).join('')}
                                </div>
                            </div>
                        `;
                    });
                }
                
                html += `</div>`;
            }
            
            html += `</div>`; // chiude dash-sections-grid
            
            container.innerHTML = html;
        }

        function renderWeekView() {
            const container = document.getElementById('calendarContainer');
            const startOfWeek = getStartOfWeek(currentPlannerDate);
            const endOfWeek = new Date(startOfWeek);
            endOfWeek.setDate(endOfWeek.getDate() + 6);
            
            const weekDays = [];
            for (let i = 0; i < 7; i++) {
                const day = new Date(startOfWeek);
                day.setDate(day.getDate() + i);
                weekDays.push(day);
            }

            // Definisco le fasce orarie: 0-8, 8-14, 14-20, 20-24
            const timeSlots = [
                { start: 0, end: 8, label: '00-08', height: '100px' },
                { start: 8, end: 14, label: '08-14', height: '200px' },
                { start: 14, end: 20, label: '14-20', height: '200px' },
                { start: 20, end: 24, label: '20-24', height: '100px' }
            ];

            let html = `
                <div class="card" style="overflow-x: auto;">
                    <div style="display: flex; gap: 2px; min-width: fit-content;">
            `;

            // Creo una colonna per ogni giorno
            weekDays.forEach(day => {
                const isCurrentDay = isToday(day);
                html += `
                    <div style="flex: 1; min-width: 150px; border: 1px solid var(--border); ${isCurrentDay ? 'background: rgba(255, 51, 102, 0.02);' : ''}">
                        <!-- Header del giorno -->
                        <div style="background: ${isCurrentDay ? 'var(--primary)' : 'var(--dark)'}; color: white; padding: 0.75rem; text-align: center; border-bottom: 2px solid var(--border);">
                            <div style="font-weight: 900; font-size: 0.9rem;">${getDayName(day)}</div>
                            <div style="font-size: 1.5rem; margin-top: 0.25rem;">${day.getDate()}</div>
                        </div>
                        
                        <!-- Fasce orarie -->
                `;
                
                timeSlots.forEach(slot => {
                    const dayTasks = getTasksForTimeSlot(day, slot.start, slot.end);
                    
                    html += `
                        <div style="border-bottom: 1px solid var(--border); padding: 0.5rem; height: ${slot.height}; overflow-y: auto; cursor: pointer; position: relative;"
                             onclick="showDayTasks('${day.toISOString()}')">
                            <!-- Label fascia oraria -->
                            <div style="font-size: 0.7rem; font-weight: 600; opacity: 0.6; margin-bottom: 0.25rem;">${slot.label}</div>
                            
                            <!-- Task della fascia -->
                            <div style="display: flex; flex-direction: column; gap: 0.25rem;">
                                ${dayTasks.length > 0 ? dayTasks.map(task => {
                                    const cat = categories.find(c => task.categories?.includes(c.id));
                                    const bgColor = cat ? cat.color : 'var(--primary)';
                                    return `<div style="background: ${bgColor}; color: white; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.7rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: 600;" title="${task.title}">${task.title}</div>`;
                                }).join('') : '<div style="opacity: 0.2; font-size: 0.7rem; text-align: center; font-style: italic;">Nessun task</div>'}
                            </div>
                        </div>
                    `;
                });
                
                html += `
                    </div>
                `;
            });

            html += `
                    </div>
                </div>
            `;

            container.innerHTML = html;
        }

        function renderMonthView() {
            console.log('Rendering month view...');
            const container = document.getElementById('calendarContainer');
            if (!container) {
                console.error('Calendar container not found!');
                return;
            }
            
            const year = currentPlannerDate.getFullYear();
            const month = currentPlannerDate.getMonth();
            
            console.log('Rendering month:', year, month);
            
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const startDate = getStartOfWeek(firstDay);
            const endDate = new Date(startDate);
            endDate.setDate(endDate.getDate() + 41); // 6 settimane

            const weeks = [];
            let currentWeek = [];
            let currentDate = new Date(startDate);

            while (currentDate <= endDate) {
                currentWeek.push(new Date(currentDate));
                
                if (currentWeek.length === 7) {
                    weeks.push(currentWeek);
                    currentWeek = [];
                }
                
                currentDate.setDate(currentDate.getDate() + 1);
            }

            const monthName = currentPlannerDate.toLocaleDateString('it-IT', { month: 'long', year: 'numeric' });
            const capitalizedMonth = monthName.charAt(0).toUpperCase() + monthName.slice(1);

            let html = `
                <div class="card">
                    <div style="text-align:center; font-size:1.2rem; font-weight:700; margin-bottom:0.75rem; color:var(--dark);">
                        ${capitalizedMonth}
                    </div>
                    <div class="calendar-grid month-view">
                        ${['Lun', 'Mar', 'Mer', 'Gio', 'Ven', 'Sab', 'Dom'].map(day => `
                            <div class="calendar-header-cell">${day}</div>
                        `).join('')}
                        
                        ${weeks.map(week => week.map(day => {
                            const dayTasks = getTasksForDate(day);
                            const isCurrentMonth = day.getMonth() === month;
                            const isCurrentDay = isToday(day);
                            
                            return `
                                <div class="calendar-day-cell ${isCurrentDay ? 'today' : ''} ${!isCurrentMonth ? 'other-month' : ''}"
                                     onclick="handleCalendarCellClick('${day.toISOString()}', event)">
                                    <div class="calendar-day-number">${day.getDate()}</div>
                                    <div class="calendar-tasks-container">
                                        ${dayTasks.slice(0, 2).map(task => {
                                            const cat = categories.find(c => task.categories?.includes(c.id));
                                            const bgColor = cat ? cat.color : 'var(--primary)';
                                            const isCompleted = task.completed_at || task.status === 'completed' || task.status === 'terminato';
                                            return `
                                                <div class="calendar-task-item ${isCompleted ? 'completed' : ''}"
                                                     style="background: ${bgColor};"
                                                     onclick="handleTaskClick('${task.id}', '${day.toISOString()}', event)">
                                                    ${task.title}
                                                </div>
                                            `;
                                        }).join('')}
                                        ${dayTasks.length > 2 ? `
                                            <span class="calendar-task-count">+${dayTasks.length - 2} altri</span>
                                        ` : ''}
                                    </div>
                                </div>
                            `;
                        }).join('')).join('')}
                    </div>
                </div>
            `;

            container.innerHTML = html;
        }

        function getTasksForTimeSlot(date, startHour, endHour) {
            const dateStr = date.getFullYear() + '-' + String(date.getMonth() + 1).padStart(2, '0') + '-' + String(date.getDate()).padStart(2, '0');
            
            // Ottieni tutti i task del giorno
            const dayTasks = tasks.filter(task => {
                if (task.status !== 'active') return false;
                
                // Per task singoli, usa start_date
                if (task.type === 'single' && task.start_date) {
                    return toLocalDateStr(task.start_date) === dateStr;
                }
                
                // Per task ricorrenti, usa next_occurrence_date
                if ((task.type === 'recurring' || task.type === 'simple_recurring') && task.next_occurrence_date) {
                    return toLocalDateStr(task.next_occurrence_date) === dateStr;
                }
                
                // Per task multipli, controlla se la data √® in multiple_dates
                if (task.type === 'multiple' && task.multiple_dates) {
                    try {
                        const dates = JSON.parse(task.multiple_dates);
                        return dates.includes(dateStr);
                    } catch (e) {
                        return false;
                    }
                }
                
                // Fallback su next_due se presente
                if (task.next_due) {
                    return toLocalDateStr(task.next_due) === dateStr;
                }
                
                return false;
            });
            
            // Filtra per fascia oraria
            return dayTasks.filter(task => {
                // Se il task ha un orario specifico, usa quello
                let taskHour = null;
                
                if (task.type === 'single' && task.start_date) {
                    const taskDate = new Date(task.start_date);
                    taskHour = taskDate.getHours();
                } else if ((task.type === 'recurring' || task.type === 'simple_recurring') && task.next_occurrence_date) {
                    const taskDate = new Date(task.next_occurrence_date);
                    taskHour = taskDate.getHours();
                } else if (task.next_due) {
                    const taskDate = new Date(task.next_due);
                    taskHour = taskDate.getHours();
                }
                
                // Se non ha orario specifico o l'orario √® 00:00, mostra nella prima fascia
                if (taskHour === null || taskHour === 0) {
                    return startHour === 0;
                }
                
                // Controlla se rientra nella fascia oraria
                return taskHour >= startHour && taskHour < endHour;
            });
        }

        function getTasksForDate(date) {
            const dateStr = date.getFullYear() + '-' + String(date.getMonth() + 1).padStart(2, '0') + '-' + String(date.getDate()).padStart(2, '0');
            
            console.log('Getting tasks for date:', dateStr);
            console.log('Total tasks:', tasks.length);
            console.log('Total history:', history.length);
            
            // Task attivi - controlla start_date, next_occurrence_date, o next_due
            const activeTasks = tasks.filter(task => {
                if (task.status !== 'active') return false;
                
                // Per task singoli, usa start_date
                if (task.type === 'single' && task.start_date) {
                    return toLocalDateStr(task.start_date) === dateStr;
                }
                
                // Per task ricorrenti, usa next_occurrence_date
                if ((task.type === 'recurring' || task.type === 'simple_recurring') && task.next_occurrence_date) {
                    return toLocalDateStr(task.next_occurrence_date) === dateStr;
                }
                
                // Per task multipli, controlla se la data √® in multiple_dates
                if (task.type === 'multiple' && task.multiple_dates) {
                    try {
                        const dates = JSON.parse(task.multiple_dates);
                        return dates.includes(dateStr);
                    } catch (e) {
                        return false;
                    }
                }
                
                // Fallback su next_due se presente
                if (task.next_due) {
                    return toLocalDateStr(task.next_due) === dateStr;
                }
                
                return false;
            });

            console.log('Active tasks found:', activeTasks.length);
            if (activeTasks.length > 0) {
                console.log('Sample active task:', activeTasks[0]);
            }

            // Task dallo storico per date passate
            const historicalTasks = history.filter(h => {
                if (!h.completed_at) return false;
                return toLocalDateStr(h.completed_at) === dateStr;
            }).map(h => {
                // Trova il task originale
                const task = tasks.find(t => t.id === h.task_id);
                if (!task) {
                    // Se non troviamo il task, creiamo uno placeholder con i dati dello storico
                    return {
                        id: h.task_id,
                        title: h.task_title || 'Task senza titolo',
                        description: '',
                        type: 'single',
                        status: 'completed',
                        completed_at: h.completed_at,
                        categories: []
                    };
                }
                return {
                    ...task,
                    id: h.task_id,
                    completed_at: h.completed_at,
                    status: 'completed'
                };
            });

            console.log('Historical tasks found:', historicalTasks.length);

            const allTasks = [...activeTasks, ...historicalTasks];
            console.log('Total tasks for date:', allTasks.length);
            
            return allTasks;
        }

        function showDayTasks(dateIso) {
            const date = new Date(dateIso);
            const dayTasks = getTasksForDate(date);
            
            if (dayTasks.length === 0) {
                showToast('Nessun task per questo giorno');
                return;
            }

            const dateStr = formatCalendarDate(date, 'dd MMMM yyyy');
            
            let html = `
                <div style="margin-bottom: 1.5rem;">
                    <h3 style="color: var(--accent); font-size: 1.5rem;">üìÖ ${dateStr}</h3>
                    <p style="opacity: 0.7; margin-top: 0.5rem;">${dayTasks.length} task in questo giorno</p>
                </div>
            `;

            // Separa task attivi e completati
            const activeTasks = dayTasks.filter(t => !t.completed_at && t.status === 'active');
            const completedTasks = dayTasks.filter(t => t.completed_at || t.status === 'completed' || t.status === 'terminato');

            if (activeTasks.length > 0) {
                html += '<h4 style="color: var(--primary); margin-bottom: 1rem;">‚úÖ Task Attivi</h4>';
                activeTasks.forEach(task => {
                    html += renderTaskCard(task, false);
                });
            }

            if (completedTasks.length > 0) {
                html += '<h4 style="color: var(--success); margin: 1.5rem 0 1rem 0;">‚úì Task Completati</h4>';
                completedTasks.forEach(task => {
                    html += renderTaskCard(task, true);
                });
            }

            const modal = document.createElement('div');
            modal.className = 'modal active';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 800px;">
                    <div class="modal-header">
                        <h2 class="modal-title">Task del Giorno</h2>
                        <span class="modal-close" onclick="this.closest('.modal').remove()">‚úï</span>
                    </div>
                    <div style="max-height: 70vh; overflow-y: auto;">
                        ${html}
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function handleCalendarCellClick(dateIso, event) {
            // Su mobile, apri sempre il popup dei task del giorno
            if (window.innerWidth <= 768) {
                showDayTasks(dateIso);
            }
            // Su desktop, non fare nulla (lascia che i click sui task funzionino)
        }

        function handleTaskClick(taskId, dateIso, event) {
            event.stopPropagation();
            
            // Su mobile, apri il popup con tutti i task del giorno
            if (window.innerWidth <= 768) {
                showDayTasks(dateIso);
            } else {
                // Su desktop, apri direttamente il dettaglio del task
                viewTask(taskId);
            }
        }

        function renderTaskCard(task, isCompleted) {
            let typeLabel = '';
            if (task.type === 'single') {
                typeLabel = 'üìÖ Singolo';
            } else if (task.type === 'simple_recurring' || task.type === 'recurring') {
                typeLabel = '‚ôæÔ∏è ' + getDetailedRecurringLabel(task);
            } else if (task.type === 'multiple') {
                const allDates = (task.multiple_dates || []);
                const totalDates = allDates.length;
                const nextOcc = task.next_occurrence_date ? task.next_occurrence_date.split('T')[0] : null;
                if (nextOcc) {
                    const remainingDates = allDates.filter(d => d >= nextOcc).length;
                    const nextDate = new Date(nextOcc + 'T00:00:00');
                    const monthNames = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];
                    const nextDateStr = `${nextDate.getDate()} ${monthNames[nextDate.getMonth()]}`;
                    typeLabel = `üìÖ Prossima: ${nextDateStr} ‚Ä¢ ${remainingDates}/${totalDates} date`;
                } else {
                    typeLabel = `üìÖ ${totalDates} date completate`;
                }
            } else if (task.type === 'free_repeat') {
                typeLabel = 'üîÑ Libera ripetizione';
            } else if (task.type === 'workflow') {
                const steps = task.workflow_steps || [];
                const completed = steps.filter(s => s.status === 'completed').length;
                const failed = steps.filter(s => s.status === 'failed').length;
                typeLabel = `üîÄ Workflow ‚Ä¢ ${completed}‚úì${failed > 0 ? ' ' + failed + '‚úó' : ''} / ${steps.length} step`;
            }
            const categoriesList = task.categories?.map(catId => {
                const cat = categories.find(c => c.id === catId);
                return cat ? `<span class="category-pill" style="background: ${cat.color}; color: white;">${cat.icon} ${cat.name}</span>` : '';
            }).join('') || '';

            return `
                <div class="card" style="cursor: pointer; ${isCompleted ? 'opacity: 0.8; border-left: 4px solid var(--success);' : 'border-left: 4px solid var(--primary);'}" 
                     onclick="viewTask('${task.id}')">
                    <div style="display: flex; justify-content: space-between; align-items: start;">
                        <h3 style="margin: 0;">${task.title}</h3>
                        ${isCompleted ? '<span style="color: var(--success); font-size: 1.5rem;">‚úì</span>' : ''}
                    </div>
                    <p style="opacity: 0.7; margin-top: 0.5rem; font-size: 0.9rem;">${typeLabel}</p>
                    ${categoriesList ? `<div class="category-pills" style="margin-top: 0.5rem;">${categoriesList}</div>` : ''}
                    ${task.description ? `<p style="margin-top: 0.5rem; font-size: 0.9rem; opacity: 0.8;">${task.description}</p>` : ''}
                </div>
            `;
        }

        function navigatePlannerWeek(delta) {
            console.log('Navigating week by:', delta);
            currentPlannerDate.setDate(currentPlannerDate.getDate() + (delta * 7));
            console.log('New date:', currentPlannerDate);
            renderCalendar();
        }

        function navigatePlannerMonth(delta) {
            console.log('Navigating month by:', delta);
            console.log('Current date before:', currentPlannerDate);
            currentPlannerDate.setMonth(currentPlannerDate.getMonth() + delta);
            console.log('New date after:', currentPlannerDate);
            renderCalendar();
        }

        function getStartOfWeek(date) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1); // Luned√¨ come primo giorno
            return new Date(d.setDate(diff));
        }

        function getDayName(date) {
            const days = ['DOM', 'LUN', 'MAR', 'MER', 'GIO', 'VEN', 'SAB'];
            return days[date.getDay()];
        }

        function isToday(date) {
            const today = new Date();
            return date.toDateString() === today.toDateString();
        }

        // Helper: converte una data (Date o stringa) in YYYY-MM-DD locale (NO UTC!)
        function toLocalDateStr(d) {
            if (!d) return null;
            const date = (d instanceof Date) ? d : new Date(d);
            if (isNaN(date.getTime())) return null;
            return date.getFullYear() + '-' + String(date.getMonth() + 1).padStart(2, '0') + '-' + String(date.getDate()).padStart(2, '0');
        }

        function formatCalendarDate(date, format) {
            const months = ['gennaio', 'febbraio', 'marzo', 'aprile', 'maggio', 'giugno',
                           'luglio', 'agosto', 'settembre', 'ottobre', 'novembre', 'dicembre'];
            
            const day = date.getDate();
            const month = date.getMonth();
            const year = date.getFullYear();
            
            if (format === 'dd MMM') {
                return `${day} ${months[month].substr(0, 3)}`;
            } else if (format === 'dd MMM yyyy') {
                return `${day} ${months[month].substr(0, 3)} ${year}`;
            } else if (format === 'dd MMMM yyyy') {
                return `${day} ${months[month]} ${year}`;
            }
            
            return fmtDate(date);
        }

        // Riceve token dal launcher (app-launcher.html) via postMessage
        window.addEventListener('message', (e) => {
            if (e.data?.type === 'SB_TOKEN' && e.data.token) {
                sbAccessToken = e.data.token;
                sessionStorage.setItem('sb_token', e.data.token);
                console.log('‚úÖ SB_TOKEN ricevuto dal launcher');
            }
        });

        window.addEventListener('load', init);
    </script>
</body>
</html>
