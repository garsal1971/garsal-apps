<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Habit Stack Tracker</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üî•</text></svg>">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Darker+Grotesque:wght@300;500;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #FF3366;
            --secondary: #6C5CE7;
            --success: #00B894;
            --warning: #F39C12;
            --danger: #E74C3C;

            --dark: #1F2937;
            --light: #FFFFFF;
            --muted: #6B7280;

            --accent: #2563EB;
            --border: #E5E7EB;
            --card-bg: #FFFFFF;
            --input-bg: #F9FAFB;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Darker Grotesque', sans-serif;
            background: var(--light);
            color: var(--dark);
            min-height: 100vh;
        }

        .app-container {
            display: grid;
            grid-template-columns: 280px 1fr;
            min-height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            background: #F3F4F6;
            padding: 1.0rem 0.75rem;
            border-right: 1px solid var(--border);
        }

        .nav-menu {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .nav-item {
            padding: 0.5rem 0.6rem;
            margin-bottom: 0.5rem;
            border-radius: 0;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1rem;
            font-weight: 500;
            position: relative;
        }

        .nav-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .nav-item.active {
            background: var(--primary);
        }

        /* Card punteggio totale */
        .score-widget {
            margin-top: 3rem;
            padding: 0.75rem;
            background: rgba(0, 217, 163, 0.1);
            border-radius: 0;
            border: 2px solid var(--success);
        }

        .score-value {
            font-family: 'Space Mono', monospace;
            font-size: 3rem;
            font-weight: 700;
            color: var(--success);
            text-align: center;
        }

        .score-label {
            text-align: center;
            margin-top: 0.5rem;
            opacity: 0.8;
        }

        /* Sidebar add button */
        .sidebar-add-btn {
            margin-top: 1.5rem;
            width: 100%;
            padding: 0.75rem;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 0;
            font-size: 1.5rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .sidebar-add-btn:hover {
            transform: translateY(-2px);
        }

        /* Main Content */
        .main-content {
            padding: 2rem;
            overflow-y: auto;
        }

        .page-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .page-title {
            font-size: 2.5rem;
            font-weight: 900;
            color: var(--dark);
        }

        /* Cards */
        .card {
            background: var(--card-bg);
            border: 2px solid var(--border);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            transition: all 0.3s ease;
        }

        .card:hover {
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
        }

        /* Buttons */
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            cursor: pointer;
            font-family: 'Darker Grotesque', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: #E6305C;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 51, 102, 0.4);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-success:hover {
            background: #00A884;
        }

        .btn-secondary {
            background: var(--secondary);
            color: white;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        /* Forms */
        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 700;
            color: var(--dark);
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--border);
            background: var(--input-bg);
            font-family: 'Darker Grotesque', sans-serif;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent);
            background: white;
        }

        /* Heatmap */
        .heatmap-container {
            overflow-x: auto;
            margin: 1rem 0;
        }

        .heatmap {
            display: grid;
            gap: 4px;
            grid-template-columns: repeat(auto-fill, 20px);
            padding: 1rem;
        }

        .heatmap-cell {
            width: 20px;
            height: 20px;
            background: #eee;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .heatmap-cell:hover {
            transform: scale(1.2);
            z-index: 10;
        }

        .heatmap-cell[data-level="1"] { background: #c6e48b; }
        .heatmap-cell[data-level="2"] { background: #7bc96f; }
        .heatmap-cell[data-level="3"] { background: #239a3b; }
        .heatmap-cell[data-level="4"] { background: #196127; }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin: 1rem 0;
        }

        /* Su mobile riduci solo il padding */
        @media (max-width: 768px) {
            .stat-card {
                padding: 1rem;
                font-size: 0.9rem;
            }
        }

        .stat-card {
            background: var(--card-bg);
            border: 2px solid var(--border);
            padding: 1.5rem;
            text-align: center;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 900;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Habit List */
        .habit-list {
            display: grid;
            gap: 1rem;
        }

        .habit-card {
            background: var(--card-bg);
            border: 2px solid var(--border);
            padding: 1.5rem;
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 1rem;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .habit-card:hover {
            border-color: var(--primary);
            box-shadow: 0 4px 20px rgba(255, 51, 102, 0.2);
        }

        .habit-checkbox {
            width: 30px;
            height: 30px;
            border: 3px solid var(--border);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .habit-checkbox.checked {
            background: var(--success);
            border-color: var(--success);
            color: white;
        }

        .habit-info h3 {
            font-size: 1.3rem;
            margin-bottom: 0.3rem;
        }

        .habit-streak {
            display: inline-block;
            background: var(--warning);
            color: white;
            padding: 0.2rem 0.6rem;
            font-size: 0.9rem;
            font-weight: 700;
            margin-top: 0.3rem;
        }

        .category-pill {
            display: inline-block;
            padding: 0.3rem 0.8rem;
            font-size: 0.8rem;
            font-weight: 700;
            margin: 0.2rem;
            color: white;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-title {
            font-size: 1.8rem;
            font-weight: 900;
        }

        .modal-close {
            cursor: pointer;
            font-size: 2rem;
            font-weight: 700;
            color: var(--muted);
            transition: color 0.3s;
        }

        .modal-close:hover {
            color: var(--danger);
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: var(--dark);
            color: white;
            padding: 1rem 1.5rem;
            z-index: 2000;
            animation: slideIn 0.3s ease;
            max-width: 300px;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #eee;
            margin: 1rem 0;
            position: relative;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success), var(--accent));
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
        }

        /* Responsive */
        /* Top Navigation Bar per Mobile */
        .bottom-nav {
            display: none;
            position: fixed;
            top: 0; /* Cambiato da bottom a top */
            left: 0;
            right: 0;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); /* Ombra verso il basso */
            z-index: 2000;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-color); /* Cambiato da border-top a border-bottom */
        }

        .bottom-nav-items {
            display: flex;
            justify-content: space-around;
            align-items: center;
            max-width: 600px;
            margin: 0 auto;
        }

        .bottom-nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0.7rem 0.5rem; /* Padding ridotto */
            color: var(--text-secondary);
            text-decoration: none;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
            border: none;
            background: none;
            font-size: 0.75rem;
        }

        .bottom-nav-item .icon {
            font-size: 1.8rem; /* Icone pi√π grandi senza testo */
            margin-bottom: 0; /* Rimosso margin sotto icona */
        }

        .bottom-nav-item.active {
            color: var(--primary);
        }

        .bottom-nav-item:active {
            transform: scale(0.9);
        }

        @media (max-width: 768px) {
            .app-container {
                grid-template-columns: 1fr;
                padding-top: 55px; /* Ridotto da 70px per navbar pi√π compatta */
                padding-bottom: 0;
            }

            .bottom-nav {
                display: block;
            }

            .sidebar {
                display: none !important; /* Nascondi completamente sidebar su mobile */
            }

            main {
                padding: 1rem;
            }

            .page-title {
                font-size: 2rem;
            }
        }

        @media (max-width: 480px) {
            }
        }

        }

        /* Color Picker */
        .color-picker {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .color-option {
            width: 40px;
            height: 40px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s ease;
        }

        .color-option:hover,
        .color-option.selected {
            border-color: var(--dark);
            transform: scale(1.1);
        }

        /* Chart */
        .chart-container {
            margin: 2rem 0;
            padding: 1rem;
            background: var(--card-bg);
            border: 2px solid var(--border);
        }

        .chart-bars {
            display: flex;
            align-items: flex-end;
            justify-content: space-around;
            height: 200px;
            gap: 0.5rem;
        }

        .chart-bar {
            flex: 1;
            background: var(--accent);
            min-height: 20px;
            position: relative;
            transition: all 0.3s ease;
        }

        .chart-bar:hover {
            background: var(--primary);
        }

        .chart-bar-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8rem;
            white-space: nowrap;
        }

        .chart-bar-value {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-weight: 700;
            color: var(--dark);
        }

        /* Habits Timeline */
        .habits-timeline-container {
            margin-bottom: 2rem;
        }

        .habit-stack {
            margin-bottom: 2rem;
            padding-bottom: 2rem;
            border-bottom: 2px solid var(--border);
        }

        .habit-stack:last-child {
            border-bottom: none;
        }

        .habit-stack-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding: 0.75rem 1rem;
            background: var(--input-bg);
            border-left: 4px solid var(--primary);
        }

        .habit-stack-title {
            font-size: 1.3rem;
            font-weight: 900;
            color: var(--dark);
            margin: 0;
        }

        .habit-stack-progress {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--primary);
        }

        .timeline-scroll {
            overflow-x: auto;
            overflow-y: hidden;
            padding: 1rem 0;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
        }

        .timeline-scroll::-webkit-scrollbar {
            height: 8px;
        }

        .timeline-scroll::-webkit-scrollbar-track {
            background: var(--input-bg);
        }

        .timeline-scroll::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 4px;
        }

        .timeline-scroll::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }

        .timeline-track {
            display: flex;
            gap: 1rem;
            min-width: min-content;
            padding: 0 1rem;
        }

        .day-card {
            min-width: 160px;
            max-width: 200px;
            background: white;
            border: 2px solid var(--border);
            padding: 1rem;
            transition: all 0.3s ease;
            cursor: pointer;
            scroll-snap-align: start;
        }

        .day-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            border-color: var(--accent);
        }

        .day-card.today {
            border-color: var(--primary);
            border-width: 3px;
            background: linear-gradient(135deg, #fff 0%, #fff5f7 100%);
        }

        .day-card.completed {
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            border-color: var(--success);
        }

        .day-card.failed {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border-color: #2196F3;
        }

        .day-card.future {
            opacity: 0.6;
        }
        
        .day-card.past:not(.completed):not(.failed) {
            opacity: 0.5;
            filter: grayscale(50%);
        }

        .day-card-date {
            text-align: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid var(--border);
        }

        .day-card-day {
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .day-card-number {
            font-size: 1.8rem;
            font-weight: 900;
            color: var(--dark);
            margin: 0.2rem 0;
        }

        .day-card-month {
            font-size: 0.8rem;
            color: var(--muted);
            text-transform: uppercase;
        }

        .day-card.today .day-card-number {
            color: var(--primary);
        }

        .day-card.completed .day-card-number {
            color: var(--success);
        }

        .day-card-times {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .time-slot {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0.6rem;
            background: var(--input-bg);
            transition: all 0.2s ease;
        }

        .time-slot:hover {
            background: var(--border);
        }

        .time-slot.completed {
            background: var(--success);
            color: white;
        }

        .time-slot.completed .time-text {
            text-decoration: line-through;
            opacity: 0.8;
        }

        .time-checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .time-slot.completed .time-checkbox {
            background: white;
            border-color: white;
            color: var(--success);
        }

        .time-slot.today-slot {
            border: 2px solid var(--primary);
            background: var(--input-bg);
        }

        .time-text {
            font-size: 0.9rem;
            font-weight: 600;
            font-family: 'Space Mono', monospace;
        }

        /* Simple buttons for state */
        .state-buttons {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
        }

        .simple-btn {
            width: 45px;
            height: 45px;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            background: white;
            transition: all 0.2s ease;
        }

        .simple-btn:hover {
            transform: scale(1.05);
        }

        .simple-btn.btn-completed {
            background: #4CAF50;
            border-color: #4CAF50;
            color: white;
        }

        .simple-btn.btn-failed {
            background: #2196F3;
            border-color: #2196F3;
            color: white;
        }

        .single-completion {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .completion-checkbox {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .completion-checkbox:hover {
            border-color: var(--success);
            transform: scale(1.1);
        }

        .completion-checkbox.checked {
            background: var(--success);
            border-color: var(--success);
            color: white;
        }

        /* Debug Console */
        .debug-toggle {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            z-index: 3000;
            background: var(--dark);
            color: white;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .debug-toggle:hover {
            transform: scale(1.1);
            background: var(--accent);
        }

        .debug-console {
            position: fixed;
            bottom: 80px;
            right: 1rem;
            width: 400px;
            max-width: calc(100vw - 2rem);
            max-height: 500px;
            background: #1a1a1a;
            color: #0f0;
            border: 2px solid var(--accent);
            z-index: 2999;
            display: none;
            flex-direction: column;
            font-family: 'Space Mono', monospace;
            font-size: 0.85rem;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
        }

        .debug-console.active {
            display: flex;
        }

        .debug-header {
            background: var(--accent);
            color: white;
            padding: 0.75rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 700;
        }

        .debug-controls {
            display: flex;
            gap: 0.5rem;
        }

        .debug-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            font-size: 0.8rem;
            font-family: 'Space Mono', monospace;
            transition: background 0.3s;
        }

        .debug-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .debug-content {
            flex: 1;
            overflow-y: auto;
            padding: 0.75rem;
            max-height: 400px;
        }

        .debug-log {
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            border-left: 3px solid #0f0;
            background: rgba(0, 255, 0, 0.05);
            word-wrap: break-word;
        }

        .debug-log.error {
            border-left-color: #f00;
            color: #f00;
            background: rgba(255, 0, 0, 0.05);
        }

        .debug-log.warn {
            border-left-color: #ff0;
            color: #ff0;
            background: rgba(255, 255, 0, 0.05);
        }

        .debug-log.info {
            border-left-color: #0af;
            color: #0af;
            background: rgba(0, 170, 255, 0.05);
        }

        .debug-timestamp {
            opacity: 0.6;
            font-size: 0.75rem;
            margin-right: 0.5rem;
        }

        .debug-stats {
            background: rgba(0, 255, 0, 0.1);
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            border: 1px solid rgba(0, 255, 0, 0.3);
        }

        .debug-stats-item {
            display: flex;
            justify-content: space-between;
            padding: 0.25rem 0;
            border-bottom: 1px solid rgba(0, 255, 0, 0.1);
        }

        .debug-stats-item:last-child {
            border-bottom: none;
        }

        @media (max-width: 768px) {
            .debug-console {
                width: calc(100vw - 2rem);
                right: 1rem;
                left: 1rem;
            }
        }
    </style>
</head>
<body>
    <!-- Menu Toggle (Mobile) -->
    <!-- Top Navigation Bar (Mobile Only) -->
    <nav class="bottom-nav">
        <div class="bottom-nav-items">
            <button class="bottom-nav-item active" onclick="showPage('dashboard')" data-page="dashboard">
                <span class="icon">üìä</span>
            </button>
            <button class="bottom-nav-item" onclick="showPage('habits')" data-page="habits">
                <span class="icon">‚úÖ</span>
            </button>
            <button class="bottom-nav-item" onclick="showPage('archive')" data-page="archive">
                <span class="icon">üì¶</span>
            </button>
            <button class="bottom-nav-item" onclick="showPage('settings')" data-page="settings">
                <span class="icon">‚öôÔ∏è</span>
            </button>
        </div>
    </nav>

    <!-- Debug Toggle -->
    <button class="debug-toggle" onclick="toggleDebug()" title="Debug Console">üêõ</button>

    <!-- Debug Console -->
    <div id="debugConsole" class="debug-console">
        <div class="debug-header">
            <span>üêõ Debug Console</span>
            <div class="debug-controls">
                <button class="debug-btn" onclick="refreshDebugStats()">üîÑ</button>
                <button class="debug-btn" onclick="clearDebugLogs()">üóëÔ∏è</button>
                <button class="debug-btn" onclick="toggleDebug()">‚úï</button>
            </div>
        </div>
        <div class="debug-content">
            <div id="debugStats" class="debug-stats"></div>
            <div id="debugLogs"></div>
        </div>
    </div>

    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <nav class="nav-menu">
                <div class="nav-item active" onclick="showPage('dashboard')">üìÖ Piano</div>
                <div class="nav-item" onclick="showPage('habits')">‚öôÔ∏è Gestione</div>
                <div class="nav-item" onclick="showPage('archive')">üì¶ Storico</div>
                <div class="nav-item" onclick="showPage('settings')">üîß Impostazioni</div>
            </nav>

            <div class="score-widget">
                <div class="score-value" id="totalScore">0</div>
                <div class="score-label">Punteggio Totale</div>
            </div>
            
            <button class="sidebar-add-btn" onclick="showAddHabitModal()">+</button>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Dashboard Page -->
            <div id="page-dashboard" class="page">
                <div class="card">
                    <div id="habitsTimeline">
                        <!-- Timeline will be rendered here -->
                    </div>
                </div>
            </div>

            <!-- Habits Page -->
            <div id="page-habits" class="page" style="display: none;">
                <div style="margin-bottom: 1.5rem;">
                    <button class="btn btn-primary" onclick="showAddHabitModal()">Nuova Abitudine</button>
                </div>

                <div style="display: flex; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap;">
                    <select class="form-input" style="width: auto;" onchange="filterHabits()" id="filterCategory">
                        <option value="">Tutte le categorie</option>
                    </select>
                    <select class="form-input" style="width: auto;" onchange="filterHabits()" id="filterStatus">
                        <option value="active">Attive</option>
                        <option value="paused">In pausa</option>
                        <option value="all">Tutte</option>
                    </select>
                </div>
                <div id="habitsList" class="habit-list">
                    <!-- All habits will be rendered here -->
                </div>
            </div>

            <!-- Archive Page -->
            <div id="page-archive" class="page" style="display: none;">
                <div id="archivedStacksList">
                    <!-- Lista stack archiviati -->
                </div>
            </div>

            <!-- Stats Page -->
            <div id="page-stats" class="page" style="display: none;">
                <div class="page-header">
                    <h1 class="page-title">Statistiche</h1>
                </div>

                <div class="stats-grid" id="detailedStats">
                    <!-- Detailed stats will be rendered here -->
                </div>

                <div class="card">
                    <h2 style="margin-bottom: 1rem;">Andamento Mensile</h2>
                    <div id="monthlyChart" class="chart-container">
                        <!-- Monthly chart will be rendered here -->
                    </div>
                </div>

                <div class="card">
                    <h2 style="margin-bottom: 1rem;">Classifica Abitudini</h2>
                    <div id="habitsRanking">
                        <!-- Habits ranking will be rendered here -->
                    </div>
                </div>
            </div>

            <!-- Categories Page -->
            <div id="page-categories" class="page" style="display: none;">
                <div class="page-header">
                    <h1 class="page-title">Categorie</h1>
                    <button class="btn btn-primary" onclick="showAddCategoryModal()">+ Nuova Categoria</button>
                </div>

                <div class="card">
                    <div id="categoriesList">
                        <!-- Categories will be rendered here -->
                    </div>
                </div>
            </div>

            <!-- Settings Page -->
            <div id="page-settings" class="page" style="display: none;">
                <div class="page-header">
                    <h1 class="page-title">Impostazioni</h1>
                </div>

                <div class="card">
                    <h2 style="margin-bottom: 1rem;">Notifiche</h2>
                    <div class="form-group">
                        <label class="form-label">
                            <input type="checkbox" id="notificationsEnabled" onchange="saveSettings()">
                            Abilita promemoria giornalieri
                        </label>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Orario promemoria</label>
                        <input type="time" class="form-input" id="notificationTime" value="09:00" onchange="saveSettings()">
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Add Habit Modal -->
    <div id="addHabitModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Nuova Abitudine</h2>
                <span class="modal-close" onclick="closeModal('addHabitModal')">‚úï</span>
            </div>
            <form onsubmit="addHabit(event)">
                <div class="form-group">
                    <label class="form-label">Nome Abitudine *</label>
                    <input type="text" class="form-input" id="habitName" required placeholder="es. Meditazione mattutina">
                </div>
                <div class="form-group">
                    <label class="form-label">Descrizione</label>
                    <textarea class="form-input" id="habitDescription" rows="3" placeholder="Descrivi la tua abitudine..."></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Categoria</label>
                    <select class="form-input" id="habitCategory">
                        <option value="">Nessuna categoria</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Frequenza</label>
                    <select class="form-input" id="habitFrequency">
                        <option value="daily">Giornaliera (una volta al giorno)</option>
                        <option value="daily_multiple">Giornaliera (pi√π volte al giorno)</option>
                        <option value="weekly">Settimanale (giorni specifici)</option>
                        <option value="custom">Personalizzata</option>
                    </select>
                </div>
                <div class="form-group" id="dailyTimesGroup" style="display: none;">
                    <label class="form-label">Orari giornalieri</label>
                    <p style="opacity: 0.7; font-size: 0.9rem; margin-bottom: 0.5rem;">Aggiungi gli orari in cui vuoi ripetere l'abitudine ogni giorno</p>
                    <div id="dailyTimesList" style="margin-bottom: 0.5rem;"></div>
                    <div style="display: flex; gap: 0.5rem;">
                        <input type="time" class="form-input" id="newDailyTime" style="flex: 1;">
                        <button type="button" class="btn btn-secondary" onclick="addDailyTime()">+ Aggiungi Orario</button>
                    </div>
                </div>
                <div class="form-group" id="weekdaysGroup" style="display: none;">
                    <label class="form-label">Giorni della settimana</label>
                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <label><input type="checkbox" name="weekday" value="1"> Lun</label>
                        <label><input type="checkbox" name="weekday" value="2"> Mar</label>
                        <label><input type="checkbox" name="weekday" value="3"> Mer</label>
                        <label><input type="checkbox" name="weekday" value="4"> Gio</label>
                        <label><input type="checkbox" name="weekday" value="5"> Ven</label>
                        <label><input type="checkbox" name="weekday" value="6"> Sab</label>
                        <label><input type="checkbox" name="weekday" value="0"> Dom</label>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Data Inizio Stack</label>
                    <input type="date" class="form-input" id="habitStartDate" value="">
                    <small style="opacity: 0.7; font-size: 0.85rem; display: block; margin-top: 0.3rem;">
                        I giorni prima di questa data non verranno contati
                    </small>
                </div>
                <div class="form-group">
                    <label class="form-label">Obiettivo (giorni/settimane consecutive)</label>
                    <input type="number" class="form-input" id="habitGoal" value="30" min="1">
                </div>
                <div class="form-group">
                    <label class="form-label">üÉè Jolly Fallimenti</label>
                    <input type="number" class="form-input" id="habitMaxFailures" value="3" min="0" max="10">
                    <small style="opacity: 0.7; font-size: 0.85rem; display: block; margin-top: 0.3rem;">
                        Numero di fallimenti consentiti prima di resettare lo stack (0 = nessun fallimento tollerato)
                    </small>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <div class="form-group">
                        <label class="form-label">üèÜ Punti Ricompensa</label>
                        <input type="number" class="form-input" id="habitPointsReward" value="100" min="0" step="10">
                        <small style="opacity: 0.7; font-size: 0.85rem; display: block; margin-top: 0.3rem;">
                            Punti guadagnati completando lo stack
                        </small>
                    </div>
                    <div class="form-group">
                        <label class="form-label">üíî Penalit√† Fallimento</label>
                        <input type="number" class="form-input" id="habitPointsPenalty" value="50" min="0" step="10">
                        <small style="opacity: 0.7; font-size: 0.85rem; display: block; margin-top: 0.3rem;">
                            Punti persi se fallisci lo stack
                        </small>
                    </div>
                </div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">Crea Abitudine</button>
            </form>
        </div>
    </div>

    <!-- Edit Habit Modal -->
    <div class="modal" id="editHabitModal">
        <div class="modal-content">
            <h2>Modifica Abitudine</h2>
            <form id="editHabitForm">
                <input type="hidden" id="editHabitId">
                
                <div class="form-group">
                    <label class="form-label">Nome Abitudine</label>
                    <input type="text" class="form-input" id="editHabitName" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Descrizione (opzionale)</label>
                    <textarea class="form-input" id="editHabitDescription" rows="3"></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Categoria</label>
                    <select class="form-input" id="editHabitCategory">
                        <option value="">Nessuna categoria</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Frequenza</label>
                    <select class="form-input" id="editHabitFrequency">
                        <option value="daily">Giornaliera</option>
                        <option value="daily_multiple">Giornaliera con orari multipli</option>
                        <option value="weekly">Settimanale</option>
                    </select>
                </div>
                
                <!-- Orari multipli -->
                <div id="editDailyTimesSection" style="display: none;">
                    <div class="form-group">
                        <label class="form-label">Orari giornalieri</label>
                        <div id="editDailyTimesList"></div>
                        <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                            <input type="time" class="form-input" id="editNewDailyTime" style="flex: 1;">
                            <button type="button" class="btn btn-secondary" onclick="addEditDailyTime()">Aggiungi</button>
                        </div>
                    </div>
                </div>
                
                <!-- Giorni settimanali -->
                <div id="editWeekdaysSection" style="display: none;">
                    <div class="form-group">
                        <label class="form-label">Giorni della settimana</label>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            <label><input type="checkbox" name="editWeekday" value="1"> Lun</label>
                            <label><input type="checkbox" name="editWeekday" value="2"> Mar</label>
                            <label><input type="checkbox" name="editWeekday" value="3"> Mer</label>
                            <label><input type="checkbox" name="editWeekday" value="4"> Gio</label>
                            <label><input type="checkbox" name="editWeekday" value="5"> Ven</label>
                            <label><input type="checkbox" name="editWeekday" value="6"> Sab</label>
                            <label><input type="checkbox" name="editWeekday" value="0"> Dom</label>
                        </div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Data Inizio Stack</label>
                    <input type="date" class="form-input" id="editHabitStartDate">
                    <small style="opacity: 0.7; font-size: 0.85rem; display: block; margin-top: 0.3rem;">
                        I giorni prima di questa data non verranno contati
                    </small>
                </div>
                <div class="form-group">
                    <label class="form-label">Obiettivo (giorni/settimane consecutive)</label>
                    <input type="number" class="form-input" id="editHabitGoal" min="1">
                </div>
                <div class="form-group">
                    <label class="form-label">üÉè Jolly Fallimenti</label>
                    <input type="number" class="form-input" id="editHabitMaxFailures" min="0" max="10">
                    <small style="opacity: 0.7; font-size: 0.85rem; display: block; margin-top: 0.3rem;">
                        Numero di fallimenti consentiti prima di resettare lo stack
                    </small>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <div class="form-group">
                        <label class="form-label">üèÜ Punti Ricompensa</label>
                        <input type="number" class="form-input" id="editHabitPointsReward" min="0" step="10">
                    </div>
                    <div class="form-group">
                        <label class="form-label">üíî Penalit√† Fallimento</label>
                        <input type="number" class="form-input" id="editHabitPointsPenalty" min="0" step="10">
                    </div>
                </div>
                
                <div style="display: flex; gap: 0.5rem;">
                    <button type="submit" class="btn btn-primary" style="flex: 1;">Salva Modifiche</button>
                    <button type="button" class="btn btn-secondary" onclick="closeModal('editHabitModal')" style="flex: 1;">Annulla</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div class="modal" id="gameOverModal" style="z-index: 2000;">
        <div class="modal-content" style="max-width: 500px; text-align: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; animation: shake 0.5s;">
            <div style="font-size: 4rem; margin-bottom: 1rem;">üíÄ</div>
            <h1 style="font-size: 3rem; margin: 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); animation: pulse 1s infinite;">GAME OVER</h1>
            <p style="font-size: 1.5rem; margin: 1rem 0; opacity: 0.9;">Jolly Esauriti!</p>
            
            <div id="gameOverHabitName" style="font-size: 1.2rem; margin: 1rem 0; padding: 1rem; background: rgba(255,255,255,0.2); border-radius: 8px;">
                <!-- Nome abitudine -->
            </div>
            
            <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 2rem;">
                <div style="text-align: center;">
                    <div style="font-size: 2rem;">üî•</div>
                    <div style="font-size: 1.5rem; font-weight: bold;" id="gameOverStreak">0</div>
                    <div style="opacity: 0.8;">Streak Finale</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 2rem;">üìÖ</div>
                    <div style="font-size: 1.5rem; font-weight: bold;" id="gameOverDays">0</div>
                    <div style="opacity: 0.8;">Giorni Totali</div>
                </div>
            </div>
            
            <button class="btn btn-primary" onclick="closeGameOver()" style="width: 100%; margin-top: 2rem; font-size: 1.2rem; background: white; color: #667eea; border: none;">
                üîÑ Ricomincia da Capo
            </button>
        </div>
    </div>

    <style>
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-10px); }
            20%, 40%, 60%, 80% { transform: translateX(10px); }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
    </style>

    <!-- Add Category Modal -->
    <div id="addCategoryModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Nuova Categoria</h2>
                <span class="modal-close" onclick="closeModal('addCategoryModal')">‚úï</span>
            </div>
            <form onsubmit="addCategory(event)">
                <div class="form-group">
                    <label class="form-label">Nome Categoria *</label>
                    <input type="text" class="form-input" id="categoryName" required placeholder="es. Salute">
                </div>
                <div class="form-group">
                    <label class="form-label">Icona</label>
                    <input type="text" class="form-input" id="categoryIcon" placeholder="es. üí™" maxlength="2">
                </div>
                <div class="form-group">
                    <label class="form-label">Colore</label>
                    <div class="color-picker">
                        <div class="color-option" style="background: #FF3366;"></div>
                        <div class="color-option" style="background: #6C5CE7;"></div>
                        <div class="color-option" style="background: #00B894;"></div>
                        <div class="color-option" style="background: #F39C12;"></div>
                        <div class="color-option" style="background: #E74C3C;"></div>
                        <div class="color-option" style="background: #2563EB;"></div>
                    </div>
                    <input type="hidden" id="categoryColor" value="#FF3366">
                </div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">Crea Categoria</button>
            </form>
        </div>
    </div>

    <!-- Edit Category Modal -->
    <div id="editCategoryModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Modifica Categoria</h2>
                <span class="modal-close" onclick="closeModal('editCategoryModal')">‚úï</span>
            </div>
            <form onsubmit="updateCategory(event)">
                <input type="hidden" id="editCategoryId">
                <div class="form-group">
                    <label class="form-label">Nome Categoria *</label>
                    <input type="text" class="form-input" id="editCategoryName" required placeholder="es. Salute">
                </div>
                <div class="form-group">
                    <label class="form-label">Icona</label>
                    <input type="text" class="form-input" id="editCategoryIcon" placeholder="es. üí™" maxlength="2">
                </div>
                <div class="form-group">
                    <label class="form-label">Colore</label>
                    <div class="color-picker">
                        <div class="color-option" style="background: #FF3366;"></div>
                        <div class="color-option" style="background: #6C5CE7;"></div>
                        <div class="color-option" style="background: #00B894;"></div>
                        <div class="color-option" style="background: #F39C12;"></div>
                        <div class="color-option" style="background: #E74C3C;"></div>
                        <div class="color-option" style="background: #2563EB;"></div>
                    </div>
                    <input type="hidden" id="editCategoryColor" value="#FF3366">
                </div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">Salva Modifiche</button>
            </form>
        </div>
    </div>

    <!-- View Category Habits Modal -->
    <div id="viewCategoryModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h2 class="modal-title">Dettagli Categoria</h2>
                <span class="modal-close" onclick="closeViewCategoryModal()">‚úï</span>
            </div>
            <div id="viewCategoryContent" style="max-height: 70vh; overflow-y: auto;">
                <!-- Content will be rendered here -->
            </div>
        </div>
    </div>

    <script>
        // Supabase Configuration
        // VERSION 2.0 - Fixed supabase client reference
        const SUPABASE_URL = 'https://jajlmmdsjlvzgcxiiypk.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImphamxtbWRzamx2emdjeGlpeXBrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njk5NTU0NjYsImV4cCI6MjA4NTUzMTQ2Nn0.ikaipwxOvIn43epayQ4mSZQkXtin3aaGEPouafwJFxU';
        const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
        console.log('üî• Habit Tracker v9.0.1');
        console.log('üì° Client object:', supabaseClient);

        // Global State
        let habits = [];
        let categories = [];
        let completions = [];
        let archivedStacks = [];
        let settings = {
            notificationsEnabled: false,
            notificationTime: '09:00'
        };
        let debugLogs = [];
        let debugEnabled = false;
        let dailyTimes = []; // Array per orari multipli giornalieri

        // Debug Functions
        function toggleDebug() {
            const debugConsole = document.getElementById('debugConsole');
            debugConsole.classList.toggle('active');
            debugEnabled = debugConsole.classList.contains('active');
            if (debugEnabled) {
                refreshDebugStats();
            }
        }

        function clearDebugLogs() {
            debugLogs = [];
            document.getElementById('debugLogs').innerHTML = '';
            addDebugLog('Console cleared', 'info');
        }

        function addDebugLog(message, type = 'log') {
            const timestamp = new Date().toLocaleTimeString('it-IT');
            const log = { timestamp, message, type };
            debugLogs.push(log);
            
            // Keep only last 100 logs
            if (debugLogs.length > 100) {
                debugLogs = debugLogs.slice(-100);
            }
            
            // Update display if console is open
            if (debugEnabled) {
                const logsContainer = document.getElementById('debugLogs');
                const logDiv = document.createElement('div');
                logDiv.className = `debug-log ${type}`;
                logDiv.innerHTML = `<span class="debug-timestamp">[${timestamp}]</span>${message}`;
                logsContainer.appendChild(logDiv);
                
                // Auto scroll to bottom
                logsContainer.scrollTop = logsContainer.scrollHeight;
            }
        }

        function refreshDebugStats() {
            const stats = {
                'Abitudini': habits.length,
                'Attive': habits.filter(h => h.status === 'active').length,
                'In Pausa': habits.filter(h => h.status === 'paused').length,
                'Categorie': categories.length,
                'Completamenti': completions.length,
                'Oggi': completions.filter(c => c.completed_at.startsWith(new Date().toISOString().split('T')[0])).length,
                'Logs': debugLogs.length,
                'Supabase': SUPABASE_URL.includes('jajlmm') ? '‚úÖ Connesso' : '‚ùå Errore'
            };

            const statsHtml = Object.entries(stats).map(([key, value]) => `
                <div class="debug-stats-item">
                    <span>${key}:</span>
                    <strong>${value}</strong>
                </div>
            `).join('');

            document.getElementById('debugStats').innerHTML = statsHtml;
        }

        // Override console methods to capture logs
        const originalConsole = {
            log: console.log,
            error: console.error,
            warn: console.warn,
            info: console.info
        };

        console.log = function(...args) {
            originalConsole.log.apply(console, args);
            addDebugLog(args.map(a => JSON.stringify(a)).join(' '), 'log');
        };

        console.error = function(...args) {
            originalConsole.error.apply(console, args);
            addDebugLog(args.map(a => JSON.stringify(a)).join(' '), 'error');
        };

        console.warn = function(...args) {
            originalConsole.warn.apply(console, args);
            addDebugLog(args.map(a => JSON.stringify(a)).join(' '), 'warn');
        };

        console.info = function(...args) {
            originalConsole.info.apply(console, args);
            addDebugLog(args.map(a => JSON.stringify(a)).join(' '), 'info');
        };

        // Daily Times Management
        function addDailyTime() {
            const timeInput = document.getElementById('newDailyTime');
            const time = timeInput.value;
            
            if (!time) {
                showToast('Seleziona un orario');
                return;
            }
            
            if (dailyTimes.includes(time)) {
                showToast('Orario gi√† aggiunto');
                return;
            }
            
            dailyTimes.push(time);
            dailyTimes.sort();
            renderDailyTimes();
            timeInput.value = '';
            console.log('‚úÖ Orario aggiunto:', time, 'Totale:', dailyTimes);
        }
        
        function removeDailyTime(time) {
            dailyTimes = dailyTimes.filter(t => t !== time);
            renderDailyTimes();
            console.log('‚ûñ Orario rimosso:', time);
        }
        
        function renderDailyTimes() {
            const container = document.getElementById('dailyTimesList');
            
            if (dailyTimes.length === 0) {
                container.innerHTML = '<p style="opacity: 0.6; font-size: 0.9rem; font-style: italic;">Nessun orario aggiunto</p>';
                return;
            }
            
            const html = dailyTimes.map(time => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; background: var(--input-bg); border: 1px solid var(--border); margin-bottom: 0.3rem;">
                    <span style="font-weight: 600;">üïê ${time}</span>
                    <button type="button" onclick="removeDailyTime('${time}')" style="background: var(--danger); color: white; border: none; padding: 0.2rem 0.6rem; cursor: pointer; font-size: 0.85rem;">‚úï</button>
                </div>
            `).join('');
            
            container.innerHTML = html;
        }

        // Initialize App
        async function init() {
            console.log('üöÄ Inizializzazione app...');
            console.log('üì° Supabase URL:', SUPABASE_URL);
            
            await loadCategories();
            await loadHabits();
            await loadCompletions();
            await loadArchivedStacks();
            await loadUserPoints(); // Carica punteggio totale
            loadSettings();
            await renderDashboard(); // Ora √® async!
            setupEventListeners();
            requestNotificationPermission();
            
            console.log('‚úÖ App inizializzata con successo!');
            refreshDebugStats();
        }

        // Supabase Functions
        async function loadHabits() {
            try {
                console.log('üì• Caricamento abitudini...');
                const { data, error } = await supabaseClient
                    .from('hb_habits')
                    .select('*')
                    .order('created_at', { ascending: false });
                
                if (error) throw error;
                
                // Converti weekdays da stringhe a numeri
                habits = (data || []).map(habit => {
                    if (habit.weekdays && Array.isArray(habit.weekdays)) {
                        habit.weekdays = habit.weekdays.map(day => parseInt(day));
                    }
                    if (habit.daily_times && Array.isArray(habit.daily_times)) {
                        // Assicurati che daily_times sia array di stringhe
                        habit.daily_times = habit.daily_times.map(time => String(time));
                    }
                    return habit;
                });
                
                console.log(`‚úÖ ${habits.length} abitudini caricate`);
                if (habits.length > 0) {
                    console.log('Esempio abitudine:', habits[0]);
                }
            } catch (error) {
                console.error('‚ùå Errore caricamento abitudini:', error);
                showToast('Errore nel caricamento delle abitudini');
            }
        }

        async function loadCategories() {
            try {
                console.log('üì• Caricamento categorie...');
                const { data, error } = await supabaseClient
                    .from('cm_categories')
                    .select('*')
                    .order('name');
                
                if (error) throw error;
                categories = data || [];
                console.log(`‚úÖ ${categories.length} categorie caricate`);
            } catch (error) {
                console.error('‚ùå Errore caricamento categorie:', error);
                showToast('Errore nel caricamento delle categorie');
            }
        }

        async function loadUserPoints() {
            try {
                const { data, error } = await supabaseClient
                    .from('hb_user_points')
                    .select('*')
                    .limit(1)
                    .single();
                
                if (error && error.code !== 'PGRST116') { // PGRST116 = no rows
                    console.error('‚ùå Errore caricamento punti:', error);
                    return;
                }
                
                if (!data) {
                    // Crea record se non esiste
                    const { data: newData } = await supabaseClient
                        .from('hb_user_points')
                        .insert([{ total_points: 0 }])
                        .select()
                        .single();
                    
                    document.getElementById('totalScore').textContent = '0';
                } else {
                    document.getElementById('totalScore').textContent = data.total_points || 0;
                }
            } catch (error) {
                console.error('‚ùå Errore caricamento punti:', error);
                // Non mostrare errore all'utente, usa 0 di default
                document.getElementById('totalScore').textContent = '0';
            }
        }

        async function loadCompletions() {
            try {
                console.log('üì• Caricamento completamenti...');
                const { data, error } = await supabaseClient
                    .from('hb_completions')
                    .select('*')
                    .order('completed_at', { ascending: false });
                
                if (error) throw error;
                completions = data || [];
                console.log(`‚úÖ ${completions.length} completamenti caricati`);
            } catch (error) {
                console.error('‚ùå Errore caricamento completamenti:', error);
                showToast('Errore nel caricamento dei completamenti');
            }
        }
        async function loadArchivedStacks() {
            try {
                console.log("üì• Caricamento stack archiviati...");
                const { data, error } = await supabaseClient
                    .from("hb_archived_stacks")
                    .select("*")
                    .order("ended_at", { ascending: false });
                
                if (error) throw error;
                archivedStacks = data || [];
                console.log(`‚úÖ ${archivedStacks.length} stack archiviati caricati`);
            } catch (error) {
                console.error("‚ùå Errore caricamento stack archiviati:", error);
            }
        }

        async function addHabit(event) {
            event.preventDefault();
            
            const name = document.getElementById('habitName').value;
            const description = document.getElementById('habitDescription').value;
            const categoryId = document.getElementById('habitCategory').value || null;
            const frequency = document.getElementById('habitFrequency').value;
            const goal = parseInt(document.getElementById('habitGoal').value);
            const maxFailures = parseInt(document.getElementById('habitMaxFailures').value);
            const startedAt = document.getElementById('habitStartDate').value;

            console.log('‚ûï Creazione nuova abitudine:', { name, frequency, goal, maxFailures, startedAt });

            let weekdays = null;
            let daily_times = null;
            
            if (frequency === 'daily_multiple') {
                if (dailyTimes.length === 0) {
                    showToast('Aggiungi almeno un orario per l\'abitudine giornaliera multipla');
                    return;
                }
                daily_times = [...dailyTimes];
                console.log('Orari giornalieri:', daily_times);
            }
            
            if (frequency === 'weekly') {
                const selected = Array.from(document.querySelectorAll('input[name="weekday"]:checked'))
                    .map(cb => parseInt(cb.value));
                if (selected.length === 0) {
                    showToast('Seleziona almeno un giorno della settimana');
                    return;
                }
                weekdays = selected;
                console.log('Giorni selezionati:', weekdays);
            }

            try {
                const { data, error } = await supabaseClient
                    .from('hb_habits')
                    .insert([{
                        name: name,
                        description: description,
                        category_id: categoryId,
                        frequency: frequency,
                        weekdays: weekdays,
                        daily_times: daily_times,
                        started_at: startedAt,
                        goal: goal,
                        max_failures: maxFailures,
                        current_failures: 0,
                        status: 'active',
                        current_streak: 0,
                        best_streak: 0
                    }])
                    .select();

                if (error) throw error;

                habits.push(data[0]);
                console.log('‚úÖ Abitudine creata:', data[0]);
                closeModal('addHabitModal');
                showToast('Abitudine creata con successo! üéâ');
                renderDashboard();
                renderHabits();
                refreshDebugStats();
                
                // Reset form
                document.getElementById('habitName').value = '';
                document.getElementById('habitDescription').value = '';
                document.getElementById('habitGoal').value = '30';
                dailyTimes = [];
                renderDailyTimes();
            } catch (error) {
                console.error('‚ùå Errore creazione abitudine:', error);
                showToast('Errore nella creazione dell\'abitudine');
            }
        }

        async function addCategory(event) {
            event.preventDefault();
            
            const name = document.getElementById('categoryName').value;
            const icon = document.getElementById('categoryIcon').value || 'üìå';
            const color = document.getElementById('categoryColor').value;

            try {
                const { data, error } = await supabaseClient
                    .from('cm_categories')
                    .insert([{
                        name: name,
                        icon: icon,
                        color: color
                    }])
                    .select();

                if (error) throw error;

                categories.push(data[0]);
                closeModal('addCategoryModal');
                showToast('Categoria creata con successo! üéâ');
                renderCategories();
                updateCategorySelects();
                
                // Reset form
                document.getElementById('categoryName').value = '';
                document.getElementById('categoryIcon').value = '';
            } catch (error) {
                console.error('Error adding category:', error);
                showToast('Errore nella creazione della categoria');
            }
        }

        async function setTimeState(habitId, time, dateStr, newState) {
            const targetDate = dateStr || new Date().toISOString().split('T')[0];
            const timeStr = time + ':00';
            
            const existing = completions.find(c => {
                if (c.habit_id !== habitId) return false;
                if (!c.completed_at.startsWith(targetDate)) return false;
                const completionTime = new Date(c.completed_at).toTimeString().substr(0, 5);
                return completionTime === time;
            });

            console.log(`üéØ setTimeState: habit=${habitId}, time=${time}, date=${targetDate}, newState=${newState}`);
            console.log(`üì¶ existing:`, existing);
            console.log(`üì¶ existing?.status:`, existing?.status);

            try {
                if (newState === 'none') {
                    // Rimuovi
                    if (existing) {
                        // Se stavi rimuovendo un "failed", restituisci il jolly
                        if (existing.status === 'failed') {
                            console.log('üÉè [TIME] Rimozione di failed ‚Üí Restituisco jolly');
                            await restoreJolly(habitId);
                        }
                        
                        const { error } = await supabaseClient
                            .from('hb_completions')
                            .delete()
                            .eq('id', existing.id);

                        if (error) throw error;

                        completions = completions.filter(c => c.id !== existing.id);
                        // showToast removed
                    }
                } else {
                    // Verifica lo stato attuale
                    if (existing) {
                        // Se esiste gi√† con lo stesso stato, NON fare nulla
                        if (existing.status === newState) {
                            console.log('‚ö†Ô∏è Stato gi√† impostato, ignoro');
                            return;
                        }
                        
                        // Altrimenti aggiorna lo stato
                        const { data, error } = await supabaseClient
                            .from('hb_completions')
                            .update({ status: newState })
                            .eq('id', existing.id)
                            .select();

                        if (error) throw error;

                        const index = completions.findIndex(c => c.id === existing.id);
                        if (index !== -1) completions[index] = data[0];
                    } else {
                        // Crea nuovo
                        const completionDateTime = `${targetDate}T${timeStr}`;
                        
                        const { data, error } = await supabaseClient
                            .from('hb_completions')
                            .insert([{
                                habit_id: habitId,
                                completed_at: completionDateTime,
                                status: newState,
                                notes: `${newState} alle ${time}`
                            }])
                            .select();

                        if (error) throw error;

                        completions.push(data[0]);
                    }
                    
                    // Gestione jolly
                    console.log(`üÉè Controllo jolly: existing=${!!existing}, existing.status=${existing?.status}, newState=${newState}`);
                    
                    if (existing && existing.status === 'failed' && newState === 'completed') {
                        console.log('‚úÖ Condizione RESTORE soddisfatta!');
                        await restoreJolly(habitId);
                    }
                    else if (newState === 'failed') {
                        console.log('‚ùå Condizione CONSUME soddisfatta!');
                        await handleFailure(habitId);
                    }
                    else {
                        console.log('‚ö™ Nessuna gestione jolly necessaria');
                    }
                    
                    // showToast removed
                }

                await updateStreak(habitId);
                await loadHabits();
                updateTimeSlot(habitId, time, dateStr, newState);
                refreshDebugStats();
            } catch (error) {
                console.error('‚ùå Errore impostazione stato orario:', error);
                showToast('Errore nel salvataggio');
            }
        }

        function updateTimeSlot(habitId, time, dateStr, newState) {
            const card = document.querySelector(`[data-habit="${habitId}"][data-date="${dateStr}"]`);
            if (!card) return;

            const timeSlot = card.querySelector(`[data-time="${time}"]`);
            if (!timeSlot) {
                console.log(`‚ö†Ô∏è Time-slot ${time} non trovato`);
                return;
            }
            
            const completion = completions.find(c => {
                if (c.habit_id !== habitId) return false;
                if (!c.completed_at.startsWith(dateStr)) return false;
                const compTime = new Date(c.completed_at).toTimeString().substr(0, 5);
                return compTime === time;
            });
            
            const isCompleted = completion && completion.status === 'completed';
            const isFailed = completion && completion.status === 'failed';

            const btnComplete = timeSlot.querySelector('[data-action="complete"]');
            const btnSkip = timeSlot.querySelector('[data-action="fail"]');
            
            if (btnComplete) {
                btnComplete.classList.remove('btn-completed');
                if (isCompleted) btnComplete.classList.add('btn-completed');
            }
            
            if (btnSkip) {
                btnSkip.classList.remove('btn-failed');
                if (isFailed) btnSkip.classList.add('btn-failed');
            }

            // Aggiorna lo stato della card
            const habit = habits.find(h => h.id === habitId);
            if (habit && habit.daily_times) {
                const completionsOnDay = completions.filter(c => 
                    c.habit_id === habitId && c.completed_at.startsWith(dateStr)
                );
                const completedCount = completionsOnDay.filter(c => c.status === 'completed').length;
                const allCompleted = completedCount >= habit.daily_times.length;
                
                card.classList.remove('completed', 'failed');
                if (allCompleted) card.classList.add('completed');
            }

            // Aggiorna l'header con il nuovo progress e streak
            updateHabitHeader(habitId);
        }

        async function toggleHabitTimeCompletion(habitId, time, dateStr = null) {
            const targetDate = dateStr || new Date().toISOString().split('T')[0];
            const timeStr = time + ':00';
            
            const existing = completions.find(c => {
                if (c.habit_id !== habitId) return false;
                if (!c.completed_at.startsWith(targetDate)) return false;
                const completionTime = new Date(c.completed_at).toTimeString().substr(0, 5);
                return completionTime === time;
            });

            console.log(`üîÑ Toggle 3-state orario ${time} del ${targetDate}`);

            try {
                if (!existing) {
                    // Stato 0 ‚Üí Stato 1: NON FATTO ‚Üí FATTO
                    const completionDateTime = `${targetDate}T${timeStr}`;
                    
                    const { data, error } = await supabaseClient
                        .from('hb_completions')
                        .insert([{
                            habit_id: habitId,
                            completed_at: completionDateTime,
                            status: 'completed',
                            notes: `Completato alle ${time}`
                        }])
                        .select();

                    if (error) throw error;

                    completions.push(data[0]);
                    // showToast removed
                } else if (existing.status === 'completed') {
                    // Stato 1 ‚Üí Stato 2: FATTO ‚Üí DIMENTICATO
                    const { data, error } = await supabaseClient
                        .from('hb_completions')
                        .update({ status: 'failed' })
                        .eq('id', existing.id)
                        .select();

                    if (error) throw error;

                    const index = completions.findIndex(c => c.id === existing.id);
                    if (index !== -1) completions[index] = data[0];
                    
                    // showToast removed
                } else {
                    // Stato 2 ‚Üí Stato 0: DIMENTICATO ‚Üí NON FATTO
                    const { error } = await supabaseClient
                        .from('hb_completions')
                        .delete()
                        .eq('id', existing.id);

                    if (error) throw error;

                    completions = completions.filter(c => c.id !== existing.id);
                    // showToast removed
                }

                await updateStreak(habitId);
                await loadHabits();
                renderDashboard();
                refreshDebugStats();
            } catch (error) {
                console.error('‚ùå Errore toggle orario:', error);
                showToast('Errore nel salvataggio');
            }
        }

        async function toggleHabitCompletion(habitId) {
            const today = new Date().toISOString().split('T')[0];
            const existing = completions.find(c => 
                c.habit_id === habitId && c.completed_at.startsWith(today)
            );

            console.log('üîÑ Toggle completamento per habit:', habitId);

            try {
                if (existing) {
                    // Remove completion
                    console.log('‚ûñ Rimozione completamento');
                    const { error } = await supabaseClient
                        .from('hb_completions')
                        .delete()
                        .eq('id', existing.id);

                    if (error) throw error;

                    completions = completions.filter(c => c.id !== existing.id);
                    showToast('Completamento rimosso');
                } else {
                    // Add completion
                    console.log('‚ûï Aggiunta completamento');
                    const { data, error } = await supabaseClient
                        .from('hb_completions')
                        .insert([{
                            habit_id: habitId,
                            completed_at: new Date().toISOString()
                        }])
                        .select();

                    if (error) throw error;

                    completions.push(data[0]);
                    showToast('Ottimo lavoro! üéâ');
                }

                // Update streak
                await updateStreak(habitId);
                await loadHabits();
                renderDashboard();
                renderHabits();
                refreshDebugStats();
            } catch (error) {
                console.error('‚ùå Errore toggle completamento:', error);
                showToast('Errore nel salvataggio');
            }
        }

        // Helper per parsare date come locale invece di UTC
        function parseDateLocal(dateString) {
            if (!dateString) return null;
            // Se √® gi√† una stringa ISO con ore (timestamp), usa Date normale
            if (dateString.includes('T')) {
                return new Date(dateString);
            }
            // Altrimenti √® una data "YYYY-MM-DD", parsala come locale
            const parts = dateString.split('-');
            const year = parseInt(parts[0]);
            const month = parseInt(parts[1]) - 1; // 0-indexed
            const day = parseInt(parts[2]);
            const date = new Date(year, month, day, 12, 0, 0, 0); // Mezzog giorno per evitare problemi DST
            return date;
        }

        async function updateStreak(habitId) {
            const habit = habits.find(h => h.id === habitId);
            if (!habit) return;

            const habitCompletions = completions
                .filter(c => c.habit_id === habitId && c.status === 'completed') // Solo completed, non skipped
                .sort((a, b) => new Date(b.completed_at) - new Date(a.completed_at));

            let currentStreak = 0;
            
            // Data di inizio (default: data creazione)
            const startDate = parseDateLocal(habit.started_at) || new Date(habit.created_at);
            startDate.setHours(12, 0, 0, 0); // Mezzogiorno

            // SETTIMANALE: Conta settimane complete
            if (habit.frequency === 'weekly' && habit.weekdays && habit.weekdays.length > 0) {
                currentStreak = calculateWeeklyStreak(habit, habitCompletions, startDate);
            } 
            // GIORNALIERO CON ORARI MULTIPLI
            else if (habit.frequency === 'daily_multiple' && habit.daily_times && habit.daily_times.length > 0) {
                currentStreak = calculateDailyMultipleStreak(habit, habitCompletions, startDate);
            } 
            // GIORNALIERO NORMALE
            else {
                currentStreak = calculateDailyStreak(habit, habitCompletions, startDate);
            }

            const bestStreak = Math.max(currentStreak, habit.best_streak || 0);

            try {
                const { error } = await supabaseClient
                    .from('hb_habits')
                    .update({
                        current_streak: currentStreak,
                        best_streak: bestStreak
                    })
                    .eq('id', habitId);

                if (error) throw error;
                console.log(`‚úÖ Streak aggiornato: current=${currentStreak}, best=${bestStreak}`);
                
                // CONTROLLA SE STACK COMPLETATO
                if (currentStreak >= habit.goal && currentStreak > 0) {
                    console.log('üéâ STACK COMPLETATO! Assegnazione punti...');
                    await completeStack(habitId);
                }
            } catch (error) {
                console.error('Error updating streak:', error);
            }
        }
        
        async function completeStack(habitId) {
            const habit = habits.find(h => h.id === habitId);
            if (!habit) return;
            
            const todayStr = new Date().toISOString().split('T')[0];
            const pointsReward = habit.points_reward || 0;
            
            console.log(`üèÜ Stack completato! Punti: +${pointsReward}`);
            
            // Calcola statistiche stack
            const startDate = new Date(habit.started_at);
            const endDate = new Date();
            const totalDays = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24));
            
            const stackCompletions = completions.filter(c => 
                c.habit_id === habitId && 
                c.status === 'completed' &&
                new Date(c.completed_at) >= startDate
            );
            
            // Archivia stack completato
            await supabaseClient
                .from('hb_archived_stacks')
                .insert([{
                    habit_id: habitId,
                    habit_name: habit.name,
                    category_id: habit.category_id,
                    started_at: habit.started_at,
                    ended_at: todayStr,
                    final_streak: habit.current_streak,
                    total_days: totalDays,
                    total_completions: stackCompletions.length,
                    total_failures: 0,
                    points_earned: pointsReward,
                    reason: 'completato'
                }]);
            
            // Aggiorna punteggio totale
            const { data: userPointsData } = await supabaseClient
                .from('hb_user_points')
                .select('*')
                .limit(1)
                .single();
            
            if (userPointsData) {
                const newTotal = (userPointsData.total_points || 0) + pointsReward;
                await supabaseClient
                    .from('hb_user_points')
                    .update({ total_points: newTotal })
                    .eq('id', userPointsData.id);
                
                // Log transazione
                await supabaseClient
                    .from('hb_points_transactions')
                    .insert([{
                        habit_id: habitId,
                        habit_name: habit.name,
                        points_change: pointsReward,
                        reason: 'stack_completed'
                    }]);
                
                // Aggiorna sidebar
                document.getElementById('totalScore').textContent = newTotal;
            }
            
            // Reset stack per ricominciare
            await supabaseClient
                .from('hb_habits')
                .update({
                    current_streak: 0,
                    current_failures: 0,
                    started_at: todayStr
                })
                .eq('id', habitId);
            
            // Cancella completions vecchio stack
            await supabaseClient
                .from('hb_completions')
                .delete()
                .eq('habit_id', habitId)
                .gte('completed_at', `${habit.started_at}T00:00:00`)
                .lte('completed_at', `${todayStr}T23:59:59`);
            
            showToast(`üéâ Stack completato! +${pointsReward} punti!`);
            
            await loadHabits();
            await loadArchivedStacks();
            renderDashboard();
        }

        function calculateWeeklyStreak(habit, completions, startDate) {
            // Trova il luned√¨ PRECEDENTE o uguale a startDate
            const firstMonday = new Date(startDate);
            const dayOfWeek = firstMonday.getDay();
            
            // Se startDate √® gi√† Luned√¨, resta cos√¨
            // Altrimenti vai al Luned√¨ precedente
            if (dayOfWeek === 1) {
                // √à gi√† Luned√¨
                firstMonday.setHours(0, 0, 0, 0);
            } else {
                // Vai al Luned√¨ precedente
                const daysToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
                firstMonday.setDate(firstMonday.getDate() - daysToMonday);
                firstMonday.setHours(0, 0, 0, 0);
            }

            console.log(`üìÖ Calcolo streak settimanale: startDate=${startDate.toISOString().split('T')[0]}, firstMonday (primo Luned√¨ precedente)=${firstMonday.toISOString().split('T')[0]}`);

            let streak = 0;
            let checkWeekStart = new Date();
            
            // Torna indietro al luned√¨ di questa settimana
            const today = new Date();
            const todayDayOfWeek = today.getDay();
            const daysToThisMonday = todayDayOfWeek === 0 ? 6 : todayDayOfWeek - 1;
            checkWeekStart.setDate(today.getDate() - daysToThisMonday);
            checkWeekStart.setHours(0, 0, 0, 0);

            // Controlla settimane consecutive partendo da questa settimana
            // Fermati quando arrivi a firstMonday (non andare oltre)
            while (checkWeekStart >= firstMonday) {
                const weekEnd = new Date(checkWeekStart);
                weekEnd.setDate(weekEnd.getDate() + 6); // Domenica

                let weekComplete = true;
                
                // Controlla ogni giorno richiesto in questa settimana
                for (const dayNum of habit.weekdays) {
                    const dayDate = new Date(checkWeekStart);
                    const daysToAdd = dayNum === 0 ? 6 : dayNum - 1;
                    dayDate.setDate(checkWeekStart.getDate() + daysToAdd);
                    
                    const dateStr = dayDate.toISOString().split('T')[0];
                    
                    // Se il giorno √® PRIMA della data inizio, consideralo completato automaticamente
                    if (dayDate < startDate) {
                        console.log(`‚úì Giorno auto-completato (prima di startDate): ${dateStr}`);
                        continue;
                    }
                    
                    // Se il giorno √® FUTURO, la settimana non √® ancora completa
                    if (dayDate > today) {
                        weekComplete = false;
                        console.log(`‚è≠Ô∏è Giorno futuro, settimana non ancora completa: ${dateStr}`);
                        break;
                    }
                    
                    // Controlla se il giorno √® stato completato
                    const completed = completions.some(c => c.completed_at.startsWith(dateStr));
                    if (!completed) {
                        weekComplete = false;
                        console.log(`‚úó Giorno mancante: ${dateStr}`);
                        break;
                    } else {
                        console.log(`‚úì Giorno completato: ${dateStr}`);
                    }
                }
                
                if (weekComplete) {
                    streak++;
                    console.log(`‚úÖ Settimana completa: ${checkWeekStart.toISOString().split('T')[0]}, streak=${streak}`);
                } else {
                    // Settimana incompleta = streak si ferma
                    console.log(`‚ùå Settimana incompleta: ${checkWeekStart.toISOString().split('T')[0]}, streak finale=${streak}`);
                    break;
                }
                
                // Vai alla settimana precedente
                checkWeekStart.setDate(checkWeekStart.getDate() - 7);
            }

            console.log(`üèÅ Streak finale: ${streak} settimane`);
            return streak;
        }

        function calculateDailyMultipleStreak(habit, completions, startDate) {
            const requiredTimes = habit.daily_times.length;
            let streak = 0;
            let checkDate = new Date();
            checkDate.setHours(0, 0, 0, 0);

            // Non contare giorni prima della data inizio
            while (checkDate >= startDate) {
                const dateStr = checkDate.toISOString().split('T')[0];
                const completionsOnDay = completions.filter(c => c.completed_at.startsWith(dateStr));
                
                if (completionsOnDay.length >= requiredTimes) {
                    streak++;
                    checkDate.setDate(checkDate.getDate() - 1);
                } else {
                    break;
                }
            }

            return streak;
        }

        function calculateDailyStreak(habit, completions, startDate) {
            let streak = 0;
            let checkDate = new Date();
            checkDate.setHours(0, 0, 0, 0);

            // Non contare giorni prima della data inizio
            while (checkDate >= startDate) {
                const dateStr = checkDate.toISOString().split('T')[0];
                const completed = completions.some(c => c.completed_at.startsWith(dateStr));
                
                if (completed) {
                    streak++;
                    checkDate.setDate(checkDate.getDate() - 1);
                } else {
                    break;
                }
            }

            return streak;
        }

        // Rendering Functions
        async function renderDashboard() {
            await checkMissedDays();
            renderHabitsTimeline();
        }

        function renderHabitsTimeline() {
            const container = document.getElementById('habitsTimeline');
            const activeHabits = habits.filter(h => h.status === 'active');
            
            if (activeHabits.length === 0) {
                container.innerHTML = '<p style="opacity: 0.7; text-align: center; padding: 2rem;">Nessuna abitudine attiva. Crea la tua prima abitudine! üéØ</p>';
                return;
            }

            const html = activeHabits.map(habit => {
                const category = categories.find(c => c.id === habit.category_id);
                return renderHabitStack(habit, category);
            }).join('');

            container.innerHTML = `<div class="habits-timeline-container">${html}</div>`;
            
            // Auto-scroll alla prima card da completare
            setTimeout(() => {
                activeHabits.forEach(habit => {
                    scrollToFirstIncomplete(habit.id);
                });
            }, 100);
        }

        function renderHabitStack(habit, category) {
            const completedDays = getCompletedDaysCount(habit);
            const categoryColor = category?.color || '#FF3366';
            
            // Per abitudini SETTIMANALI: genera card per settimane
            if (habit.frequency === 'weekly' && habit.weekdays && habit.weekdays.length > 0) {
                return renderWeeklyHabitStack(habit, category, completedDays, categoryColor);
            }
            
            // Per abitudini GIORNALIERE: genera giorni dalla data di inizio
            const today = new Date();
            today.setHours(12, 0, 0, 0); // Mezzogiorno per evitare problemi fuso orario
            
            // Data di inizio (default: data creazione)
            const startDate = parseDateLocal(habit.started_at) || new Date(habit.created_at);
            startDate.setHours(12, 0, 0, 0); // Mezzogiorno
            
            const days = [];
            const totalDays = habit.goal || 30; // Default 30 giorni se non specificato
            
            // Genera i giorni dalla data di inizio fino a goal giorni
            for (let i = 0; i < totalDays; i++) {
                const date = new Date(startDate);
                date.setDate(startDate.getDate() + i);
                days.push(date);
            }

            const dayCards = days.map((date) => {
                const isToday = date.toISOString().split('T')[0] === today.toISOString().split('T')[0];
                return renderDayCard(habit, date, isToday);
            }).join('');

            return `
                <div class="habit-stack">
                    <div class="habit-stack-header" style="border-left-color: ${categoryColor};">
                        <div>
                            <h3 class="habit-stack-title">
                                ${category ? `${category.icon} ` : ''}${habit.name}${(() => { const pts = calculateCurrentPoints(habit); return pts > 0 ? ` <span style="display: inline-block; margin-left: 0.5rem; padding: 0.25rem 0.6rem; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border-radius: 50px; color: white; font-weight: bold; font-size: 0.75rem; vertical-align: middle;">üèÜ ${pts}</span>` : ''; })()}
                            </h3>
                            <p style="opacity: 0.7; margin: 0.3rem 0 0 0; font-size: 0.9rem;">
                                ${getFrequencyLabel(habit)}
                            </p>
                        </div>
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <div class="habit-stack-progress">
                                ${completedDays}/${habit.goal}
                                ${habit.current_streak > 0 ? `<span style="margin-left: 0.5rem;">üî• ${habit.current_streak}</span>` : ''}
                                ${habit.max_failures > 0 ? `<span style="margin-left: 0.5rem; color: #2196F3;">üÉè ${habit.max_failures - (habit.current_failures || 0)}</span>` : ''}
                            </div>
                            <button class="btn btn-secondary" onclick="showEditHabitModal('${habit.id}')" style="padding: 0.3rem 0.6rem; font-size: 0.85rem;">
                                ‚úèÔ∏è Modifica
                            </button>
                        </div>
                    </div>
                    <div class="timeline-scroll" id="timeline-${habit.id}">
                        <div class="timeline-track">
                            ${dayCards}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderWeeklyHabitStack(habit, category, completedDays, categoryColor) {
            console.log(`üìä renderWeeklyHabitStack chiamata per habit: ${habit.name}, goal: ${habit.goal}`);
            
            const today = new Date();
            today.setHours(12, 0, 0, 0); // Mezzogiorno per evitare problemi fuso orario
            
            // Data di inizio (default: data creazione)
            const startDate = parseDateLocal(habit.started_at) || new Date(habit.created_at);
            startDate.setHours(12, 0, 0, 0); // Mezzogiorno
            
            console.log(`üìÖ startDate: ${startDate.toISOString().split('T')[0]}, today: ${today.toISOString().split('T')[0]}`);
            
            // Trova il luned√¨ della settimana che CONTIENE startDate
            const firstWeekStart = new Date(startDate);
            console.log(`üîç startDate prima calcolo:`, startDate, `toISOString:`, startDate.toISOString(), `getDay():`, startDate.getDay());
            
            const dayOfWeek = firstWeekStart.getDay();
            console.log(`üîç dayOfWeek=${dayOfWeek}`);
            
            const daysToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
            console.log(`üîç daysToMonday=${daysToMonday} (formula: ${dayOfWeek} === 0 ? -6 : 1 - ${dayOfWeek})`);
            
            firstWeekStart.setDate(firstWeekStart.getDate() + daysToMonday);
            firstWeekStart.setHours(0, 0, 0, 0);
            
            console.log(`üìÖ firstWeekStart (luned√¨): ${firstWeekStart.toISOString().split('T')[0]}, getDay()=${firstWeekStart.getDay()}`);
            
            const weeks = [];
            
            // Genera le settimane dalla prima fino a goal settimane
            const totalWeeks = habit.goal || 12; // Default 12 settimane se non specificato
            
            console.log(`üìä Generando ${totalWeeks} settimane...`);
            
            for (let i = 0; i < totalWeeks; i++) {
                const weekStart = new Date(firstWeekStart);
                weekStart.setDate(firstWeekStart.getDate() + (i * 7));
                weeks.push(weekStart);
            }
            
            console.log(`‚úÖ ${weeks.length} settimane generate`);
            
            // Trova il luned√¨ di questa settimana per evidenziarlo
            const thisWeekStart = new Date(today);
            const todayDayOfWeek = today.getDay();
            const daysToThisMonday = todayDayOfWeek === 0 ? -6 : 1 - todayDayOfWeek;
            thisWeekStart.setDate(today.getDate() + daysToThisMonday);
            thisWeekStart.setHours(0, 0, 0, 0);

            const weekCards = weeks.map((weekStart) => {
                const isCurrentWeek = weekStart.getTime() === thisWeekStart.getTime();
                return renderWeekCard(habit, weekStart, isCurrentWeek);
            }).join('');

            return `
                <div class="habit-stack">
                    <div class="habit-stack-header" style="border-left-color: ${categoryColor};">
                        <div>
                            <h3 class="habit-stack-title">
                                ${category ? `${category.icon} ` : ''}${habit.name}${(() => { const pts = calculateCurrentPoints(habit); return pts > 0 ? ` <span style="display: inline-block; margin-left: 0.5rem; padding: 0.25rem 0.6rem; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border-radius: 50px; color: white; font-weight: bold; font-size: 0.75rem; vertical-align: middle;">üèÜ ${pts}</span>` : ''; })()}
                            </h3>
                            <p style="opacity: 0.7; margin: 0.3rem 0 0 0; font-size: 0.9rem;">
                                ${getFrequencyLabel(habit)}
                            </p>
                        </div>
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <div class="habit-stack-progress">
                                ${completedDays}/${habit.goal}
                                ${habit.current_streak > 0 ? `<span style="margin-left: 0.5rem;">üî• ${habit.current_streak}</span>` : ''}
                                ${habit.max_failures > 0 ? `<span style="margin-left: 0.5rem; color: #2196F3;">üÉè ${habit.max_failures - (habit.current_failures || 0)}</span>` : ''}
                            </div>
                            <button class="btn btn-secondary" onclick="showEditHabitModal('${habit.id}')" style="padding: 0.3rem 0.6rem; font-size: 0.85rem;">
                                ‚úèÔ∏è Modifica
                            </button>
                        </div>
                    </div>
                    <div class="timeline-scroll" id="timeline-${habit.id}">
                        <div class="timeline-track">
                            ${weekCards}
                        </div>
                    </div>
                </div>
            `;
        }

        function getWeekStart(referenceDate, weekOffset) {
            const date = new Date(referenceDate);
            const dayOfWeek = date.getDay();
            const diff = dayOfWeek === 0 ? -6 : 1 - dayOfWeek; // Luned√¨ come inizio settimana
            date.setDate(date.getDate() + diff + (weekOffset * 7));
            date.setHours(12, 0, 0, 0); // Mezzogiorno per evitare problemi fuso orario
            return date;
        }

        function getWeekNumber(date) {
            const firstDayOfYear = new Date(date.getFullYear(), 0, 1);
            const pastDaysOfYear = (date - firstDayOfYear) / 86400000;
            return Math.ceil((pastDaysOfYear + firstDayOfYear.getDay() + 1) / 7);
        }

        function renderWeekCard(habit, weekStart, isCurrentWeek) {
            const weekNumber = getWeekNumber(weekStart);
            const monthNames = ['GEN', 'FEB', 'MAR', 'APR', 'MAG', 'GIU', 'LUG', 'AGO', 'SET', 'OTT', 'NOV', 'DIC'];
            const dayNames = ['DOM', 'LUN', 'MAR', 'MER', 'GIO', 'VEN', 'SAB'];
            
            const today = new Date();
            today.setHours(12, 0, 0, 0); // Mezzogiorno per evitare problemi fuso orario
            
            // Calcola startDate dell'abitudine
            const startDate = parseDateLocal(habit.started_at) || new Date(habit.created_at);
            startDate.setHours(12, 0, 0, 0);
            
            const weekEnd = new Date(weekStart);
            weekEnd.setDate(weekStart.getDate() + 6);
            
            const isPast = weekEnd < today;
            const isFuture = weekStart > today;
            
            console.log(`üîç Generando settimana ${weekNumber}: weekStart=${weekStart.toISOString().split('T')[0]}, isPast=${isPast}, isFuture=${isFuture}`);
            console.log(`üîç Habit weekdays:`, habit.weekdays);
            
            // Genera i giorni della settimana che sono configurati per questa abitudine
            const weekDays = habit.weekdays.map(dayNum => {
                console.log(`üîç MAP: dayNum=${dayNum}, weekStart=${weekStart.toISOString().split('T')[0]}, weekStart.getDay()=${weekStart.getDay()}`);
                
                const date = new Date(weekStart);
                // dayNum: 0=DOM, 1=LUN, etc.
                const daysToAdd = dayNum === 0 ? 6 : dayNum - 1; // Converti in offset da luned√¨
                date.setDate(weekStart.getDate() + daysToAdd);
                date.setHours(12, 0, 0, 0); // Mezzogiorno per evitare problemi fuso orario // IMPORTANTE: normalizza a mezzanotte!
                
                const dateStr = date.toISOString().split('T')[0];
                const completion = completions.find(c => 
                    c.habit_id === habit.id && c.completed_at.startsWith(dateStr)
                );
                
                const isCompleted = completion && completion.status === 'completed';
                const isFailed = completion && completion.status === 'failed';
                
                // Usa oggi senza conversione UTC
                const todayStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
                const isToday = dateStr === todayStr;
                const dayIsPast = date < today;
                const dayIsFuture = date > today;
                const isBeforeStart = date < startDate; // Prima della data inizio stack
                
                // Pu√≤ completare SOLO se √® oggi E dopo started_at
                const canComplete = isToday && !isBeforeStart;
                
                // Debug
                if (dateStr === '2026-02-13' || dateStr === '2026-02-14' || dateStr === '2026-02-15') {
                    console.log(`üîç DEBUG: dateStr="${dateStr}", todayStr="${todayStr}", isToday=${isToday}, date=${date.toISOString()}, today=${today.toISOString()}`);
                }
                console.log(`üìÖ ${dateStr} (${dayNames[dayNum]}): canComplete=${canComplete}, isToday=${isToday}, dayIsPast=${dayIsPast}, dayIsFuture=${dayIsFuture}, isBeforeStart=${isBeforeStart}`);
                
                return {
                    date,
                    dateStr,
                    dayNum,
                    dayName: dayNames[dayNum],
                    isCompleted,
                    isFailed,
                    isToday,
                    canComplete
                };
            });
            
            const completedCount = weekDays.filter(d => d.isCompleted).length;
            const totalDays = weekDays.length;
            const allCompleted = completedCount === totalDays;
            
            const daySlots = weekDays.map(day => {
                const pastStyle = !day.isToday && !day.canComplete && !day.isCompleted && !day.isFailed ? 'opacity: 0.5; filter: grayscale(50%);' : '';
                return `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 0.6rem 0.4rem; background: var(--input-bg); margin-bottom: 0.3rem; min-width: 80px; ${day.isToday ? 'border: 2px solid var(--primary);' : ''} ${pastStyle}"
                         data-week-day="${day.dateStr}"
                         data-habit-week="${habit.id}">
                        <div class="time-text" style="margin-bottom: 0.5rem; font-weight: 600; font-size: 0.85rem;">${day.dayName}</div>
                        <div class="state-buttons" style="gap: 0.3rem;">
                            <button class="simple-btn ${day.isCompleted ? 'btn-completed' : ''}" 
                                    style="width: 35px; height: 35px; font-size: 1rem;"
                                    data-action="complete"
                                    ${!day.canComplete ? 'disabled' : ''}
                                    title="Fatto">‚úì</button>
                            <button class="simple-btn ${day.isFailed ? 'btn-failed' : ''}" 
                                    style="width: 35px; height: 35px; font-size: 1rem;"
                                    data-action="fail"
                                    ${!day.canComplete ? 'disabled' : ''}
                                    title="Saltato (Jolly)">‚úï</button>
                        </div>
                    </div>
                `;
            }).join('');

            return `
                <div class="day-card ${isCurrentWeek ? 'today' : ''} ${allCompleted ? 'completed' : ''} ${isFuture ? 'future' : ''}"
                     data-habit="${habit.id}" 
                     data-week="${weekNumber}"
                     data-completed="${allCompleted}">
                    <div class="day-card-date">
                        <div class="day-card-day">SETT. ${weekNumber}</div>
                        <div class="day-card-number">dal ${weekStart.getDate()}</div>
                        <div class="day-card-month">${monthNames[weekStart.getMonth()]}</div>
                    </div>
                    <div class="day-card-times">
                        ${daySlots}
                    </div>
                </div>
            `;
        }

        function renderDayCard(habit, date, isToday) {
            const dateStr = date.toISOString().split('T')[0];
            const dayOfWeek = date.getDay();
            const dayNames = ['DOM', 'LUN', 'MAR', 'MER', 'GIO', 'VEN', 'SAB'];
            const monthNames = ['GEN', 'FEB', 'MAR', 'APR', 'MAG', 'GIU', 'LUG', 'AGO', 'SET', 'OTT', 'NOV', 'DIC'];
            
            const isPast = date < new Date(new Date().setHours(0, 0, 0, 0));
            const isFuture = date > new Date(new Date().setHours(23, 59, 59, 999));
            
            // Controllo started_at
            const startDate = parseDateLocal(habit.started_at) || new Date(habit.created_at);
            startDate.setHours(12, 0, 0, 0);
            const dateToCheck = new Date(date);
            dateToCheck.setHours(12, 0, 0, 0);
            const isBeforeStart = dateToCheck < startDate;
            
            // Verifica se il giorno √® applicabile per questa abitudine
            const isApplicable = isDayApplicable(habit, date);
            
            if (!isApplicable) {
                return `
                    <div class="day-card" style="opacity: 0.3; cursor: not-allowed;">
                        <div class="day-card-date">
                            <div class="day-card-day">${dayNames[dayOfWeek]}</div>
                            <div class="day-card-number">${date.getDate()}</div>
                            <div class="day-card-month">${monthNames[date.getMonth()]}</div>
                        </div>
                        <div style="text-align: center; padding: 1rem; opacity: 0.5; font-size: 0.8rem;">
                            Non previsto
                        </div>
                    </div>
                `;
            }

            // Per abitudini con orari multipli
            if (habit.frequency === 'daily_multiple' && habit.daily_times && habit.daily_times.length > 0) {
                const times = habit.daily_times;
                const completionsOnDay = completions.filter(c => 
                    c.habit_id === habit.id && c.completed_at.startsWith(dateStr)
                );
                
                // Definisci isPast e isFuture per questa card
                const isPast = date < new Date(new Date().setHours(0, 0, 0, 0));
                const isFuture = date > new Date(new Date().setHours(23, 59, 59, 999));
                
                const completedTimes = completionsOnDay.map(c => {
                    return new Date(c.completed_at).toTimeString().substr(0, 5);
                });
                
                const allCompleted = completedTimes.length >= times.length;
                
                const timeSlots = times.map(time => {
                    const completion = completionsOnDay.find(c => {
                        const compTime = new Date(c.completed_at).toTimeString().substr(0, 5);
                        return compTime === time;
                    });
                    
                    const isCompleted = completion && completion.status === 'completed';
                    const isFailed = completion && completion.status === 'failed';
                    const canComplete = isToday && !isBeforeStart; // Solo oggi E dopo started_at
                    
                    return `
                        <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 0.6rem 0.4rem; background: var(--input-bg); margin-bottom: 0.3rem; min-width: 80px;"
                             data-time="${time}">
                            <div class="time-text" style="margin-bottom: 0.5rem; font-weight: 600; font-size: 0.9rem;">${time}</div>
                            <div class="state-buttons" style="gap: 0.3rem;">
                                <button class="simple-btn ${isCompleted ? 'btn-completed' : ''}" 
                                        style="width: 35px; height: 35px; font-size: 1rem;"
                                        data-action="complete"
                                        ${!canComplete || isFuture ? 'disabled' : ''}
                                        title="Fatto">‚úì</button>
                                <button class="simple-btn ${isFailed ? 'btn-failed' : ''}" 
                                        style="width: 35px; height: 35px; font-size: 1rem;"
                                        data-action="fail"
                                        ${!canComplete || isFuture ? 'disabled' : ''}
                                        title="Saltato (Jolly)">‚úï</button>
                            </div>
                        </div>
                    `;
                }).join('');

                return `
                    <div class="day-card ${isToday ? 'today' : ''} ${isPast ? 'past' : ''} ${allCompleted ? 'completed' : ''} ${isFuture ? 'future' : ''}" 
                         data-habit="${habit.id}" 
                         data-date="${dateStr}"
                         data-completed="${allCompleted}">
                        <div class="day-card-date">
                            <div class="day-card-day">${dayNames[dayOfWeek]}</div>
                            <div class="day-card-number">${date.getDate()}</div>
                            <div class="day-card-month">${monthNames[date.getMonth()]}</div>
                        </div>
                        <div class="day-card-times">
                            ${timeSlots}
                        </div>
                    </div>
                `;
            } else {
                // Abitudine normale (una volta al giorno)
                const completion = completions.find(c => 
                    c.habit_id === habit.id && c.completed_at.startsWith(dateStr)
                );
                
                const isCompleted = completion && completion.status === 'completed';
                const isFailed = completion && completion.status === 'failed';
                const canComplete = isToday && !isBeforeStart; // Solo oggi E dopo started_at

                return `
                    <div class="day-card ${isToday ? 'today' : ''} ${isCompleted ? 'completed' : ''} ${isFailed ? 'failed' : ''} ${isFuture ? 'future' : ''}"
                         data-habit="${habit.id}" 
                         data-date="${dateStr}"
                         data-can-complete="${canComplete && !isFuture}">
                        <div class="day-card-date">
                            <div class="day-card-day">${dayNames[dayOfWeek]}</div>
                            <div class="day-card-number">${date.getDate()}</div>
                            <div class="day-card-month">${monthNames[date.getMonth()]}</div>
                        </div>
                        <div class="single-completion">
                            <div class="state-buttons">
                                <button class="simple-btn ${isCompleted ? 'btn-completed' : ''}" 
                                        data-action="complete"
                                        ${!canComplete || isFuture ? 'disabled' : ''}
                                        title="Fatto">‚úì</button>
                                <button class="simple-btn ${isFailed ? 'btn-failed' : ''}" 
                                        data-action="fail"
                                        ${!canComplete || isFuture ? 'disabled' : ''}
                                        title="Saltato (Jolly)">‚úï</button>
                            </div>
                        </div>
                    </div>
                `;
            }
        }

        function isDayApplicable(habit, date) {
            const dayOfWeek = date.getDay();
            
            if (habit.frequency === 'daily' || habit.frequency === 'daily_multiple') {
                return true;
            }
            
            if (habit.frequency === 'weekly' && habit.weekdays) {
                return habit.weekdays.includes(dayOfWeek);
            }
            
            return true;
        }

        function getFrequencyLabel(habit) {
            if (habit.frequency === 'daily') {
                return 'Giornaliera';
            } else if (habit.frequency === 'daily_multiple') {
                const timesCount = habit.daily_times ? habit.daily_times.length : 0;
                return `${timesCount}x al giorno (${habit.daily_times.join(', ')})`;
            } else if (habit.frequency === 'weekly') {
                const days = ['Dom', 'Lun', 'Mar', 'Mer', 'Gio', 'Ven', 'Sab'];
                const dayNames = habit.weekdays ? habit.weekdays.map(d => days[d]).join(', ') : '';
                return `Settimanale (${dayNames})`;
            }
            return 'Personalizzata';
        }

        function getCompletedDaysCount(habit) {
            return habit.current_streak || 0;
        }

        function calculateCurrentPoints(habit) {
            const completedDays = completions.filter(c => 
                c.habit_id === habit.id && 
                c.status === 'completed'
            ).length;
            
            const pointsReward = habit.points_reward || 0;
            const goal = habit.goal || 30;
            
            if (pointsReward === 0 || completedDays === 0) return 0;
            
            // (punti_totali / obiettivo) √ó giorni_completati
            const pointsPerDay = pointsReward / goal;
            return Math.floor(pointsPerDay * completedDays);
        }

        function scrollToFirstIncomplete(habitId) {
            const timeline = document.getElementById(`timeline-${habitId}`);
            if (!timeline) return;
            
            const cards = timeline.querySelectorAll('.day-card');
            let firstIncomplete = null;
            
            // Trova la prima card non completata (oggi/questa settimana o passato)
            for (const card of cards) {
                const isCompleted = card.dataset.completed === 'true';
                const isFuture = card.classList.contains('future');
                const isToday = card.classList.contains('today');
                
                // Priorit√†: oggi/questa settimana non completata, poi qualsiasi non completata
                if (isToday && !isCompleted) {
                    firstIncomplete = card;
                    break;
                }
                
                if (!isCompleted && !isFuture && !firstIncomplete) {
                    firstIncomplete = card;
                }
            }
            
            // Se non trova nessuna card incompleta, vai a oggi/questa settimana
            if (!firstIncomplete) {
                firstIncomplete = timeline.querySelector('.day-card.today');
            }
            
            if (firstIncomplete) {
                const scrollPos = firstIncomplete.offsetLeft - (timeline.offsetWidth / 2) + (firstIncomplete.offsetWidth / 2);
                timeline.scrollTo({
                    left: scrollPos,
                    behavior: 'smooth'
                });
            }
        }

        async function setWeekDayState(habitId, dateStr, newState) {
            const existing = completions.find(c => 
                c.habit_id === habitId && c.completed_at.startsWith(dateStr)
            );

            console.log(`üéØ Imposta stato WEEK-DAY ${newState} per ${dateStr} - habit ${habitId}`);
            console.log(`üì¶ Existing prima:`, existing);

            try {
                if (newState === 'none') {
                    if (existing) {
                        // Se stavi rimuovendo un "failed", restituisci il jolly
                        if (existing.status === 'failed') {
                            console.log('üÉè [WEEKLY] Rimozione di failed ‚Üí Restituisco jolly');
                            await restoreJolly(habitId);
                        }
                        
                        const { error } = await supabaseClient
                            .from('hb_completions')
                            .delete()
                            .eq('id', existing.id);

                        if (error) throw error;

                        completions = completions.filter(c => c.id !== existing.id);
                        console.log(`‚úÖ Record eliminato, completions length: ${completions.length}`);
                        // // showToast removed // RIMOSSO
                        
                        await updateStreak(habitId);
                        await loadHabits();
                        await new Promise(resolve => setTimeout(resolve, 50));
                        updateWeekDay(habitId, dateStr, newState);
                        refreshDebugStats();
                    } else {
                        console.log('‚ö†Ô∏è Nessun record da eliminare');
                    }
                    return;
                }
                
                if (existing) {
                    if (existing.status === newState) {
                        console.log('‚ö†Ô∏è Stato gi√† impostato, ignoro');
                        return;
                    }
                    
                    const { data, error } = await supabaseClient
                        .from('hb_completions')
                        .update({ status: newState })
                        .eq('id', existing.id)
                        .select();

                    if (error) throw error;

                    const index = completions.findIndex(c => c.id === existing.id);
                    if (index !== -1) completions[index] = data[0];
                    console.log(`‚úÖ Record aggiornato a ${newState}`);
                } else {
                    const completionDateTime = `${dateStr}T12:00:00`;
                    
                    const { data, error } = await supabaseClient
                        .from('hb_completions')
                        .insert([{
                            habit_id: habitId,
                            completed_at: completionDateTime,
                            status: newState
                        }])
                        .select();

                    if (error) throw error;

                    completions.push(data[0]);
                    console.log(`‚úÖ Nuovo record creato con stato ${newState}`);
                }
                
                // Gestione jolly
                if (existing && existing.status === 'failed' && newState === 'completed') {
                    await restoreJolly(habitId);
                }
                else if (newState === 'failed') {
                    await handleFailure(habitId);
                }
                
                // showToast(newState === 'completed' ? '‚úì Fatto!' : '‚úï Fallito'); // RIMOSSO
                
                await updateStreak(habitId);
                await loadHabits();
                updateWeekDay(habitId, dateStr, newState);
                refreshDebugStats();
            } catch (error) {
                console.error('‚ùå Errore impostazione stato week-day:', error);
                showToast('Errore nel salvataggio'); // Questo lo lascio per gli errori
            }
        }

        async function setDayState(habitId, dateStr, newState) {
            const existing = completions.find(c => 
                c.habit_id === habitId && c.completed_at.startsWith(dateStr)
            );

            console.log(`üéØ [DAILY] setDayState: habit=${habitId}, date=${dateStr}, newState=${newState}`);
            console.log(`üì¶ [DAILY] existing:`, existing);
            console.log(`üì¶ [DAILY] existing?.status:`, existing?.status);

            try {
                if (newState === 'none') {
                    // Rimuovi completamento se esiste
                    if (existing) {
                        // Se stavi rimuovendo un "failed", restituisci il jolly
                        if (existing.status === 'failed') {
                            console.log('üÉè [DAILY] Rimozione di failed ‚Üí Restituisco jolly');
                            await restoreJolly(habitId);
                        }
                        
                        const { error } = await supabaseClient
                            .from('hb_completions')
                            .delete()
                            .eq('id', existing.id);

                        if (error) throw error;

                        completions = completions.filter(c => c.id !== existing.id);
                        console.log(`‚úÖ Record eliminato, completions length: ${completions.length}`);
                        // // showToast removed // RIMOSSO
                        
                        // Aggiorna solo questa card specifica
                        await updateStreak(habitId);
                        await loadHabits();
                        // Aspetta un istante per essere sicuri che completions sia aggiornato
                        await new Promise(resolve => setTimeout(resolve, 50));
                        updateSingleCard(habitId, dateStr, newState);
                        refreshDebugStats();
                    } else {
                        console.log('‚ö†Ô∏è Nessun record da eliminare');
                    }
                    return; // IMPORTANTE: return dopo aver gestito 'none'
                }
                
                // Continua solo se newState NON √® 'none'
                // Verifica lo stato attuale
                if (existing) {
                    // Se esiste gi√† con lo stesso stato, NON fare nulla
                    if (existing.status === newState) {
                        console.log('‚ö†Ô∏è Stato gi√† impostato, ignoro');
                        return;
                    }
                    
                    // Altrimenti aggiorna lo stato esistente
                    const { data, error } = await supabaseClient
                        .from('hb_completions')
                        .update({ status: newState })
                        .eq('id', existing.id)
                        .select();

                    if (error) throw error;

                    const index = completions.findIndex(c => c.id === existing.id);
                    if (index !== -1) completions[index] = data[0];
                    console.log(`‚úÖ Record aggiornato a ${newState}`);
                } else {
                    // Crea nuovo completamento
                    const completionDateTime = `${dateStr}T12:00:00`;
                    
                    const { data, error } = await supabaseClient
                        .from('hb_completions')
                        .insert([{
                            habit_id: habitId,
                            completed_at: completionDateTime,
                            status: newState
                        }])
                        .select();

                    if (error) throw error;

                    completions.push(data[0]);
                    console.log(`‚úÖ Nuovo record creato con stato ${newState}`);
                }
                
                // Gestione jolly:
                console.log(`üÉè [DAILY] Controllo jolly: existing=${!!existing}, existing.status=${existing?.status}, newState=${newState}`);
                
                // Se cambia da "failed" a "completed" ‚Üí Restituisci jolly
                if (existing && existing.status === 'failed' && newState === 'completed') {
                    console.log('‚úÖ [DAILY] Condizione RESTORE soddisfatta!');
                    await restoreJolly(habitId);
                }
                // Se √® nuovo "failed" ‚Üí Consuma jolly
                else if (newState === 'failed') {
                    console.log('‚ùå [DAILY] Condizione CONSUME soddisfatta!');
                    await handleFailure(habitId);
                }
                else {
                    console.log('‚ö™ [DAILY] Nessuna gestione jolly necessaria');
                }
                
                // showToast(newState === 'completed' ? '‚úì Fatto!' : '‚úï Fallito'); // RIMOSSO
                
                // Aggiorna solo questa card specifica
                await updateStreak(habitId);
                await loadHabits();
                updateSingleCard(habitId, dateStr, newState);
                refreshDebugStats();
            } catch (error) {
                console.error('‚ùå Errore impostazione stato:', error);
                showToast('Errore nel salvataggio');
            }
        }

        async function checkMissedDays() {
            console.log('üîç Controllo giorni mancati...');
            
            const today = new Date();
            today.setHours(12, 0, 0, 0);
            const todayStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
            
            for (const habit of habits.filter(h => h.status === 'active')) {
                try {
                    const startDate = parseDateLocal(habit.started_at);
                    if (!startDate || startDate > today) continue;
                    
                    const maxFailures = habit.max_failures || 3;
                    let missedCount = 0;
                    let autoFailedDates = [];
                    
                    // Controlla ogni giorno tra started_at e ieri
                    const currentDate = new Date(startDate);
                    
                    while (currentDate < today) {
                        const dateStr = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}-${String(currentDate.getDate()).padStart(2, '0')}`;
                        
                        // Verifica se questo giorno era previsto
                        let shouldHaveCompleted = false;
                        
                        if (habit.frequency === 'daily' || habit.frequency === 'daily_multiple') {
                            shouldHaveCompleted = true;
                        } else if (habit.frequency === 'weekly' && habit.weekdays) {
                            const dayOfWeek = currentDate.getDay();
                            shouldHaveCompleted = habit.weekdays.includes(dayOfWeek);
                        }
                        
                        if (shouldHaveCompleted) {
                            // Controlla se ha completion per questo giorno
                            const hasCompletion = completions.some(c => 
                                c.habit_id === habit.id && 
                                c.completed_at.startsWith(dateStr)
                            );
                            
                            if (!hasCompletion) {
                                missedCount++;
                                autoFailedDates.push(dateStr);
                                console.log(`‚ùå Giorno mancato: ${dateStr} per ${habit.name}`);
                            }
                        }
                        
                        // Avanza di un giorno
                        currentDate.setDate(currentDate.getDate() + 1);
                    }
                    
                    // Se ci sono giorni mancati, aggiorna current_failures
                    if (missedCount > 0) {
                        const newFailures = (habit.current_failures || 0) + missedCount;
                        
                        console.log(`‚ö†Ô∏è ${habit.name}: ${missedCount} giorni mancati, totale fallimenti: ${newFailures}/${maxFailures}`);
                        
                        // Aggiorna nel database
                        await supabaseClient
                            .from('hb_habits')
                            .update({ current_failures: newFailures })
                            .eq('id', habit.id);
                        
                        // Aggiorna locale
                        habit.current_failures = newFailures;
                        
                        // Crea record "failed" per ogni giorno mancato (opzionale, per storico)
                        for (const missedDate of autoFailedDates) {
                            await supabaseClient
                                .from('hb_completions')
                                .insert([{
                                    habit_id: habit.id,
                                    completed_at: `${missedDate}T12:00:00`,
                                    status: 'failed'
                                }]);
                        }
                        
                        // Se supera il limite ‚Üí GAME OVER
                        if (newFailures >= maxFailures) {
                            console.log(`üíÄ GAME OVER automatico per ${habit.name}`);
                            await resetStack(habit.id);
                            return; // Esci subito per mostrare il popup
                        }
                    }
                    
                } catch (error) {
                    console.error(`‚ùå Errore controllo giorni mancati per ${habit.name}:`, error);
                }
            }
            
            // Ricarica habits aggiornati
            await loadHabits();
            await loadCompletions();
            
            console.log('‚úÖ Controllo giorni mancati completato');
        }

        async function restoreJolly(habitId) {
            try {
                const habit = habits.find(h => h.id === habitId);
                if (!habit) {
                    console.error('‚ùå Habit non trovato:', habitId);
                    return;
                }
                
                const currentFailures = habit.current_failures || 0;
                
                // Non pu√≤ scendere sotto zero
                if (currentFailures <= 0) {
                    console.log('‚ö†Ô∏è Nessun jolly da restituire');
                    return;
                }
                
                const newFailures = currentFailures - 1;
                console.log(`üÉè Jolly restituito: ${currentFailures} ‚Üí ${newFailures}`);
                
                // Aggiorna current_failures
                const { data, error } = await supabaseClient
                    .from('hb_habits')
                    .update({ current_failures: newFailures })
                    .eq('id', habitId)
                    .select();
                
                if (error) {
                    console.error('‚ùå Errore restituzione jolly:', error);
                    return;
                }
                
                // Aggiorna locale
                habit.current_failures = newFailures;
                
                const maxFailures = habit.max_failures || 3;
                const remaining = maxFailures - newFailures;
                showToast(`‚úÖ Jolly restituito! Ora hai ${remaining} jolly`);
                
            } catch (error) {
                console.error('‚ùå Errore in restoreJolly:', error);
            }
        }

        async function handleFailure(habitId) {
            try {
                const habit = habits.find(h => h.id === habitId);
                if (!habit) {
                    console.error('‚ùå Habit non trovato:', habitId);
                    return;
                }
                
                const maxFailures = habit.max_failures || 3; // Default 3 se null
                const currentFailures = habit.current_failures || 0;
                const newFailures = currentFailures + 1;
                
                console.log(`‚ùå Fallimento registrato: ${newFailures}/${maxFailures}`, habit);
                
                // Aggiorna current_failures
                const { data, error } = await supabaseClient
                    .from('hb_habits')
                    .update({ current_failures: newFailures })
                    .eq('id', habitId)
                    .select();
                
                if (error) {
                    console.error('‚ùå Errore update current_failures:', error);
                    showToast('Errore aggiornamento fallimenti');
                    return;
                }
                
                // Aggiorna locale
                habit.current_failures = newFailures;
                
                // Se supera il limite, reset stack
                if (newFailures >= maxFailures) {
                    showToast(`üÉè Jolly esauriti! Stack resettato.`);
                    await resetStack(habitId);
                } else {
                    const remaining = maxFailures - newFailures;
                    showToast(`üÉè Jolly usato. Rimangono ${remaining} jolly`);
                }
            } catch (error) {
                console.error('‚ùå Errore in handleFailure:', error);
                showToast('Errore gestione fallimento');
            }
        }

        async function resetStack(habitId) {
            try {
                const habit = habits.find(h => h.id === habitId);
                if (!habit) return;
                
                // Calcola giorni totali dello stack
                const startDate = new Date(habit.started_at);
                const today = new Date();
                const daysPassed = Math.floor((today - startDate) / (1000 * 60 * 60 * 24));
                
                console.log(`üîÑ Reset stack per habit ${habitId}`);
                
                // Mostra popup GAME OVER con dati
                document.getElementById('gameOverHabitName').textContent = habit.name;
                document.getElementById('gameOverStreak').textContent = habit.current_streak || 0;
                document.getElementById('gameOverDays').textContent = daysPassed;
                
                // Suona la musica!
                playGameOverSound();
                
                // Mostra modal
                document.getElementById('gameOverModal').classList.add('active');
                
                // Salva habitId per il bottone "Ricomincia"
                window.currentResetHabitId = habitId;
                
            } catch (error) {
                console.error('‚ùå Errore in resetStack:', error);
                showToast('Errore reset stack');
            }
        }
        
        async function closeGameOver() {
            const habitId = window.currentResetHabitId;
            if (!habitId) return;
            
            try {
                const habit = habits.find(h => h.id === habitId);
                if (!habit) return;
                
                const todayStr = new Date().toISOString().split('T')[0];
                
                // Calcola statistiche dello stack da archiviare
                const startDate = new Date(habit.started_at);
                const endDate = new Date();
                const totalDays = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24));
                
                const stackCompletions = completions.filter(c => 
                    c.habit_id === habitId && 
                    c.status === 'completed' &&
                    new Date(c.completed_at) >= startDate
                );
                
                const stackFailures = completions.filter(c => 
                    c.habit_id === habitId && 
                    c.status === 'failed' &&
                    new Date(c.completed_at) >= startDate
                );
                
                console.log('üì¶ Archiving stack:', {
                    habit_name: habit.name,
                    started_at: habit.started_at,
                    ended_at: todayStr,
                    final_streak: habit.current_streak,
                    total_days: totalDays,
                    completions: stackCompletions.length,
                    failures: stackFailures.length
                });
                
                // STEP 1: Archivia lo stack vecchio
                const { data: archivedData, error: archiveError } = await supabaseClient
                    .from('hb_archived_stacks')
                    .insert([{
                        habit_id: habitId,
                        habit_name: habit.name,
                        category_id: habit.category_id,
                        started_at: habit.started_at,
                        ended_at: todayStr,
                        final_streak: habit.current_streak || 0,
                        total_days: totalDays,
                        total_completions: stackCompletions.length,
                        total_failures: stackFailures.length,
                        reason: 'jolly_esauriti'
                    }])
                    .select();
                
                if (archiveError) {
                    console.error('‚ùå Errore archiving:', archiveError);
                    showToast('Errore archiving stack');
                    return;
                }
                
                console.log('‚úÖ Stack archiviato:', archivedData);
                
                // STEP 1.5: Calcola e applica penalit√† punti
                const penalty = -(habit.points_penalty || 0); // Negativo perch√© √® una perdita
                console.log(`üíî Penalit√† punti: ${penalty}`);
                
                // Aggiorna archived stack con punti
                await supabaseClient
                    .from('hb_archived_stacks')
                    .update({ points_earned: penalty })
                    .eq('id', archivedData[0].id);
                
                // Aggiorna punteggio totale utente (se esiste tabella user_points)
                // Se non esiste ancora, salta questo step
                const { data: userPointsData } = await supabaseClient
                    .from('hb_user_points')
                    .select('*')
                    .limit(1)
                    .single();
                
                if (userPointsData) {
                    const newTotal = Math.max(0, (userPointsData.total_points || 0) + penalty);
                    await supabaseClient
                        .from('hb_user_points')
                        .update({ total_points: newTotal })
                        .eq('id', userPointsData.id);
                    
                    // Log transazione
                    await supabaseClient
                        .from('hb_points_transactions')
                        .insert([{
                            habit_id: habitId,
                            habit_name: habit.name,
                            points_change: penalty,
                            reason: 'stack_failed'
                        }]);
                    
                    console.log(`üí∞ Punteggio aggiornato: ${newTotal}`);
                    
                    // Aggiorna sidebar
                    document.getElementById('totalScore').textContent = newTotal;
                }
                
                // STEP 2: Cancella TUTTI i completions del vecchio stack
                // (da started_at fino a oggi, cos√¨ il nuovo stack parte completamente pulito)
                console.log('üßπ Cancellazione TUTTI i completions del vecchio stack...');
                const oldStartedAt = habit.started_at;
                const { error: deleteError } = await supabaseClient
                    .from('hb_completions')
                    .delete()
                    .eq('habit_id', habitId)
                    .gte('completed_at', `${oldStartedAt}T00:00:00`)
                    .lte('completed_at', `${todayStr}T23:59:59`);
                
                if (deleteError) {
                    console.error('‚ùå Errore cancellazione completions vecchio stack:', deleteError);
                    // Non bloccare il reset per questo
                } else {
                    console.log(`‚úÖ Tutti i completions dal ${oldStartedAt} al ${todayStr} cancellati`);
                }
                
                // STEP 3: Reset current_failures e current_streak, aggiorna started_at a oggi
                const { data, error } = await supabaseClient
                    .from('hb_habits')
                    .update({
                        current_failures: 0,
                        current_streak: 0,
                        started_at: todayStr
                    })
                    .eq('id', habitId)
                    .select();
                
                if (error) {
                    console.error('‚ùå Errore reset stack:', error);
                    showToast('Errore reset stack');
                    return;
                }
                
                console.log('‚úÖ Stack resettato:', data);
                
                // Chiudi modal
                document.getElementById('gameOverModal').classList.remove('active');
                
                // Ricarica tutto
                await loadHabits();
                await loadArchivedStacks();
                await loadCompletions(); // IMPORTANTE: ricarica completions aggiornati
                renderDashboard();
                renderHabits();
                
                showToast('üì¶ Stack archiviato e ripartito da zero!');
                
            } catch (error) {
                console.error('‚ùå Errore closeGameOver:', error);
                showToast('Errore reset stack');
            }
        }

        function updateSingleCard(habitId, dateStr, newState) {
            console.log(`üîÑ updateSingleCard: habit=${habitId}, date=${dateStr}, newState=${newState}`);
            
            const card = document.querySelector(`[data-habit="${habitId}"][data-date="${dateStr}"]`);
            if (!card) {
                console.log('‚ö†Ô∏è Card non trovata');
                return;
            }

            const completion = completions.find(c => 
                c.habit_id === habitId && c.completed_at.startsWith(dateStr)
            );
            
            const isCompleted = completion && completion.status === 'completed';
            const isFailed = completion && completion.status === 'failed';

            console.log(`üìä Stato: isCompleted=${isCompleted}, isFailed=${isFailed}`);

            // Aggiorna classi card
            card.classList.remove('completed', 'failed');
            if (isCompleted) card.classList.add('completed');
            if (isFailed) card.classList.add('failed');

            // Aggiorna bottoni
            const btnComplete = card.querySelector('[data-action="complete"]');
            const btnSkip = card.querySelector('[data-action="fail"]');
            
            if (btnComplete) {
                btnComplete.classList.remove('btn-completed');
                if (isCompleted) btnComplete.classList.add('btn-completed');
            }
            
            if (btnSkip) {
                btnSkip.classList.remove('btn-failed');
                if (isFailed) btnSkip.classList.add('btn-failed');
            }

            updateHabitHeader(habitId);
            console.log(`‚úÖ Card aggiornata`);
        }

        function updateWeekDay(habitId, dateStr, newState) {
            console.log(`üîÑ updateWeekDay: habit=${habitId}, date=${dateStr}, newState=${newState}`);
            
            // Cerca il week-day specifico usando ENTRAMBI habit e data
            const weekDay = document.querySelector(`[data-week-day="${dateStr}"][data-habit-week="${habitId}"]`);
            
            if (!weekDay) {
                console.log('‚ö†Ô∏è Week-day non trovato per habit', habitId, 'date', dateStr);
                return;
            }

            const completion = completions.find(c => 
                c.habit_id === habitId && c.completed_at.startsWith(dateStr)
            );
            
            const isCompleted = completion && completion.status === 'completed';
            const isFailed = completion && completion.status === 'failed';

            console.log(`üìä Stato week-day: isCompleted=${isCompleted}, isFailed=${isFailed}`);

            // Aggiorna bottoni del week-day
            const btnComplete = weekDay.querySelector('[data-action="complete"]');
            const btnSkip = weekDay.querySelector('[data-action="fail"]');
            
            if (btnComplete) {
                btnComplete.classList.remove('btn-completed');
                if (isCompleted) btnComplete.classList.add('btn-completed');
            }
            
            if (btnSkip) {
                btnSkip.classList.remove('btn-failed');
                if (isFailed) btnSkip.classList.add('btn-failed');
            }

            // Aggiorna lo stato della card settimana se tutti i giorni sono completati
            const card = weekDay.closest('.day-card');
            if (card) {
                const habit = habits.find(h => h.id === habitId);
                if (habit && habit.weekdays) {
                    // Cerca solo i week-days di QUESTA abitudine
                    const weekDaysInCard = card.querySelectorAll(`[data-habit-week="${habitId}"]`);
                    let allCompleted = true;
                    
                    weekDaysInCard.forEach(wd => {
                        const dateStr = wd.dataset.weekDay;
                        const comp = completions.find(c => 
                            c.habit_id === habitId && 
                            c.completed_at.startsWith(dateStr) &&
                            c.status === 'completed'
                        );
                        if (!comp) allCompleted = false;
                    });
                    
                    card.classList.remove('completed', 'failed');
                    if (allCompleted) card.classList.add('completed');
                }
            }

            updateHabitHeader(habitId);
            console.log(`‚úÖ Week-day aggiornato`);
        }

        function updateHabitHeader(habitId) {
            const habit = habits.find(h => h.id === habitId);
            if (!habit) return;

            const timeline = document.getElementById(`timeline-${habitId}`);
            if (!timeline) return;

            const stack = timeline.closest('.habit-stack');
            if (!stack) return;

            const progressEl = stack.querySelector('.habit-stack-progress');
            if (progressEl) {
                const completedDays = habit.current_streak || 0;
                progressEl.innerHTML = `
                    ${completedDays}/${habit.goal}
                    ${habit.current_streak > 0 ? `<span style="margin-left: 0.5rem;">üî• ${habit.current_streak}</span>` : ''}
                                ${habit.max_failures > 0 ? `<span style="margin-left: 0.5rem; color: #2196F3;">üÉè ${habit.max_failures - (habit.current_failures || 0)}</span>` : ''}
                `;
            }
        }

        async function toggleDayCompletion(habitId, dateStr) {
            const existing = completions.find(c => 
                c.habit_id === habitId && c.completed_at.startsWith(dateStr)
            );

            console.log(`üîÑ Toggle 3-state per ${dateStr} - habit ${habitId}`);

            try {
                if (!existing) {
                    // Stato 0 ‚Üí Stato 1: NON FATTO ‚Üí FATTO (verde)
                    const completionDateTime = `${dateStr}T12:00:00`;
                    
                    const { data, error } = await supabaseClient
                        .from('hb_completions')
                        .insert([{
                            habit_id: habitId,
                            completed_at: completionDateTime,
                            status: 'completed'
                        }])
                        .select();

                    if (error) throw error;

                    completions.push(data[0]);
                    showToast('‚úì Completato!');
                } else if (existing.status === 'completed') {
                    // Stato 1 ‚Üí Stato 2: FATTO ‚Üí DIMENTICATO (rosso)
                    const { data, error } = await supabaseClient
                        .from('hb_completions')
                        .update({ status: 'failed' })
                        .eq('id', existing.id)
                        .select();

                    if (error) throw error;

                    const index = completions.findIndex(c => c.id === existing.id);
                    if (index !== -1) completions[index] = data[0];
                    
                    showToast('‚äó Dimenticato');
                } else {
                    // Stato 2 ‚Üí Stato 0: DIMENTICATO ‚Üí NON FATTO (rimuovi)
                    const { error } = await supabaseClient
                        .from('hb_completions')
                        .delete()
                        .eq('id', existing.id);

                    if (error) throw error;

                    completions = completions.filter(c => c.id !== existing.id);
                    // showToast removed
                }

                await updateStreak(habitId);
                await loadHabits();
                renderDashboard();
                refreshDebugStats();
            } catch (error) {
                console.error('‚ùå Errore toggle:', error);
                showToast('Errore nel salvataggio');
            }
        }

        function renderHabits() {
            const filter = document.getElementById('filterStatus')?.value || 'active';
            const categoryFilter = document.getElementById('filterCategory')?.value || '';

            let filtered = habits;
            
            if (filter !== 'all') {
                filtered = filtered.filter(h => h.status === filter);
            }

            if (categoryFilter) {
                filtered = filtered.filter(h => h.category_id === categoryFilter);
            }

            if (filtered.length === 0) {
                document.getElementById('habitsList').innerHTML = '<p style="opacity: 0.7;">Nessuna abitudine trovata</p>';
                return;
            }

            const html = filtered.map(habit => {
                const category = categories.find(c => c.id === habit.category_id);
                const completionCount = completions.filter(c => c.habit_id === habit.id).length;
                
                // Calcola la frequenza descrittiva
                let frequencyLabel = '';
                if (habit.frequency === 'daily') {
                    frequencyLabel = 'üìÖ Giornaliera';
                } else if (habit.frequency === 'daily_multiple') {
                    const timesCount = habit.daily_times ? habit.daily_times.length : 0;
                    frequencyLabel = `üïê ${timesCount}x al giorno`;
                } else if (habit.frequency === 'weekly') {
                    frequencyLabel = 'üìÜ Settimanale';
                } else {
                    frequencyLabel = 'üîÑ Personalizzata';
                }

                return `
                    <div class="card">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 1rem;">
                            <div>
                                <h3 style="margin-bottom: 0.5rem;">${habit.name}</h3>
                                ${habit.description ? `<p style="opacity: 0.7;">${habit.description}</p>` : ''}
                                ${category ? `<span class="category-pill" style="background: ${category.color}">${category.icon} ${category.name}</span>` : ''}
                                ${habit.frequency === 'daily_multiple' && habit.daily_times ? `
                                    <div style="margin-top: 0.5rem; padding: 0.5rem; background: var(--input-bg); border-left: 3px solid var(--accent);">
                                        <strong style="font-size: 0.9rem; color: var(--accent);">Orari: </strong>
                                        ${habit.daily_times.map(t => `<span style="font-size: 0.85rem; opacity: 0.8;">üïê ${t}</span>`).join(' ‚Ä¢ ')}
                                    </div>
                                ` : ''}
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 0.9rem; opacity: 0.7;">${frequencyLabel}</div>
                                ${habit.current_streak > 0 ? `<span class="habit-streak">üî• ${habit.current_streak}</span>` : ''}
                            </div>
                        </div>
                        <div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 1rem;">
                            <div style="flex: 1;">
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: ${(habit.current_streak / habit.goal) * 100}%">
                                        ${Math.round((habit.current_streak / habit.goal) * 100)}%
                                    </div>
                                </div>
                                <p style="opacity: 0.7; font-size: 0.9rem;">Obiettivo: ${habit.goal} giorni | Completamenti: ${completionCount}</p>
                            </div>
                        </div>
                        <div style="display: flex; justify-content: flex-end; gap: 0.5rem;">
                            <button class="btn btn-secondary" onclick="showEditHabitModal('${habit.id}')">MODIFICA</button>
                            <button class="btn btn-danger" onclick="deleteHabit('${habit.id}')">ELIMINA</button>
                        </div>
                    </div>
                `;
            }).join('');

            document.getElementById('habitsList').innerHTML = html;
        }

        function renderStats() {
            // Detailed Stats
            const totalCompletions = completions.length;
            const activeHabits = habits.filter(h => h.status === 'active').length;
            const totalStreak = habits.reduce((sum, h) => sum + (h.current_streak || 0), 0);
            const avgStreak = activeHabits > 0 ? Math.round(totalStreak / activeHabits) : 0;

            const statsHtml = `
                <div class="stat-card">
                    <div class="stat-value">${totalCompletions}</div>
                    <div class="stat-label">Completamenti Totali</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${avgStreak}</div>
                    <div class="stat-label">Streak Media</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${activeHabits}</div>
                    <div class="stat-label">Abitudini Attive</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${categories.length}</div>
                    <div class="stat-label">Categorie</div>
                </div>
            `;
            document.getElementById('detailedStats').innerHTML = statsHtml;

            // Monthly Chart
            renderMonthlyChart();

            // Habits Ranking
            const sorted = [...habits].sort((a, b) => 
                (b.current_streak || 0) - (a.current_streak || 0)
            );

            const rankingHtml = sorted.slice(0, 10).map((habit, index) => {
                const category = categories.find(c => c.id === habit.category_id);
                const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
                
                return `
                    <div class="card" style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <span style="font-size: 1.5rem; font-weight: 900;">${medal}</span>
                            <div>
                                <h3 style="margin-bottom: 0.3rem;">${habit.name}</h3>
                                ${category ? `<span class="category-pill" style="background: ${category.color}">${category.icon} ${category.name}</span>` : ''}
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 1.5rem; font-weight: 900; color: var(--primary);">${habit.current_streak || 0}</div>
                            <div style="opacity: 0.7; font-size: 0.9rem;">giorni</div>
                        </div>
                    </div>
                `;
            }).join('');

            document.getElementById('habitsRanking').innerHTML = rankingHtml || '<p style="opacity: 0.7;">Nessuna abitudine disponibile</p>';
        }

        function renderMonthlyChart() {
            const now = new Date();
            const months = [];
            
            for (let i = 5; i >= 0; i--) {
                const date = new Date(now.getFullYear(), now.getMonth() - i, 1);
                const monthStr = date.toISOString().slice(0, 7);
                const count = completions.filter(c => c.completed_at.startsWith(monthStr)).length;
                months.push({
                    label: date.toLocaleDateString('it-IT', { month: 'short' }),
                    count
                });
            }

            const maxCount = Math.max(...months.map(m => m.count), 1);

            const html = `
                <div class="chart-bars">
                    ${months.map(m => `
                        <div style="flex: 1; display: flex; flex-direction: column; align-items: center;">
                            <div class="chart-bar-value">${m.count}</div>
                            <div class="chart-bar" style="height: ${(m.count / maxCount) * 100}%;"></div>
                            <div class="chart-bar-label">${m.label}</div>
                        </div>
                    `).join('')}
                </div>
            `;

            document.getElementById('monthlyChart').innerHTML = html;
        }

        function renderCategories() {
            // Aggiungi conteggio abitudini per ordinamento
            const categoriesWithCount = categories.map(cat => {
                const habitCount = habits.filter(h => h.category_id === cat.id && h.status === 'active').length;
                return { ...cat, habitCount };
            });
            
            // Ordina per numero abitudini (decrescente)
            categoriesWithCount.sort((a, b) => b.habitCount - a.habitCount);
            
            const html = categoriesWithCount.map(cat => {
                const habitCount = cat.habitCount;
                const canDelete = habitCount === 0;
                
                return `
                    <div class="card" style="background: white; border-radius: 0; padding: 0.75rem; margin-bottom: 1rem; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
                        <!-- Header: icona + nome + info -->
                        <div style="display: flex; justify-content: space-between; align-items: center; gap: 1rem; margin-bottom: 0.75rem;">
                            <div style="display: flex; align-items: center; gap: 0.75rem; flex: 1; min-width: 0;">
                                <div style="width: 44px; height: 44px; background: ${cat.color}; border-radius: 0; display: flex; align-items: center; justify-content: center; font-size: 1.3rem; flex-shrink: 0;">
                                    ${cat.icon}
                                </div>
                                <div style="min-width: 0;">
                                    <h3 style="margin: 0; font-size: 1.1rem; color: #333; font-weight: 700; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${cat.name}</h3>
                                    <p style="margin: 0.15rem 0 0 0; opacity: 0.6; font-size: 0.8rem;">${habitCount} ${habitCount === 1 ? 'abitudine' : 'abitudini'}</p>
                                </div>
                            </div>
                            <div style="padding: 0.4rem 0.8rem; background: ${cat.color}20; border-radius: 20px;">
                                <span style="color: ${cat.color}; font-weight: 700; font-size: 0.9rem;">${cat.color}</span>
                            </div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div style="display: flex; gap: 0.8rem; justify-content: flex-start; align-items: center; flex-wrap: wrap;">
                            <button onclick="viewCategoryHabits('${cat.id}')" style="
                                background: var(--accent);
                                color: white;
                                border: none;
                                padding: 0.5rem 1rem;
                                border-radius: 0;
                                font-size: 0.9rem;
                                font-weight: 600;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                white-space: nowrap;
                            " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
                                üìã Vedi Abitudini
                            </button>
                            <button onclick="editCategory('${cat.id}')" style="
                                background: var(--primary);
                                color: white;
                                border: none;
                                padding: 0.5rem 1rem;
                                border-radius: 0;
                                font-size: 0.9rem;
                                font-weight: 600;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                white-space: nowrap;
                            " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
                                ‚úèÔ∏è Modifica
                            </button>
                            ${canDelete ? 
                                `<button onclick="deleteCategory('${cat.id}')" style="
                                    background: var(--danger);
                                    color: white;
                                    border: none;
                                    padding: 0.5rem 1rem;
                                    border-radius: 0;
                                    font-size: 0.9rem;
                                    font-weight: 600;
                                    cursor: pointer;
                                    transition: all 0.2s ease;
                                    white-space: nowrap;
                                " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
                                    üóëÔ∏è Elimina
                                </button>` :
                                `<button disabled title="Ci sono abitudini associate" style="
                                    background: #D1D5DB;
                                    color: #9CA3AF;
                                    border: none;
                                    padding: 0.5rem 1rem;
                                    border-radius: 0;
                                    font-size: 0.9rem;
                                    font-weight: 600;
                                    cursor: not-allowed;
                                    white-space: nowrap;
                                ">
                                    üóëÔ∏è Elimina
                                </button>`
                            }
                        </div>
                    </div>
                `;
            }).join('');
            
            if (categoriesWithCount.length === 0) {
                document.getElementById('categoriesList').innerHTML = '<p style="opacity: 0.7; text-align: center; padding: 2rem;">Nessuna categoria creata. Crea la tua prima categoria!</p>';
                return;
            }
            
            document.getElementById('categoriesList').innerHTML = html;
        }

        // UI Functions
        function showPage(pageName) {
            // Hide all pages
            document.querySelectorAll('.page').forEach(page => {
                page.style.display = 'none';
            });

            // Show selected page
            document.getElementById(`page-${pageName}`).style.display = 'block';

            // Update active nav item (sidebar)
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Find and activate the clicked nav item
            const clickedItem = document.querySelector(`.nav-item[onclick="showPage('${pageName}')"]`);
            if (clickedItem) {
                clickedItem.classList.add('active');
            }

            // Update active bottom nav item (mobile)
            document.querySelectorAll('.bottom-nav-item').forEach(item => {
                item.classList.remove('active');
            });
            const bottomNavItem = document.querySelector(`.bottom-nav-item[data-page="${pageName}"]`);
            if (bottomNavItem) {
                bottomNavItem.classList.add('active');
            }

            // Render page content
            switch(pageName) {
                case 'dashboard':
                    renderDashboard();
                    break;
                case 'habits':
                    renderHabits();
                    updateCategorySelects();
                    break;
                case 'calendar':
                    renderCalendar();
                    break;
                case 'archive':
                    renderArchive();
                    break;
                case 'stats':
                    renderStats();
                    break;
                case 'categories':
                    renderCategories();
                    break;
            }
        }
        
        function editCategory(categoryId) {
            const cat = categories.find(c => c.id === categoryId);
            if (!cat) return;
            
            // Popola il modal di modifica
            document.getElementById('editCategoryId').value = cat.id;
            document.getElementById('editCategoryName').value = cat.name;
            document.getElementById('editCategoryIcon').value = cat.icon;
            document.getElementById('editCategoryColor').value = cat.color;
            
            // Seleziona il colore attuale
            document.querySelectorAll('#editCategoryModal .color-option').forEach(opt => {
                opt.classList.remove('selected');
                const optColor = window.getComputedStyle(opt).backgroundColor;
                const hex = rgbToHex(optColor);
                if (hex === cat.color.toUpperCase()) {
                    opt.classList.add('selected');
                }
            });
            
            document.getElementById('editCategoryModal').classList.add('active');
        }
        
        async function updateCategory(event) {
            event.preventDefault();
            
            const id = document.getElementById('editCategoryId').value;
            const name = document.getElementById('editCategoryName').value;
            const icon = document.getElementById('editCategoryIcon').value || 'üìå';
            const color = document.getElementById('editCategoryColor').value;
            
            console.log('‚úèÔ∏è Aggiornamento categoria:', { id, name, icon, color });
            
            try {
                const { data, error } = await supabaseClient
                    .from('cm_categories')
                    .update({ name, icon, color })
                    .eq('id', id)
                    .select();
                
                if (error) throw error;
                
                const index = categories.findIndex(c => c.id === id);
                if (index !== -1 && data) {
                    categories[index] = data[0];
                }
                
                console.log('‚úÖ Categoria aggiornata');
                closeModal('editCategoryModal');
                showToast('Categoria aggiornata con successo! ‚ú®');
                renderCategories();
                updateCategorySelects();
                refreshDebugStats();
            } catch (error) {
                console.error('‚ùå Errore aggiornamento categoria:', error);
                showToast('Errore nell\'aggiornamento della categoria');
            }
        }
        
        function viewCategoryHabits(categoryId) {
            const cat = categories.find(c => c.id === categoryId);
            if (!cat) return;
            
            const categoryHabits = habits.filter(h => 
                h.category_id === categoryId && h.status === 'active'
            );
            
            let html = `
                <div style="margin-bottom: 2rem; padding: 1.5rem; background: ${cat.color}10; border-left: 4px solid ${cat.color};">
                    <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem;">
                        <div style="width: 50px; height: 50px; background: ${cat.color}; display: flex; align-items: center; justify-content: center; font-size: 1.8rem;">
                            ${cat.icon}
                        </div>
                        <div>
                            <h2 style="margin: 0; color: ${cat.color};">${cat.name}</h2>
                            <p style="margin: 0.3rem 0 0 0; opacity: 0.7;">${categoryHabits.length} ${categoryHabits.length === 1 ? 'abitudine' : 'abitudini'}</p>
                        </div>
                    </div>
                    <div style="display: flex; gap: 2rem; margin-top: 1rem;">
                        <div>
                            <span style="font-weight: 700;">Colore:</span>
                            <div style="display: inline-block; width: 24px; height: 24px; background: ${cat.color}; margin-left: 0.5rem; vertical-align: middle;"></div>
                            <span style="margin-left: 0.5rem; opacity: 0.7;">${cat.color}</span>
                        </div>
                    </div>
                </div>
                
                <h3 style="margin-bottom: 1rem; color: var(--accent);">üìã Abitudini in questa categoria:</h3>
            `;
            
            if (categoryHabits.length === 0) {
                html += '<p style="opacity: 0.7; text-align: center; padding: 2rem;">Nessuna abitudine in questa categoria</p>';
            } else {
                html += categoryHabits.map(habit => {
                    const completionCount = completions.filter(c => c.habit_id === habit.id).length;
                    return `
                        <div class="card" style="cursor: pointer; margin-bottom: 1rem;" onclick="closeViewCategoryModal()">
                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                <div style="flex: 1;">
                                    <h3 style="margin-bottom: 0.5rem;">${habit.name}</h3>
                                    ${habit.description ? `<p style="opacity: 0.7; margin-bottom: 0.5rem;">${habit.description}</p>` : ''}
                                    <div style="display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
                                        <span style="font-size: 0.85rem; opacity: 0.7;">
                                            üìÖ ${habit.frequency === 'daily' ? 'Giornaliera' : 'Settimanale'}
                                        </span>
                                        ${habit.current_streak > 0 ? `
                                            <span style="background: var(--warning); color: white; padding: 0.2rem 0.6rem; font-size: 0.85rem; font-weight: 700;">
                                                üî• ${habit.current_streak} giorni
                                            </span>
                                        ` : ''}
                                        <span style="font-size: 0.85rem; opacity: 0.7;">
                                            ‚úì ${completionCount} completamenti
                                        </span>
                                    </div>
                                </div>
                            </div>
                            <div style="margin-top: 1rem;">
                                <div class="progress-bar" style="height: 20px;">
                                    <div class="progress-fill" style="width: ${(habit.current_streak / habit.goal) * 100}%; font-size: 0.8rem;">
                                        ${Math.round((habit.current_streak / habit.goal) * 100)}%
                                    </div>
                                </div>
                                <p style="opacity: 0.6; font-size: 0.85rem; margin-top: 0.5rem;">Obiettivo: ${habit.goal} giorni</p>
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            document.getElementById('viewCategoryContent').innerHTML = html;
            document.getElementById('viewCategoryModal').classList.add('active');
        }
        
        function closeViewCategoryModal() {
            document.getElementById('viewCategoryModal').classList.remove('active');
        }
        
        function editHabit(habitId) {
            // TODO: Implementare modal di modifica abitudini
            showToast('Funzione modifica abitudine in sviluppo üöß');
            console.log('Edit habit requested for:', habitId);
        }

        function showEditHabitModal(habitId) {
            const habit = habits.find(h => h.id === habitId);
            if (!habit) return;
            
            // Popola i campi
            document.getElementById('editHabitId').value = habit.id;
            document.getElementById('editHabitName').value = habit.name;
            document.getElementById('editHabitDescription').value = habit.description || '';
            document.getElementById('editHabitCategory').value = habit.category_id || '';
            document.getElementById('editHabitFrequency').value = habit.frequency;
            document.getElementById('editHabitGoal').value = habit.goal;
            document.getElementById('editHabitMaxFailures').value = habit.max_failures || 3;
            document.getElementById('editHabitStartDate').value = habit.started_at || new Date().toISOString().split('T')[0];
            
            // Gestisci orari multipli
            editDailyTimes = habit.daily_times ? [...habit.daily_times] : [];
            updateEditDailyTimesList();
            
            // Gestisci giorni settimanali
            document.querySelectorAll('input[name="editWeekday"]').forEach(cb => {
                cb.checked = habit.weekdays && habit.weekdays.includes(parseInt(cb.value));
            });
            
            // Mostra/nascondi sezioni
            handleEditFrequencyChange();
            
            // Aggiorna select categorie
            updateEditCategorySelect();
            
            document.getElementById('editHabitModal').classList.add('active');
        }
        
        let editDailyTimes = [];
        
        function addEditDailyTime() {
            const timeInput = document.getElementById('editNewDailyTime');
            const time = timeInput.value;
            if (time && !editDailyTimes.includes(time)) {
                editDailyTimes.push(time);
                editDailyTimes.sort();
                updateEditDailyTimesList();
                timeInput.value = '';
            }
        }
        
        function removeEditDailyTime(time) {
            editDailyTimes = editDailyTimes.filter(t => t !== time);
            updateEditDailyTimesList();
        }
        
        function updateEditDailyTimesList() {
            const list = document.getElementById('editDailyTimesList');
            if (editDailyTimes.length === 0) {
                list.innerHTML = '<p style="opacity: 0.6; font-size: 0.9rem;">Nessun orario aggiunto</p>';
            } else {
                list.innerHTML = editDailyTimes.map(time => `
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 0.5rem; background: var(--input-bg); margin-bottom: 0.3rem;">
                        <span>${time}</span>
                        <button type="button" class="btn btn-secondary" onclick="removeEditDailyTime('${time}')" style="padding: 0.2rem 0.5rem;">‚úï</button>
                    </div>
                `).join('');
            }
        }
        
        function handleEditFrequencyChange() {
            const frequency = document.getElementById('editHabitFrequency').value;
            document.getElementById('editDailyTimesSection').style.display = frequency === 'daily_multiple' ? 'block' : 'none';
            document.getElementById('editWeekdaysSection').style.display = frequency === 'weekly' ? 'block' : 'none';
        }
        
        function updateEditCategorySelect() {
            const select = document.getElementById('editHabitCategory');
            const currentValue = select.value;
            select.innerHTML = '<option value="">Nessuna categoria</option>' + 
                categories.map(cat => `<option value="${cat.id}">${cat.icon} ${cat.name}</option>`).join('');
            select.value = currentValue;
        }
        
        document.getElementById('editHabitFrequency').addEventListener('change', handleEditFrequencyChange);
        
        document.getElementById('editHabitForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const habitId = document.getElementById('editHabitId').value;
            const name = document.getElementById('editHabitName').value;
            const description = document.getElementById('editHabitDescription').value;
            const categoryId = document.getElementById('editHabitCategory').value || null;
            const frequency = document.getElementById('editHabitFrequency').value;
            const goal = parseInt(document.getElementById('editHabitGoal').value);
            const maxFailures = parseInt(document.getElementById('editHabitMaxFailures').value);
            const startedAt = document.getElementById('editHabitStartDate').value;
            
            let weekdays = null;
            let daily_times = null;
            
            if (frequency === 'daily_multiple') {
                if (editDailyTimes.length === 0) {
                    showToast('Aggiungi almeno un orario');
                    return;
                }
                daily_times = [...editDailyTimes];
            }
            
            if (frequency === 'weekly') {
                const selected = Array.from(document.querySelectorAll('input[name="editWeekday"]:checked'))
                    .map(cb => parseInt(cb.value));
                if (selected.length === 0) {
                    showToast('Seleziona almeno un giorno');
                    return;
                }
                weekdays = selected;
            }
            
            try {
                const { data, error } = await supabaseClient
                    .from('hb_habits')
                    .update({
                        name,
                        description,
                        category_id: categoryId,
                        frequency,
                        weekdays,
                        daily_times,
                        started_at: startedAt,
                        goal,
                        max_failures: maxFailures
                    })
                    .eq('id', habitId)
                    .select();
                
                if (error) throw error;
                
                // Aggiorna array locale
                const index = habits.findIndex(h => h.id === habitId);
                if (index !== -1) {
                    habits[index] = data[0];
                    // Converti weekdays da stringhe a numeri
                    if (habits[index].weekdays && Array.isArray(habits[index].weekdays)) {
                        habits[index].weekdays = habits[index].weekdays.map(day => parseInt(day));
                    }
                }
                
                closeModal('editHabitModal');
                showToast('Abitudine aggiornata! üéâ');
                renderDashboard();
                renderHabits();
            } catch (error) {
                console.error('‚ùå Errore aggiornamento:', error);
                showToast('Errore nell\'aggiornamento');
            }
        });

        function showAddHabitModal() {
            updateCategorySelects();
            // Imposta data di oggi come default
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('habitStartDate').value = today;
            document.getElementById('addHabitModal').classList.add('active');
        }

        function showAddCategoryModal() {
            document.getElementById('addCategoryModal').classList.add('active');
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        function toggleSidebar() {
            document.getElementById('sidebar').classList.toggle('active');
        }

        function playGameOverSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Sequenza di note discendenti (game over classico)
                const notes = [
                    { freq: 392, duration: 0.15 },  // G
                    { freq: 370, duration: 0.15 },  // F#
                    { freq: 349, duration: 0.15 },  // F
                    { freq: 330, duration: 0.15 },  // E
                    { freq: 311, duration: 0.3 },   // D#
                    { freq: 294, duration: 0.3 },   // D
                    { freq: 277, duration: 0.5 }    // C#
                ];
                
                let startTime = audioContext.currentTime;
                
                notes.forEach((note, index) => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = note.freq;
                    oscillator.type = 'square'; // Suono retro 8-bit
                    
                    gainNode.gain.setValueAtTime(0.3, startTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + note.duration);
                    
                    oscillator.start(startTime);
                    oscillator.stop(startTime + note.duration);
                    
                    startTime += note.duration;
                });
            } catch (error) {
                console.error('Errore audio:', error);
            }
        }

        function showToast(message) {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        function updateCategorySelects() {
            const selects = [
                document.getElementById('habitCategory'),
                document.getElementById('filterCategory')
            ];

            selects.forEach(select => {
                if (!select) return;
                
                const currentValue = select.value;
                const isFilter = select.id === 'filterCategory';
                
                select.innerHTML = isFilter ? 
                    '<option value="">Tutte le categorie</option>' : 
                    '<option value="">Nessuna categoria</option>';
                
                categories.forEach(cat => {
                    const option = document.createElement('option');
                    option.value = cat.id;
                    option.textContent = `${cat.icon} ${cat.name}`;
                    select.appendChild(option);
                });
                
                select.value = currentValue;
            });
        }

        function filterHabits() {
            renderHabits();
        }

        async function deleteHabit(habitId) {
            if (!confirm('Sei sicuro di voler eliminare questa abitudine?')) return;

            try {
                // Delete completions first
                await supabaseClient.from('hb_completions').delete().eq('habit_id', habitId);
                
                // Delete habit
                const { error } = await supabaseClient.from('hb_habits').delete().eq('id', habitId);
                if (error) throw error;

                habits = habits.filter(h => h.id !== habitId);
                completions = completions.filter(c => c.habit_id !== habitId);
                
                showToast('Abitudine eliminata');
                renderHabits();
                renderDashboard();
            } catch (error) {
                console.error('Error deleting habit:', error);
                showToast('Errore nell\'eliminazione');
            }
        }

        async function deleteCategory(categoryId) {
            if (!confirm('Sei sicuro di voler eliminare questa categoria?')) return;

            try {
                const { error } = await supabaseClient.from('cm_categories').delete().eq('id', categoryId);
                if (error) throw error;

                categories = categories.filter(c => c.id !== categoryId);
                
                // Update habits that had this category
                habits.forEach(h => {
                    if (h.category_id === categoryId) {
                        h.category_id = null;
                    }
                });

                showToast('Categoria eliminata');
                renderCategories();
            } catch (error) {
                console.error('Error deleting category:', error);
                showToast('Errore nell\'eliminazione');
            }
        }

        function setupEventListeners() {
            // Frequency change
            const freqSelect = document.getElementById('habitFrequency');
            if (freqSelect) {
                freqSelect.addEventListener('change', (e) => {
                    const weekdaysGroup = document.getElementById('weekdaysGroup');
                    const dailyTimesGroup = document.getElementById('dailyTimesGroup');
                    
                    // Nascondi tutti
                    weekdaysGroup.style.display = 'none';
                    dailyTimesGroup.style.display = 'none';
                    
                    // Mostra il gruppo appropriato
                    if (e.target.value === 'weekly') {
                        weekdaysGroup.style.display = 'block';
                    } else if (e.target.value === 'daily_multiple') {
                        dailyTimesGroup.style.display = 'block';
                    }
                });
            }

            // Close modals on outside click
            document.querySelectorAll('.modal').forEach(modal => {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.classList.remove('active');
                    }
                });
            });
            
            // Color picker click handling
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('color-option')) {
                    const style = window.getComputedStyle(e.target);
                    const color = style.backgroundColor;
                    // Convert rgb to hex
                    const hex = rgbToHex(color);
                    
                    // Determina quale modal √® aperto
                    const addModal = document.getElementById('addCategoryModal');
                    const editModal = document.getElementById('editCategoryModal');
                    
                    if (addModal && addModal.classList.contains('active')) {
                        document.getElementById('categoryColor').value = hex;
                        document.querySelectorAll('#addCategoryModal .color-option').forEach(opt => {
                            opt.classList.remove('selected');
                        });
                    } else if (editModal && editModal.classList.contains('active')) {
                        document.getElementById('editCategoryColor').value = hex;
                        document.querySelectorAll('#editCategoryModal .color-option').forEach(opt => {
                            opt.classList.remove('selected');
                        });
                    }
                    
                    e.target.classList.add('selected');
                }
            });

            // EVENT DELEGATION per i bottoni semplici
            document.addEventListener('click', (e) => {
                const btn = e.target.closest('.simple-btn');
                
                // LOG DEBUG - sia console che debug app
                if (btn) {
                    const logMsg = `üñ±Ô∏è CLICK: disabled=${btn.disabled}, action=${btn.dataset.action}`;
                    console.log(logMsg);
                    addDebugLog(logMsg);
                }
                
                if (!btn || btn.disabled) return;

                e.stopPropagation();

                const card = btn.closest('.day-card');
                if (!card) {
                    const msg = '‚ùå CARD NON TROVATA';
                    console.log(msg);
                    addDebugLog(msg);
                    return;
                }

                const habitId = card.dataset.habit;
                const action = btn.dataset.action;
                
                const cardMsg = `‚úÖ CARD: habit=${habitId?.substr(0,8)}, hasDate=${!!card.dataset.date}, hasWeek=${!!card.dataset.week}`;
                console.log(cardMsg);
                addDebugLog(cardMsg);

                // Controlla se √® dentro un time-slot (orari multipli)
                const timeSlot = btn.closest('[data-time]');
                if (timeSlot) {
                    addDebugLog('üïê TIME-SLOT TROVATO');
                    const time = timeSlot.dataset.time;
                    const dateStr = card.dataset.date;
                    
                    // Rileggi lo stato ATTUALE per questo orario
                    const completion = completions.find(c => {
                        if (c.habit_id !== habitId) return false;
                        if (!c.completed_at.startsWith(dateStr)) return false;
                        const compTime = new Date(c.completed_at).toTimeString().substr(0, 5);
                        return compTime === time;
                    });
                    
                    const isCompleted = completion && completion.status === 'completed';
                    const isFailed = completion && completion.status === 'failed';
                    
                    addDebugLog(`üïê ${time}: ${action}, completed=${isCompleted}, skipped=${isFailed}`);
                    
                    if (action === 'complete') {
                        setTimeState(habitId, time, dateStr, isCompleted ? 'none' : 'completed');
                    } else if (action === 'fail') {
                        setTimeState(habitId, time, dateStr, isFailed ? 'none' : 'failed');
                    }
                    return;
                }

                // Controlla se √® dentro un week-day (settimanale)
                const weekDay = btn.closest('[data-week-day]');
                if (weekDay) {
                    addDebugLog('üìÖ WEEK-DAY TROVATO');
                    const dateStr = weekDay.dataset.weekDay;
                    
                    // Rileggi lo stato ATTUALE per questo giorno
                    const completion = completions.find(c => 
                        c.habit_id === habitId && c.completed_at.startsWith(dateStr)
                    );
                    
                    const isCompleted = completion && completion.status === 'completed';
                    const isFailed = completion && completion.status === 'failed';
                    
                    addDebugLog(`üìÖ ${dateStr}: ${action}, completed=${isCompleted}, skipped=${isFailed}`);
                    
                    if (action === 'complete') {
                        setWeekDayState(habitId, dateStr, isCompleted ? 'none' : 'completed');
                    } else if (action === 'fail') {
                        setWeekDayState(habitId, dateStr, isFailed ? 'none' : 'failed');
                    }
                    return;
                }

                addDebugLog('üìÖ CARD NORMALE');

                // Altrimenti √® una card normale (giornaliera)
                const dateStr = card.dataset.date;

                // Rileggi lo stato ATTUALE
                const completion = completions.find(c => 
                    c.habit_id === habitId && c.completed_at.startsWith(dateStr)
                );
                
                const isCompleted = completion && completion.status === 'completed';
                const isFailed = completion && completion.status === 'failed';

                addDebugLog(`üîò ${dateStr}: ${action}, completed=${isCompleted}, skipped=${isFailed}`);

                if (action === 'complete') {
                    if (isCompleted) {
                        console.log('üü¢ Verde gi√† attivo ‚Üí DISATTIVA');
                        setDayState(habitId, dateStr, 'none');
                    } else {
                        console.log('üü¢ Verde non attivo ‚Üí ATTIVA');
                        setDayState(habitId, dateStr, 'completed');
                    }
                } else if (action === 'fail') {
                    if (isFailed) {
                        console.log('üî¥ Rosso gi√† attivo ‚Üí DISATTIVA');
                        setDayState(habitId, dateStr, 'none');
                    } else {
                        console.log('üî¥ Rosso non attivo ‚Üí ATTIVA');
                        setDayState(habitId, dateStr, 'failed');
                    }
                }
            });
        }
        
        function rgbToHex(rgb) {
            // Handle already hex colors
            if (rgb.startsWith('#')) return rgb;
            
            const values = rgb.match(/\d+/g);
            if (!values) return '#FF3366';
            
            const r = parseInt(values[0]);
            const g = parseInt(values[1]);
            const b = parseInt(values[2]);
            
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }

        // Notifications
        function requestNotificationPermission() {
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
        }

        function scheduleNotifications() {
            if (!settings.notificationsEnabled) return;
            
            const [hours, minutes] = settings.notificationTime.split(':');
            const now = new Date();
            const scheduled = new Date();
            scheduled.setHours(hours, minutes, 0, 0);

            if (scheduled <= now) {
                scheduled.setDate(scheduled.getDate() + 1);
            }

            const timeout = scheduled - now;
            
            setTimeout(() => {
                sendNotification();
                setInterval(sendNotification, 24 * 60 * 60 * 1000); // Daily
            }, timeout);
        }

        function sendNotification() {
            if ('Notification' in window && Notification.permission === 'granted') {
                const today = new Date().toISOString().split('T')[0];
                const todayCompletions = completions.filter(c => c.completed_at.startsWith(today));
                const activeHabits = habits.filter(h => h.status === 'active');
                const remaining = activeHabits.length - todayCompletions.length;

                if (remaining > 0) {
                    new Notification('Habit Stack Tracker', {
                        body: `Hai ancora ${remaining} abitudini da completare oggi! üí™`,
                        icon: 'üî•'
                    });
                }
            }
        }

        // Settings
        function loadSettings() {
            const saved = localStorage.getItem('habitTrackerSettings');
            if (saved) {
                settings = JSON.parse(saved);
                document.getElementById('notificationsEnabled').checked = settings.notificationsEnabled;
                document.getElementById('notificationTime').value = settings.notificationTime;
                
                if (settings.notificationsEnabled) {
                    scheduleNotifications();
                }
            }
        }

        function saveSettings() {
            settings.notificationsEnabled = document.getElementById('notificationsEnabled').checked;
            settings.notificationTime = document.getElementById('notificationTime').value;
            
            localStorage.setItem('habitTrackerSettings', JSON.stringify(settings));
            showToast('Impostazioni salvate');

            if (settings.notificationsEnabled) {
                scheduleNotifications();
            }
        }

        // Data Export/Import
        function exportData() {
            const data = {
                habits,
                categories,
                completions,
                exportDate: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `habit-tracker-export-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);

            showToast('Dati esportati con successo!');
        }

        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json';
            
            input.onchange = async (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                
                reader.onload = async (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        
                        if (confirm('Importare i dati? Questo sovrascriver√† i dati esistenti.')) {
                            // Import categories
                            for (const cat of data.categories) {
                                await supabaseClient.from('cm_categories').upsert(cat);
                            }

                            // Import habits
                            for (const habit of data.habits) {
                                await supabaseClient.from('hb_habits').upsert(habit);
                            }

                            // Import completions
                            for (const comp of data.completions) {
                                await supabaseClient.from('hb_completions').upsert(comp);
                            }

                            await loadCategories();
                            await loadHabits();
                            await loadCompletions();
                            
                            renderDashboard();
                            showToast('Dati importati con successo!');
                        }
                    } catch (error) {
                        console.error('Error importing data:', error);
                        showToast('Errore nell\'importazione dei dati');
                    }
                };
                
                reader.readAsText(file);
            };
            
            input.click();
        }

        function renderArchive() {
            const container = document.getElementById('archivedStacksList');
            
            if (archivedStacks.length === 0) {
                container.innerHTML = '<p style="opacity: 0.7; text-align: center; padding: 2rem;">Nessuno stack archiviato ancora. üì¶</p>';
                return;
            }
            
            const html = archivedStacks.map(stack => {
                const category = categories.find(c => c.id === stack.category_id);
                const duration = `${stack.started_at} ‚Üí ${stack.ended_at}`;
                const reasonText = stack.reason === 'jolly_esauriti' ? 'üíÄ Jolly Esauriti' : '‚úÖ Completato';
                
                return `
                    <div class="card" style="margin-bottom: 1rem; border-left: 4px solid ${category?.color || '#ccc'};">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 1rem;">
                            <div>
                                <h3 style="margin: 0 0 0.5rem 0; display: flex; align-items: center; gap: 0.5rem;">
                                    ${category ? category.icon : 'üìå'} ${stack.habit_name}
                                </h3>
                                <p style="opacity: 0.7; margin: 0; font-size: 0.9rem;">${duration}</p>
                            </div>
                            <span style="padding: 0.3rem 0.8rem; background: ${stack.reason === 'jolly_esauriti' ? '#ffebee' : '#e8f5e9'}; border-radius: 20px; font-size: 0.85rem;">
                                ${reasonText}
                            </span>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 1rem;">
                            <div style="text-align: center;">
                                <div style="font-size: 1.5rem;">üî•</div>
                                <div style="font-size: 1.2rem; font-weight: bold;">${stack.final_streak}</div>
                                <div style="opacity: 0.7; font-size: 0.85rem;">Streak</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 1.5rem;">üìÖ</div>
                                <div style="font-size: 1.2rem; font-weight: bold;">${stack.total_days}</div>
                                <div style="opacity: 0.7; font-size: 0.85rem;">Giorni</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 1.5rem;">‚úÖ</div>
                                <div style="font-size: 1.2rem; font-weight: bold;">${stack.total_completions}</div>
                                <div style="opacity: 0.7; font-size: 0.85rem;">Successi</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 1.5rem;">‚ùå</div>
                                <div style="font-size: 1.2rem; font-weight: bold;">${stack.total_failures}</div>
                                <div style="opacity: 0.7; font-size: 0.85rem;">Fallimenti</div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            container.innerHTML = html;
        }

        // Initialize app when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
