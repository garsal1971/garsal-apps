<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AppSphere v1.1.1</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@500;600&family=DM+Mono:wght@400&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html { overflow: hidden; height: 100%; }
  body {
    background: #fff;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    font-family: 'DM Sans', sans-serif;
    user-select: none;
  }
  #field {
    position: fixed;
    inset: 0;
    overflow: hidden;
  }
  .cw {
    position: absolute;
    transform: translate(-50%, -50%);
    cursor: grab;
    touch-action: none;
    will-change: left, top;
  }
  .cw.dragging { cursor: grabbing; z-index: 1000 !important; }
  .cw.dragging .circle {
    box-shadow: 0 16px 48px rgba(0,0,0,0.2);
    transform: scale(1.05);
  }
  .cw.pushed .circle {
    transition: none;
  }
  .circle {
    border-radius: 50%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transition: box-shadow 0.2s, transform 0.2s;
  }
  .cw:not(.dragging):hover .circle {
    box-shadow: 0 6px 20px rgba(0,0,0,0.15);
  }
  .c-name {
    font-weight: 600;
    color: #fff;
    text-align: center;
    line-height: 1.2;
    word-break: break-word;
    overflow-wrap: break-word;
    hyphens: auto;
    pointer-events: none;
    text-shadow: 0 1px 4px rgba(0,0,0,0.2);
    max-width: 75%;
  }
  .c-score {
    font-family: 'DM Mono', monospace;
    color: rgba(255,255,255,0.75);
    margin-top: 4px;
    pointer-events: none;
  }
  .cw:not(.dragging):hover .tip { opacity: 1; transform: translateX(-50%) translateY(0); }
  .tip {
    position: absolute;
    bottom: calc(100% + 10px);
    left: 50%;
    transform: translateX(-50%) translateY(5px);
    background: #111;
    color: #fff;
    border-radius: 8px;
    padding: 8px 14px;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.15s, transform 0.15s;
    z-index: 9999;
    font-size: 12px;
  }
  .tip::after {
    content: '';
    position: absolute;
    top: 100%; left: 50%;
    transform: translateX(-50%);
    border: 5px solid transparent;
    border-top-color: #111;
  }
  .tip-name { font-weight: 600; margin-bottom: 2px; }
  .tip-meta { color: #aaa; font-size: 11px; font-family: 'DM Mono', monospace; }

  /* ── SCORE PANEL ── */
  #score-panel {
    position: fixed;
    bottom: 20px;
    left: 20px;
    background: #EE334E;
    border: 4px solid #111;
    border-radius: 10px;
    padding: 10px 20px 12px;
    z-index: 200;
    display: none;
    flex-direction: column;
    gap: 2px;
    min-width: 110px;
    pointer-events: none;
  }
  #score-panel.visible { display: flex; }
  .sp-label {
    font-family: 'DM Sans', sans-serif;
    font-size: 10px;
    font-weight: 600;
    color: rgba(255,255,255,0.7);
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }
  .sp-value {
    font-family: 'DM Mono', monospace;
    font-size: 30px;
    font-weight: 400;
    color: #fff;
    line-height: 1;
    text-shadow: 0 1px 4px rgba(0,0,0,0.2);
  }

  @keyframes popIn {
    from { opacity:0; transform:translate(-50%,-50%) scale(0.2); }
    to   { opacity:1; transform:translate(-50%,-50%) scale(1); }
  }

  /* ── LOGIN ── */
  #login-screen {
    position: fixed;
    inset: 0;
    background: #fff;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    transition: opacity 0.5s ease;
  }
  #login-screen.hidden {
    opacity: 0;
    pointer-events: none;
  }
  .login-card {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0;
    text-align: center;
  }
  .login-title {
    font-size: 28px;
    font-weight: 600;
    color: #111;
    letter-spacing: -0.5px;
    margin-bottom: 6px;
  }
  .login-sub {
    font-family: 'DM Mono', monospace;
    font-size: 12px;
    color: #aaa;
    margin-bottom: 36px;
  }
  .google-btn {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 13px 24px;
    background: #fff;
    border: 1.5px solid #ddd;
    border-radius: 10px;
    font-family: 'DM Sans', sans-serif;
    font-size: 14px;
    font-weight: 600;
    color: #111;
    cursor: pointer;
    transition: border-color 0.2s, box-shadow 0.2s;
  }
  .google-btn:hover {
    border-color: #aaa;
    box-shadow: 0 4px 16px rgba(0,0,0,0.08);
  }
  .google-icon { width: 18px; height: 18px; flex-shrink: 0; }

  /* ── NOME UTENTE IN ALTO ── */
  #user-bar {
    position: fixed;
    top: 16px;
    right: 20px;
    display: none;
    align-items: center;
    gap: 10px;
    z-index: 500;
    font-family: 'DM Mono', monospace;
    font-size: 12px;
    color: #888;
  }
  #user-bar.visible { display: flex; }
  #logout-btn {
    padding: 5px 12px;
    border: 1px solid #ddd;
    border-radius: 6px;
    background: #fff;
    font-family: 'DM Mono', monospace;
    font-size: 11px;
    color: #888;
    cursor: pointer;
    transition: border-color 0.2s;
  }
  #logout-btn:hover { border-color: #aaa; color: #111; }
</style>
</head>
<body>

<!-- LOGIN -->
<div id="login-screen">
  <div class="login-card">
    <div class="login-title">AppSphere</div>
    <div class="login-sub">// il tuo universo di applicazioni</div>
    <button class="google-btn" onclick="loginWithGoogle()">
      <svg class="google-icon" viewBox="0 0 24 24">
        <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/>
        <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/>
        <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"/>
        <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/>
      </svg>
      Accedi con Google
    </button>
  </div>
</div>

<!-- UTENTE BAR -->
<div id="user-bar">
  <span id="user-name"></span>
  <button id="logout-btn" onclick="logout()">Esci</button>
</div>

<div id="field"></div>

<!-- SCORE PANEL -->
<div id="score-panel">
  <div class="sp-label">Totale</div>
  <div class="sp-value" id="sp-value">—</div>
</div>

<script>
const OLYMPIC = ['#0081C8','#FCB131','#1A1A1A','#00A651','#EE334E'];

const PAD = 12;
const GAP = 8; // minimum gap between circles

const APP_VERSION = 'v1.1.1';
const BUILD_TIME  = '2026-03-01T00:00:00Z';
console.log('%c AppSphere ' + APP_VERSION + ' %c build: ' + BUILD_TIME,
    'background:#0081C8;color:#fff;font-weight:bold;padding:2px 6px;border-radius:3px 0 0 3px',
    'background:#222;color:#aaa;padding:2px 6px;border-radius:0 3px 3px 0');

function clamp(v, lo, hi) { return Math.min(hi, Math.max(lo, v)); }

function getScorePanelRect() {
  const el = document.getElementById('score-panel');
  if (!el || !el.classList.contains('visible')) return null;
  const r = el.getBoundingClientRect();
  return { x: r.left, y: r.top, w: r.width, h: r.height };
}

function pushFromPanel(cx, cy, r, panel) {
  if (!panel) return { x: cx, y: cy };
  const closestX = clamp(cx, panel.x, panel.x + panel.w);
  const closestY = clamp(cy, panel.y, panel.y + panel.h);
  const dx = cx - closestX;
  const dy = cy - closestY;
  const dist = Math.hypot(dx, dy) || 0.001;
  const minDist = r + GAP;
  if (dist < minDist) {
    const scale = (minDist - dist) / dist;
    return { x: cx + dx * scale, y: cy + dy * scale };
  }
  return { x: cx, y: cy };
}

let nodes = []; // { el, x, y, r, app }
let W, H;

// ── SIZE ──
function sizeOf(score) {
  const min = Math.min(...CURRENT_APPS.map(a => a.score));
  const max = Math.max(...CURRENT_APPS.map(a => a.score));
  return Math.round(72 + ((score + 1000 - min) / (max + 1000 - min || 1)) * 130);
}

// ── INITIAL PACK (no overlap) ──
function initialPlace(r, existingNodes) {
  const cx = W / 2;
  const cy = H / 2;
  const panel = getScorePanelRect();

  function overlapsPanelAt(x, y) {
    if (!panel) return false;
    const closestX = clamp(x, panel.x, panel.x + panel.w);
    const closestY = clamp(y, panel.y, panel.y + panel.h);
    return Math.hypot(x - closestX, y - closestY) < r + GAP;
  }

  // Start tight at center, expand spread until a non-overlapping spot is found
  for (let attempt = 0; attempt < 200; attempt++) {
    const spread = r + attempt * (r * 0.5);
    for (let i = 0; i < 30; i++) {
      const angle = Math.random() * Math.PI * 2;
      const dist  = Math.random() * spread;
      const x = clamp(cx + Math.cos(angle) * dist, r + PAD, W - r - PAD);
      const y = clamp(cy + Math.sin(angle) * dist, r + PAD, H - r - PAD);
      const okCircles = existingNodes.every(n => Math.hypot(x - n.x, y - n.y) >= r + n.r + GAP);
      if (okCircles && !overlapsPanelAt(x, y)) return { x, y };
    }
  }
  return { x: cx, y: cy };
}

// ── COLLISION RESOLUTION ──
// Phase 1: push non-dragged circles away (dragged pinned).
// Phase 2: back-pressure — if dragged still overlaps anything (circles backed
//          against a wall), push the dragged circle back to eliminate all overlap.
function resolveCollisions(draggedId) {
  const MAIN_ITERS = 80;
  const BACK_ITERS = 30;
  const panel = getScorePanelRect();

  // ── Phase 1 ──
  for (let iter = 0; iter < MAIN_ITERS; iter++) {
    let moved = false;

    for (let a = 0; a < nodes.length; a++) {
      for (let b = a + 1; b < nodes.length; b++) {
        const na = nodes[a];
        const nb = nodes[b];
        const minDist = na.r + nb.r + GAP;
        const dx = nb.x - na.x;
        const dy = nb.y - na.y;
        const dist = Math.hypot(dx, dy) || 0.01;
        if (dist >= minDist) continue;

        moved = true;
        const push = (minDist - dist) / dist;

        if (na.id === draggedId) {
          nb.x += dx * push;
          nb.y += dy * push;
        } else if (nb.id === draggedId) {
          na.x -= dx * push;
          na.y -= dy * push;
        } else {
          na.x -= dx * push * 0.5;
          na.y -= dy * push * 0.5;
          nb.x += dx * push * 0.5;
          nb.y += dy * push * 0.5;
        }
      }
    }

    // Clamp non-dragged to viewport and push away from score panel
    nodes.forEach(n => {
      if (n.id === draggedId) return;
      const p = pushFromPanel(n.x, n.y, n.r, panel);
      if (p.x !== n.x || p.y !== n.y) moved = true;
      n.x = clamp(p.x, n.r + PAD, W - n.r - PAD);
      n.y = clamp(p.y, n.r + PAD, H - n.r - PAD);
    });

    if (!moved) break;
  }

  // ── Phase 2: back-pressure ──
  // If dragged circle still overlaps something (e.g. others are against the wall),
  // push the dragged circle back until there is no overlap.
  const dn = nodes.find(n => n.id === draggedId);
  if (!dn) return;

  for (let iter = 0; iter < BACK_ITERS; iter++) {
    let moved = false;

    for (const n of nodes) {
      if (n.id === draggedId) continue;
      const minDist = dn.r + n.r + GAP;
      const dx = n.x - dn.x;
      const dy = n.y - dn.y;
      const dist = Math.hypot(dx, dy) || 0.01;
      if (dist < minDist) {
        moved = true;
        const push = (minDist - dist) / dist;
        dn.x -= dx * push;
        dn.y -= dy * push;
      }
    }

    // Keep dragged away from score panel and viewport edges
    const p = pushFromPanel(dn.x, dn.y, dn.r, panel);
    dn.x = clamp(p.x, dn.r + PAD, W - dn.r - PAD);
    dn.y = clamp(p.y, dn.r + PAD, H - dn.r - PAD);

    if (!moved) break;
  }
}

// ── APPLY POSITIONS TO DOM ──
function applyPositions(draggedId) {
  nodes.forEach(n => {
    n.el.style.left = n.x + 'px';
    n.el.style.top  = n.y + 'px';
    if (n.id !== draggedId) {
      n.el.classList.add('pushed');
      // remove pushed class after a tick so transitions stay off only during move
    }
  });
}

// ── FIT FONT SIZE ──
// Binary search: largest font-size where text block fits inside circle's inscribed square
function fitFontSize(name, circleSize) {
  const maxW = circleSize * 0.64;
  const maxH = circleSize * 0.64;

  const el = document.createElement('span');
  el.style.cssText = [
    'position:absolute',
    'visibility:hidden',
    'pointer-events:none',
    'white-space:normal',
    `max-width:${maxW}px`,
    'word-break:break-word',
    'text-align:center',
    "font-family:'DM Sans',sans-serif",
    'font-weight:600',
    'line-height:1.2',
  ].join(';');
  el.textContent = name;
  document.body.appendChild(el);

  let lo = 8, hi = circleSize * 0.55;
  for (let i = 0; i < 20; i++) {
    const mid = (lo + hi) / 2;
    el.style.fontSize = mid + 'px';
    if (el.offsetWidth <= maxW && el.offsetHeight <= maxH) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  document.body.removeChild(el);
  return Math.floor(lo);
}

// ── BUILD DOM ──
let CURRENT_APPS = [];

function render(apps) {
  if (apps) CURRENT_APPS = apps;
  const field = document.getElementById('field');
  W = field.offsetWidth;
  H = field.offsetHeight;
  field.innerHTML = '';
  nodes = [];

  const sorted = [...CURRENT_APPS].sort((a, b) => b.score - a.score);

  sorted.forEach((app, i) => {
    const size = sizeOf(app.score);
    const r = size / 2;
    const pos = initialPlace(r, nodes);

    const color = OLYMPIC[i % OLYMPIC.length];
    const nameFz  = fitFontSize(app.name, size);
    const scoreFz = Math.max(8, size * 0.075);

    const wrap = document.createElement('div');
    wrap.className = 'cw';
    wrap.style.left = pos.x + 'px';
    wrap.style.top  = pos.y + 'px';
    wrap.style.zIndex = i + 1;
    wrap.style.animation = `popIn 0.4s cubic-bezier(0.34,1.56,0.64,1) ${i * 0.07}s both`;

    wrap.innerHTML = `
      <div class="circle" style="width:${size}px;height:${size}px;background:${color};border:4px solid #111;">
        <span class="c-name" style="font-size:${nameFz}px">${app.name}</span>
        <span class="c-score" style="font-size:${scoreFz}px">${app.score}</span>
      </div>
      <div class="tip">
        <div class="tip-name">${app.name}</div>
        <div class="tip-meta">${app.description} · ${app.score} pts</div>
      </div>
    `;

    const node = { id: app.id, el: wrap, x: pos.x, y: pos.y, r, app };
    nodes.push(node);
    makeDraggable(node);
    field.appendChild(wrap);
  });

  // Update total score in the panel
  const total = CURRENT_APPS.reduce((s, a) => s + a.score, 0);
  const spv = document.getElementById('sp-value');
  if (spv) spv.textContent = total.toLocaleString('it-IT');
}

// ── DRAG ──
let zTop = 100;

function makeDraggable(node) {
  const el = node.el;
  let dragging = false;
  let startX, startY, origX, origY, moved;

  function getXY(e) {
    return e.touches
      ? { x: e.touches[0].clientX, y: e.touches[0].clientY }
      : { x: e.clientX, y: e.clientY };
  }

  function onDown(e) {
    const { x, y } = getXY(e);
    startX = x; startY = y;
    origX = node.x; origY = node.y;
    dragging = true; moved = false;
    el.style.zIndex = ++zTop;
    window.addEventListener('mousemove', onMove);
    window.addEventListener('touchmove', onMove, { passive: false });
    window.addEventListener('mouseup', onUp);
    window.addEventListener('touchend', onUp);
  }

  function onMove(e) {
    if (!dragging) return;
    e.preventDefault();
    const { x, y } = getXY(e);
    const dx = x - startX;
    const dy = y - startY;

    if (!moved && Math.hypot(dx, dy) > 4) {
      moved = true;
      el.classList.add('dragging');
    }
    if (!moved) return;

    // Update dragged node position (clamped)
    node.x = Math.min(W - node.r - PAD, Math.max(node.r + PAD, origX + dx));
    node.y = Math.min(H - node.r - PAD, Math.max(node.r + PAD, origY + dy));

    // Resolve collisions keeping this node pinned
    resolveCollisions(node.id);

    // Apply all positions
    applyPositions(node.id);
  }

  function onUp() {
    dragging = false;
    el.classList.remove('dragging');
    nodes.forEach(n => n.el.classList.remove('pushed'));
    window.removeEventListener('mousemove', onMove);
    window.removeEventListener('touchmove', onMove);
    window.removeEventListener('mouseup', onUp);
    window.removeEventListener('touchend', onUp);
    if (!moved) launchApp(node.app);
  }

  el.addEventListener('mousedown', onDown);
  el.addEventListener('touchstart', onDown, { passive: true });
}

function launchApp(app) {
  const win = window.open(app.html_file, '_blank');

  // Passa i token all'app figlia via postMessage (dopo 1s per attesa caricamento)
  const googleToken = sessionStorage.getItem('google_token');
  const sbToken     = sessionStorage.getItem('sb_token');
  if (win) {
    setTimeout(() => {
      if (googleToken) win.postMessage({ type: 'GOOGLE_TOKEN', token: googleToken }, '*');
      if (sbToken)     win.postMessage({ type: 'SB_TOKEN',     token: sbToken     }, '*');
    }, 1000);
  }
}

// ── AUTH ──
const SUPABASE_URL = 'https://jajlmmdsjlvzgcxiiypk.supabase.co';
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImphamxtbWRzamx2emdjeGlpeXBrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njk5NTU0NjYsImV4cCI6MjA4NTUzMTQ2Nn0.ikaipwxOvIn43epayQ4mSZQkXtin3aaGEPouafwJFxU';

function loginWithGoogle() {
  const redirect = window.location.href.split('#')[0].split('?')[0];
  const scopes = [
    'email',
    'profile',
    'https://www.googleapis.com/auth/fitness.activity.read',
    'https://www.googleapis.com/auth/fitness.body.read',
    'https://www.googleapis.com/auth/fitness.nutrition.read',
  ].join(' ');
  window.location.href = `${SUPABASE_URL}/auth/v1/authorize?provider=google`
    + `&redirect_to=${encodeURIComponent(redirect)}`
    + `&scopes=${encodeURIComponent(scopes)}`
    + `&access_type=offline`;
}

async function logout() {
  const token = sessionStorage.getItem('sb_token');
  if (token) {
    await fetch(`${SUPABASE_URL}/auth/v1/logout`, {
      method: 'POST',
      headers: { 'apikey': SUPABASE_KEY, 'Authorization': 'Bearer ' + token }
    }).catch(() => {});
  }
  sessionStorage.removeItem('sb_token');
  document.getElementById('user-bar').classList.remove('visible');
  document.getElementById('score-panel').classList.remove('visible');
  document.getElementById('sp-value').textContent = '—';
  document.getElementById('login-screen').classList.remove('hidden');
}

function parseHash() {
  const hash = window.location.hash.slice(1);
  if (!hash) return null;
  const p = {};
  hash.split('&').forEach(kv => { const [k,v] = kv.split('='); p[decodeURIComponent(k)] = decodeURIComponent(v||''); });
  if (p.access_token) {
    sessionStorage.setItem('sb_token', p.access_token);
    // provider_token = token Google reale, usabile con Google Fit API
    if (p.provider_token) sessionStorage.setItem('google_token', p.provider_token);
    history.replaceState(null, '', window.location.pathname);
    return p.access_token;
  }
  return null;
}

async function getUserInfo(token) {
  const res = await fetch(`${SUPABASE_URL}/auth/v1/user`, {
    headers: { 'apikey': SUPABASE_KEY, 'Authorization': 'Bearer ' + token }
  });
  return res.ok ? res.json() : null;
}

function showApp(user) {
  const name = user?.user_metadata?.full_name || user?.email || 'Utente';
  document.getElementById('user-name').textContent = name.split(' ')[0];
  document.getElementById('user-bar').classList.add('visible');
  document.getElementById('score-panel').classList.add('visible');
  const ls = document.getElementById('login-screen');
  ls.classList.add('hidden');
  setTimeout(() => {
    ls.style.display = 'none';
    loadApps();
  }, 500);
}

// ── CARICA APP DA SUPABASE ──
async function loadApps() {
  const token = sessionStorage.getItem('sb_token');

  // 1. Leggi tutte le app attive
  const res = await fetch(
    `${SUPABASE_URL}/rest/v1/cm_apps?active=eq.true&select=id,title,description,score_query,html_file,color&order=id.asc`,
    {
      headers: {
        'apikey': SUPABASE_KEY,
        'Authorization': 'Bearer ' + token,
        'Content-Type': 'application/json',
      }
    }
  );

  if (!res.ok) {
    console.error('Errore fetch cm_apps:', await res.text());
    return;
  }

  const rows = await res.json();

  // 2. Per ogni app esegui la score_query
  const apps = await Promise.all(rows.map(async (row, i) => {
    let score = 0;
    try {
      const rpc = await fetch(`${SUPABASE_URL}/rest/v1/rpc/run_score_query`, {
        method: 'POST',
        headers: {
          'apikey': SUPABASE_KEY,
          'Authorization': 'Bearer ' + token,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ query: row.score_query })
      });
      if (rpc.ok) score = Number(await rpc.json()) || 0;
    } catch(e) {
      console.warn('Score query fallita per', row.title, e);
    }

    return {
      id:          row.id,
      name:        row.title,
      description: row.description || '',
      score:       score,
      color:       row.color || OLYMPIC[i % OLYMPIC.length],
      html_file:   row.html_file,
    };
  }));

  render(apps);
}

async function init() {
  const token = parseHash() || sessionStorage.getItem('sb_token');
  if (token) {
    const user = await getUserInfo(token);
    if (user) { showApp(user); return; }
    sessionStorage.removeItem('sb_token');
  }
  // show login
}
init();

window.addEventListener('resize', () => { if (CURRENT_APPS.length) render(); });
</script>
</body>
</html>
